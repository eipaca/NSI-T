{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"A propos","text":"<p>Bienvenue sur le site de ressources du cours de Terminale NSI de l'Ecole Internationale PACA .</p> <p>L'image <code>gif</code> ci-dessous pr\u00e9sente un programme Python de r\u00e9solution automatique de jeux de D\u00e9mineurs par intelligence artificielle (AI) r\u00e9alis\u00e9 par un \u00e9l\u00e8ve dans le cadre de son projet en classe de Terminale NSI. </p> <p> </p> \"R\u00e9solution de D\u00e9mineurs par intelligence artificielle (AI)\" par Louis, \u00e9l\u00e8ve de Terminale NSI, 2022-23"},{"location":"#programme-de-terminale-nsi","title":"Programme de Terminale NSI","text":"<ul> <li>Le  programme officiel.</li> </ul>"},{"location":"#comment-est-construit-ce-site","title":"Comment est construit ce site ?","text":"<p>Ce site est r\u00e9dig\u00e9 en Markdown avec le th\u00e8me Material for MkDocs.</p>"},{"location":"algorithmique/","title":"Algorithmique","text":"<p>Un algorithme<sup>1</sup>  est un \u00e9nonc\u00e9 d'une suite d'op\u00e9rations \u00e9l\u00e9mentaire permettant de r\u00e9soudre un probl\u00e8me. On a \u00e9tudi\u00e9 en classe de premi\u00e8re quelques algorithmes classiques :</p> <ul> <li>Recherche et tri de tableau</li> <li>Algorithme des k plus proches voisins (un exemple d'algorithme d'apprentissage)</li> <li>Recherche dichotomique dans un tableau tri\u00e9</li> <li>Algorithmes gloutons <sup>2</sup></li> </ul> <p>L'analyse de la complexit\u00e9, ou co\u00fbt, d'un algorithme consiste en l'\u00e9tude de la quantit\u00e9 de ressources n\u00e9cessaire \u00e0 l'ex\u00e9cution de cet algorithme. On distingue principalement deux types de complexit\u00e9 :</p> <ul> <li>La complexit\u00e9 spatiale qui mesure l'utilisation de l'espace m\u00e9moire.</li> <li>La complexit\u00e9 temporelle qui ne mesure pas le temps de calcul (qui d\u00e9pend de l'ordinateur, du langage de programmation, du compilateur ou de l'interpr\u00e9teur, des performances de la machine, etc) mais plut\u00f4t l'ordre de grandeur du nombre d'op\u00e9rations \u00e9l\u00e9mentaires (affectation, calcul, comparaison, etc.) dans le pire des cas, ou plus pr\u00e9cis\u00e9ment la vitesse de croissance de ce nombre  (aux constantes pr\u00e8s). </li> </ul> <p>Les principales complexit\u00e9s temporelles sont les suivantes :</p> Notation D\u00e9sigantion Exemples \\(O(1)\\) constante Acc\u00e8s \u00e0 un \u00e9l\u00e9ment d'un tableau \\(O(log_2(n))\\) logarithmique<sup>3</sup> Recherche dichotomique (tableau tri\u00e9) \\(O(n)\\) lin\u00e9aire Recherche dans un tableau \\(O(n \\times log_2(n))\\) lin\u00e9arithmique<sup>4</sup> Tri fusion \\(O(n^2)\\) quadratique Tri \u00e0 bulle, parcours de matrice \\(O(a^n)\\) exponentielle<sup>5</sup>: Sac \u00e0 dos \\(O(n!)\\) factorielle Voyageur de commerce <p></p> <ol> <li> <p>Le mot \u00ab algorithme \u00bb vient du nom du math\u00e9maticien Al Khwarizmi, qui \u00e9crivit au 9\u00e8me si\u00e8cle le premier ouvrage syst\u00e9matique sur la solution d'\u00e9quations lin\u00e9aires et quadratiques.\u00a0\u21a9</p> </li> <li> <p>Un algorithme glouton suit le principe de faire, \u00e9tape par \u00e9tape, un choix optimum local, dans l'espoir d'obtenir un r\u00e9sultat optimum global.\u00a0\u21a9</p> </li> <li> <p>Ou quasi lin\u00e9aire, quand n vaut 1 milliard \\(log_2(10^9) = 30\\).\u00a0\u21a9</p> </li> <li> <p>Le \"logarithme base 2\" not\u00e9 \\(log_2\\). Par d\u00e9finition \\(log_2(2^x) = x\\).\u00a0\u21a9</p> </li> <li> <p>Consid\u00e9r\u00e9s comme infaisables d\u00e8s que \\(n\\) n'est pas tr\u00e8s petit. On peut comparer \\(2^{250} = 10^8\\) avec \\(250^2=62500\\).\u00a0\u21a9</p> </li> </ol>"},{"location":"algorithmique/1-arbres-binaires/","title":"Algorithmes sur les arbres binaires et sur les arbres binaires de recherche","text":"<p>Cours</p> <p>Un arbre est une structure de donn\u00e9es hi\u00e9rarchique (les n\u0153uds sont li\u00e9s par des relations p\u00e8re-fils) et r\u00e9cursive. </p> <p>Un arbre binaire (AB) est un cas particulier d'arbre o\u00f9 chaque n\u0153ud poss\u00e8de au maximum deux fils ordonn\u00e9s : un fils gauche et/ou un fils droit. Ils ne sont pas intervertibles !</p> <p>La plupart des exercices de baccalaur\u00e9at n'ont qu'une seule classe r\u00e9cursive et se contentent d'impl\u00e9menter des arbres non vides, dit \"enracin\u00e9s\".</p> <p>On a d\u00e9j\u00e0 impl\u00e9ment\u00e9 un arbre binaire et ses n\u0153uds en Python avec deux classes, une classe <code>AB</code> permettant d'impl\u00e9menter un arbre vide, et une classe <code>Noeud</code> r\u00e9cursive :</p> <p> </p> <pre><code>class AB: \n    def __init__(self, racine = None): \n        self.racine = racine # type : Noeud \n\nclass Noeud: \n    def __init__(self, v, g = None, d = None): \n        self.gauche = g # type Noeud \n        self.droite = d # type Noeud \n        self.valeur = v\n</code></pre> <p>Impl\u00e9mentons l'arbre ci-contre.</p> <pre><code>n9, n4 = Noeud(9), Noeud(4)\nn1, n12 = Noeud(1, n9, n4), Noeud(12)\nn6 = Noeud(6, n1, n12)\nn3 = Noeud(3)\nn10 = Noeud(10, d = n3)\narbre = AB(Noeud(5, n10, n6))\n</code></pre>"},{"location":"algorithmique/1-arbres-binaires/#calcul-de-la-taille-dun-arbre-binaire","title":"Calcul de la taille d'un arbre binaire","text":"<p>Cours</p> <p>La taille d'un arbre est son nombre de n\u0153uds. Un arbre vide a une taille de 0.</p> <p>De fa\u00e7on g\u00e9n\u00e9rale, pour calculer la taille d'un arbre, il suffit de compter le nombre de n\u0153uds \u00e0 partir de la racine en parcourant toutes les branches.</p> <p>Dans le cas d'un arbre binaire impl\u00e9ment\u00e9 comme d\u00e9crit ci-dessus, on peut cr\u00e9er une m\u00e9thode r\u00e9cursive, <code>taille()</code>,  de la classe <code>Noeud</code>. Cette m\u00e9thode renvoie la 1 plus somme des tailles des deux fils d'un n\u0153ud. Ainsi on parcourt tout l'arbre en partant de sa racine.</p> <p> </p> <p>Pour la classe <code>AB</code>, on ajoute une autre m\u00e9thode appel\u00e9e aussi <code>taille()</code> qui renvoie <code>0</code> pour l'arbre vide ou sinon la taille de la racine.</p> <pre><code>class AB: \n    def taille(self):\n        if self.racine == None: return 0\n # renvoie la taille du n\u0153ud racine\n        return self.racine.taille()\n\nclass Noeud: \n\n    def taille(self):\n        # taille du sous arbre gauche\n        if self.gauche is None:\n            tg = 0  \n        else:\n            tg = self.gauche.taille()\n\n        # taille du sous arbre droit\n        if self.droite is None:\n            td = 0\n        else:\n            td = self.droite.taille()\n\n        # la taille est 1 + la somme des deux \n        return 1 + td + tg\n</code></pre> <p>Calculons la taille de l'arbre pr\u00e9c\u00e9dent :</p> <pre><code>&gt;&gt;&gt; arbre.taille()\n8\n</code></pre> <p>Le calcul de la taille a un co\u00fbt proportionnel \u00e0 au nombre de n\u0153uds \\(n\\) de l'arbre (pour chaque n\u0153ud suppl\u00e9mentaire, on rajoute 3 op\u00e9rations). La complexit\u00e9 du calcul de la taille est en \\(O(n)\\). </p>"},{"location":"algorithmique/1-arbres-binaires/#calcul-de-la-hauteur-dun-arbre-binaire","title":"Calcul de la hauteur d'un arbre binaire","text":"<p> Il n'existe pas de d\u00e9finition universelle pour la hauteur d'un arbre et la profondeur d'un n\u0153ud dans un arbre. Dans certains cas la profondeur des n\u0153uds est compt\u00e9e \u00e0 partir de 0, la hauteur de l'arbre r\u00e9duit \u00e0 la racine est 0 et la hauteur de l'arbre vide est -1 (par convention).</p> <p>Cours</p> <ul> <li> <p>La profondeur d'un n\u0153ud est le nombre de n\u0153uds du chemin qui va de la racine jusqu'\u00e0 ce n\u0153ud. La profondeur de la racine est donc 1.</p> </li> <li> <p>La hauteur d'un arbre est le nombre de n\u0153uds (ou niveaux) du plus long chemin d\u2019une feuille \u00e0 la racine. Un arbre r\u00e9duit \u00e0 la racine a une hauteur de 1, un arbre vide a une hauteur de 0.</p> </li> </ul> <p>Pour calculer la hauteur d'un arbre, il faut parcourir toutes ses branches \u00e0 partir de la racine et prendre la profondeur de la feuille la plus \u00e9loign\u00e9e. </p> <p> </p> <p>Dans le cas arbre binaire impl\u00e9ment\u00e9 comme d\u00e9crit ci-dessus, on peut \u00e0 nouveau cr\u00e9er une m\u00e9thode r\u00e9cursive, <code>hauteur()</code>, de la classe <code>Noeud</code>. Cette m\u00e9thode renvoie la 1 plus la plus grande hauteurs de ses deux fils.  Les feuilles hauteur ont une hauteur de 1 (avec la convention choisie ici).</p> <p>Pour la classe <code>AB</code>, on ajoute une autre m\u00e9thode appel\u00e9e aussi <code>hauteur()</code> qui renvoie <code>0</code> pour l'arbre vide ou sinon la hauteur du N\u0153ud racine.</p> <pre><code>class AB: \n\n    def hauteur(self):\n        if self.racine == None: return 0\n        # renvoie la hauteur du n\u0153ud racine\n        return self.racine.hauteur()\n\nclass Noeud:     \n    def hauteur(self):\n        # hauteur du sous arbre gauche\n        if self.gauche is None:\n            hg = 0  # par convention l'arbre vide a une hauteur de 0\n        else:\n            hg = self.gauche.hauteur()\n\n        # hauteur du sous arbre droit\n        if self.droite is None:\n            hd = 0  # par convention l'arbre vide a une hauteur de 0\n        else:\n            hd = self.droite.hauteur()\n\n        # la hauteur est 1 + le plus grand des deux\n        return 1 + max(hg, hd)\n</code></pre> <p>Le calcul de la hauteur a un co\u00fbt proportionnel \u00e0 la taille du nombre de n\u0153uds \\(n\\) de l'arbre (pour chaque n\u0153ud suppl\u00e9mentaire, on rajoute 3 op\u00e9rations). La complexit\u00e9 du calcul de la hauteur est en \\(O(n)\\).</p>"},{"location":"algorithmique/1-arbres-binaires/#parcourir-un-arbre-binaire","title":"Parcourir un arbre binaire","text":"<p>Parcourir un arbre binaire consiste \u00e0 visiter tous les n\u0153uds que contient cet arbre. Il existe de nombreux algorithmes de parcours qui visitent chaque n\u0153uds dans un ordre diff\u00e9rent, les plus courants<sup>1</sup> sont le parcours en largeur et le parcours en profondeur.</p>"},{"location":"algorithmique/1-arbres-binaires/#parcours-en-largeur-bfs","title":"Parcours en largeur (BFS)","text":"<p>Cours</p> <p>Le parcours en largeur ou BFS (Breadth First Search), consiste \u00e0 parcourir l'arbre niveau par niveau, en partant de la racine. Les n\u0153uds de niveau 0 sont d'abord parcourus puis les n\u0153uds de niveau 1 et ainsi de suite. Dans chaque niveau, les n\u0153uds sont parcourus de la gauche vers la droite.</p> <p> </p> <p>L'impl\u00e9mentation se fait naturellement en utilisant une structure en file : </p> <ul> <li>La racine est d'abord mise dans la file, puis</li> <li>Tant que la file n'est pas vide:<ul> <li>On d\u00e9file le premier n\u0153ud de la file</li> <li>On note sa valeur dans le parcours</li> <li>On enfile ses fils gauche et droite, dans cet ordre, s'ils existent. </li> </ul> </li> </ul> <p>La m\u00e9thode est it\u00e9rative, on n'utilise pas la r\u00e9cursivit\u00e9 de la classe <code>Noeud</code>, on peut donc l'ajouter au choix dans la classe <code>Noeud</code> ou dans la classe <code>AB</code> directement:</p> <pre><code>class Noeud:\n\n    def parcours_larg(self):\n        parcours = []\n        file = []         # file de noeuds en attente\n\n        file.append(self)\n        while len(file) != 0:   # tant que la file n'est pas vide\n            n = file.pop(0)             # on d\u00e9file le premier n\u0153ud de la file\n            parcours.append(n.valeur)   # on note sa valeur\n            # on enfile le fils gauche s'il existe\n            if n.gauche is not None: \n                file.append(n.gauche)  \n            # on enfile le fils droit s'il existe\n            if n.droite is not None: \n                file.append(n.droite)\n\n        return parcours\n</code></pre> <p>et l'appel de la m\u00e9thode pour le n\u0153ud racine :</p> <pre><code>class AB :\n    def parcours_larg(self):\n        if self.racine is None: \n            print(\"l'arbre est vide\")\n        else: \n            return self.racine.parcours_larg()\n\n\n&gt;&gt;&gt; arbre.parcours_larg()\n[5, 10, 6, 3, 1, 12, 9, 4]\n</code></pre> <p>Le parcours en largeur contient une boucle tant que la file n'est pas vide c'est-\u00e0-dire tant que tous les n\u0153uds n'ont pas \u00e9t\u00e9 visit\u00e9s, le co\u00fbt est donc proportionnel \u00e0 la taille du nombre de n\u0153uds \\(n\\) de l'arbre. La complexit\u00e9 du parcours en largeur est en \\(O(n)\\).</p>"},{"location":"algorithmique/1-arbres-binaires/#parcours-en-profondeur-dfs","title":"Parcours en profondeur (DFS)","text":"<p>Cours</p> <p>Le parcours en profondeur ou DFS (Depth First Search) consiste \u00e0 parcourir pour chaque n\u0153ud d'abord son sous-arbre gauche enti\u00e8rement et ensuite son sous arbre droit.</p> <p>On peut r\u00e9aliser trois types de parcours en profondeur en choisissant \u00e0 quel moment \u00ab visiter \u00bb le n\u0153ud lui-m\u00eame :</p> <ul> <li>Avant le parcours de son sous-arbre gauche : parcours pr\u00e9fixe (ou pr\u00e9ordre) ;</li> <li>Entre le parcours de sous-arbre gauche et celui de son sous-arbre droit : parcours infixe (ou en ordre) ;</li> <li>Apr\u00e8s le parcours de son sous-arbre droit : parcours postfixe (ou suffixe, ou encore postordre).</li> </ul> Parcours pr\u00e9fixe Parcours infixe Parcours postfixe 1. Visite du n\u0153ud2.Parcours branche gauche3.Parcours branche droite 1.Parcours branche gauche2.Visite du n\u0153ud3.Parcours branche droite 1.Parcours branche gauche2.Parcours branche droite3.Visite du n\u0153ud 5 - 10 - 3 - 6 - 1 - 9 - 4 - 12 10 - 3 - 5 - 9 - 1 - 4 - 6 - 12 3 - 10 - 9 - 4 - 1 - 12 - 6 - 5 <p>Les impl\u00e9mentations r\u00e9cursives de ces trois types de parcours en profondeur sont tr\u00e8s semblables, seul l'ordre des instructions change : la ligne <code>parcours.append(self.valeur)</code> est plac\u00e9e avant, au milieu ou apr\u00e8s les appels r\u00e9cursifs des parcours des fils gauche et droit :</p> Parcours pr\u00e9fixeParcours infixeParcours postfixe <pre><code>class AB :\n    def parcours_prefixe(self):\n        if self.racine is None: \n            return []\n        else: \n            return self.racine.parcours_prefixe()\n\nclass Noeud:\n    def parcours_prefixe(self, parcours = None):\n        # Premier appel de la m\u00e9thode sans renseigner parcours\n        if parcours is None:\n            parcours = []\n\n        # Ajout de la valeur avant les fils gauche et  droit\n        parcours.append(self.valeur)\n\n        # Parcours du fils gauche\n        if self.gauche is not None:\n            self.gauche.parcours_prefixe(parcours)\n\n        # Parcours du fils droit\n        if self.droite is not None:\n            self.droite.parcours_prefixe(parcours)\n\n&gt;&gt;&gt; arbre.parcours_prefixe()\n[5, 10, 3, 6, 1, 9, 4, 12]\n</code></pre> <pre><code>class AB :\n    def parcours_infixe(self):\n        if self.racine is None: \n            return []\n        else: \n            return self.racine.parcours_infixe()\n\nclass Noeud:\n    def parcours_infixe(self, parcours = None):\n        # Premier appel de la m\u00e9thode sans renseigner parcours\n        if parcours is None:\n            parcours = []\n\n        # Parcours du fils gauche\n        if self.gauche is not None:\n            self.gauche.parcours_infixe(parcours)\n\n        # Ajout de la valeur apr\u00e8s le fils gauche et avant le droit\n        parcours.append(self.valeur)\n\n        # Parcours du fils droit\n        if self.droite is not None:\n            self.droite.parcours_infixe(parcours)\n\n    return parcours\n\n&gt;&gt;&gt; arbre.parcours_infixe()\n[10, 3, 5, 9, 1, 4, 6, 12]\n</code></pre> <pre><code>class AB :\n    def parcours_postfixe(self):\n        if self.racine is None: \n            return []\n        else: \n            return self.racine.parcours_postfixe()\n\nclass Noeud:\n    def parcours_postfixe(self, parcours = None):\n        # Premier appel de la m\u00e9thode sans renseigner parcours\n        if parcours is None:\n            parcours = []\n\n        # Parcours du fils gauche\n        if self.gauche is not None:\n            self.gauche.parcours_postfixe(parcours)\n\n        # Parcours du fils droit\n        if self.droite is not None:\n            self.droite.parcours_postfixe(parcours)\n\n        # Ajout de la valeur apr\u00e8s ses fils gauche et droit\n        parcours.append(self.valeur) \n\n        return parcours\n\n\n&gt;&gt;&gt; arbre.parcours_postfixe()\n[3, 10, 9, 4, 1, 12, 6, 5]\n</code></pre> <p>Noter qu'il est aussi possible d'impl\u00e9menter le parcours pr\u00e9fixe de fa\u00e7on it\u00e9rative, semblable au parcours en largeur, \u00e0 la diff\u00e9rence qu'on utilise une pile plut\u00f4t qu'une file<sup>2</sup>.</p> <p>Le parcours en largeur a un co\u00fbt proportionnel \u00e0 la taille du nombre de n\u0153uds \\(n\\) de l'arbre (pour chaque n\u0153ud suppl\u00e9mentaire, on rajoute 4 op\u00e9rations). La complexit\u00e9 du calcul de la hauteur est en \\(O(n)\\).</p>"},{"location":"algorithmique/1-arbres-binaires/#algorithmes-sur-les-arbres-binaires-de-recherche","title":"Algorithmes sur les arbres binaires de recherche","text":"<p>Les algorithmes de calculs de taille, de hauteur et de parcours d'arbres s'appliquent \u00e0 tous les arbres binaires. Dans la suite de ce chapitres, les algorithmes s'appliquent \u00e0 des arbres binaires particuliers : les arbres binaires de recherche.</p> <p>\u00ab sup\u00e9rieur \u00bb et  \u00ab inf\u00e9rieur \u00bb peuvent \u00eatre au sens strict ou large en fonction de la d\u00e9finition donn\u00e9e.</p> <p>Cours</p> <p>Un arbre binaire de recherche (ABR) est un cas particulier d'arbre binaire o\u00f9 :</p> <ul> <li>Chaque n\u0153ud a une cl\u00e9<sup>3</sup> sup\u00e9rieure \u00e0 celles de tous les n\u0153uds de son sous-arbre gauche .</li> <li>Chaque n\u0153ud a une cl\u00e9 inf\u00e9rieure \u00e0 celles de tous les n\u0153uds de son sous-arbre droit.</li> </ul> <p>Tous les sous-arbres sont aussi des ABR.</p> <p>On consid\u00e8re l'ABR suivant qui servira d'exemple pour la suite :</p> <p> </p> <p>La classe <code>ABR</code> est une sous classe d'<code>AB</code> qui h\u00e9rite<sup>4</sup>  des m\u00e9thodes d'un arbre binaire et permet d'ajouter ses propres m\u00e9thodes.</p> <pre><code>class ABR(AB):\n    pass\n\narbre_bin = ABR(Noeud(7,\n                    Noeud(4, \n                        Noeud(2),\n                        Noeud(6)),\n                    Noeud(11,\n                        Noeud(9, \n                            Noeud(8), \n                            Noeud(10)), \n                        Noeud(12))))\n</code></pre> <p>Les m\u00e9thodes de la classe <code>AB</code> fonctionnent par h\u00e9ritage, en particulier le parcours infixe donne un r\u00e9sultat notable :</p> <pre><code>&gt;&gt;&gt; arbre_bin.taille()\n9\n&gt;&gt;&gt; arbre_bin.hauteur()\n3\n\n&gt;&gt;&gt; arbre_bin.parcours_infixe()\n[2, 4, 6, 7, 8, 9, 10, 11, 12]\n</code></pre> <p>Cours</p> <p>Le parcours infixe d'un ABR renvoie les valeurs des n\u0153uds dans l'ordre croissant.</p>"},{"location":"algorithmique/1-arbres-binaires/#rechercher-une-cle","title":"Rechercher une cl\u00e9","text":"<p>Comme son nom l'indique, un ABR est sp\u00e9cifiquement adapt\u00e9 pour rechercher rapidement une cl\u00e9. On parcourt l'ABR en partant de sa racine, et on observe trois cas :</p> <ul> <li>si la valeur recherch\u00e9e est plus grande que la valeur du n\u0153ud parcouru, on descend \u00e0 droite ;</li> <li>si la valeur recherch\u00e9e est plus petite que la valeur du n\u0153ud parcouru, on descend \u00e0 gauche ;</li> <li>si c'est la m\u00eame, la cl\u00e9 a \u00e9t\u00e9 trouv\u00e9e.</li> </ul> <p>Une fois arriv\u00e9 \u00e0 une feuille, la cl\u00e9 n'a pas \u00e9t\u00e9 trouv\u00e9e. L'exemple ci-contre montre la recherche de la valeur 6 dans l'arbre pr\u00e9c\u00e9dent.</p> <p>Modifions la classe <code>ABR</code>, pour g\u00e9rer imm\u00e9diatement le cas de l'arbre vide (la valeur n'est pas trouv\u00e9e) et appeler une m\u00e9thode de la classe <code>Noeud</code>.</p> <pre><code>class ABR(AB):\n     def recherche(self, v):\n        \"\"\" Renvoie True si v est une valeur de l'arbre\"\"\"\n        if self.racine is None: \n            return False\n        return self.racine.recherche(v)\n</code></pre> <p>Voici ce que cela donne en r\u00e9cursif pour la classe <code>Noeud</code> : </p> <pre><code>class Noeud:\n    def chercher(self, v):\n        if v &lt; self.valeur:      # On continue \u00e0 chercher \u00e0 gauche s'il y a un fils gauche\n            if self.gauche is None: \n                return False \n            else:                 \n                return self.gauche.chercher(v)\n        elif v &gt; self.valeur:    # On continue \u00e0 chercher \u00e0 gauche s'il y a un fils droit\n            if self.droite is None: \n                return False\n            else: \n                return self.droite.chercher(v)\n        else:                     # On a trouv\u00e9 v\n            return True    \n</code></pre> <p>ou en it\u00e9ratif : <pre><code>    def chercher(self, v):\n        \"\"\" Renvoie le Noeud de valeur v\n            None si aucun noeud n'a cette valeur\n        \"\"\"\n        n = self.racine\n        while n is not None:\n            if v &lt; n.valeur:      # On continue \u00e0 chercher v \u00e0 gauche\n                n = n.gauche\n            if v &gt; n.valeur:      # On continue \u00e0 chercher v \u00e0 gauche\n                n = n.droite\n            else:                 # On a trouv\u00e9 v\n                return False\n        # Si on arrive ici, c'est qu'on n'a pas trouv\u00e9 v\n        return True\n</code></pre></p> <p>A chaque appel r\u00e9cursif, ou it\u00e9ration de la boucle <code>while</code>, le nombre de n\u0153uds \u00e0 parcourir est divis\u00e9 par un facteur 2 (dans un arbre \u00e9quilibr\u00e9), on en d\u00e9duit que la complexit\u00e9 de la recherche d'une cl\u00e9 est en \\(O(log_2(n))\\). \u2003</p>"},{"location":"algorithmique/1-arbres-binaires/#inserer-une-cle","title":"Ins\u00e9rer une cl\u00e9","text":"<p>Cours</p> <p>Lorsqu'on ajoute un n\u0153ud \u00e0 un ABR, on ajoute toujours une feuille de l'arbre, jamais un n\u0153ud interne.  </p> <p> </p> <p>Il suffit donc de rechercher la feuille dont la cl\u00e9 est la plus proche de celle du n\u0153ud \u00e0 ins\u00e9rer (comme pour l'algorithme de recherche), puis d'ajouter le n\u0153ud \u00e0 gauche si sa cl\u00e9 est inf\u00e9rieure \u00e0 celle de la feuille, et \u00e0 droite dans le cas contraire. L'exemple ci-contre montre l'insertion de la valeur 5.</p> <p>Dans le cas d'un ABR qui n'autorise pas les cl\u00e9s multiples, il faut emp\u00eacher l'insertion d'un n\u0153ud dont la cl\u00e9 est d\u00e9j\u00e0 dans l'arbre. </p> <p>Modifions la classe <code>ABR</code>, pour g\u00e9rer imm\u00e9diatement le cas de l'arbre vide (on ajoute une racine) et appeler une m\u00e9thode de la classe <code>Noeud</code>.</p> <pre><code>class ABR(AB):\n    def inserer(self, v):\n        \"\"\" insere la valeur v dans l'arbre\"\"\"\n        # si l'arbre est vide, on ajoute une racine\n        if self.racine is None: \n            self.racine = Noeud(v)\n        else:\n            self.racine.inserer(v)\n</code></pre> <p>Voici ce que cela donne en r\u00e9cursif pour la classe <code>Noeud</code> : </p> <pre><code>class Noeud:\n    def inserer(self,v):\n        \"\"\"insere la valeur v dans l'ABR\"\"\"\n        if v &lt; self.valeur:\n            if self.gauche is None: \n                self.gauche = Noeud(v)    # on ajoute v \u00e0 gauche\n            else: \n                self.gauche.inserer(v)    # on descend \u00e0 gauche\n        if v &gt; self.valeur: \n            if self.droite is None: \n                self.droite = Noeud(v)    # on ajoute v \u00e0 droite\n            else: \n                self.droite.inserer(v)    # on descend \u00e0 droite\n        if v == self.valeur: \n            print(v,\"est d\u00e9j\u00e0 dans l'ABR\")   # la valeur est d\u00e9j\u00e0 dans l'ABR\n</code></pre> <p>ou en it\u00e9ratif :</p> <pre><code>    def inserer(self, v):\n        \"\"\" Ins\u00e8re un nouveau Noeud de valeur v dans l'arbre    \"\"\"\n        if self.racine is None:\n            self.racine = Noeud(v)\n        else:\n            n = self.racine\n            while n is not None:\n                if v &lt; n.valeur:\n                    if n.gauche is None:\n                        n.gauche = Noeud(v)\n                        return\n                    n = n.gauche\n                elif v &gt; n.valeur:\n                    if n.droite is None:\n                        n.droite = Noeud(v)\n                        return\n                    n = n.droite\n                else:\n                    return # cl\u00e9 d\u00e9j\u00e0 dans l'arbre\n</code></pre> <p>La complexit\u00e9 de l'insertion d'une cl\u00e9 est en \\(O(log_2(n))\\).</p>"},{"location":"algorithmique/1-arbres-binaires/#supprimer-une-cle-hors-programme","title":"Supprimer une cl\u00e9 (hors programme)","text":"<p>L'op\u00e9ration d\u00e9pend du nombre de fils du n\u0153ud \u00e0 supprimer.</p> Cas n\u00b01 : le n\u0153ud \u00e0 supprimer est une feuilleCas n\u00b02 : le n\u0153ud \u00e0 supprimer avec un seul filsCas n\u00b03 : le n\u0153ud \u00e0 supprimer avec deux fils <ul> <li>On cherche le p\u00e8re du n\u0153ud \u00e0 supprimer ;</li> <li>On supprime le lien p\u00e8re-fils.</li> </ul> <p>Exemple : suppression du n\u0153ud 5</p> <p> </p> <ul> <li>On recherche le p\u00e8re du n\u0153ud \u00e0 supprimer ;</li> <li>On redirige le lien p\u00e8re-fils vers le fils (unique) du n\u0153ud \u00e0 supprimer.</li> </ul> <p>Exemple : suppression du n\u0153ud 6</p> <p> </p> <ul> <li>On recherche le n\u0153ud de sa branche de gauche ayant la plus grande valeur, comme c'est le plus grand de cette branche, il n'a pas de fils droit (voir valeur max) ;</li> <li>On rompt le lien p\u00e8re-fils, (comme dans le cas n\u00b02  ;)</li> <li>Et on remplace la valeur du n\u0153ud \u00e0 supprimer par celle du n\u0153ud d\u00e9croch\u00e9.</li> </ul> <p>Exemple : suppression du n\u0153ud 11</p> <p> </p> <p>Remarque : alternativement, on peut d\u00e9crocher le n\u0153ud ayant la plus petite valeur de sa branche de droite.</p> <pre><code>    def supprimer(self, v):\n        \"\"\" Supprime le Noeud de valeur v dans l'arbre\n            (s'il existe)\n        \"\"\"\n        # on recherche le noeud \u00e0 supprimer n et son pere p\n        p= None\n        n = self.racine\n        while n is not None:\n            if v &gt; n.valeur:\n                p = n\n                n = n.droite\n            elif v &lt; n.valeur:\n                p = n\n                n = n.gauche\n            else:\n                break\n        if n is None: return -1  # la valeur n'existe pas\n        fils = 0\n        if n.gauche is not None: fils += 1\n        if n.droite is not None: fils += 1\n\n        print(fils)\n        print(p.valeur)\n\n        if n.gauche is None and n.droite is None:    # n est une feuille\n            if p.droite == n: p.droite = None\n            else: p.gauche = None\n        elif n.gauche is not None and n.droite is None:  # 1 seul fils \u00e0 gauche\n            if p.droite == n: p.droite = n.gauche\n            else: p.gauche = n.gauche\n        elif n.gauche is  None and n.droite is not None:  # 1 seul fils \u00e0 droite\n            if p.droite == n: p.droite = n.droite\n            else: p.gauche = n.droite\n        else:               # 2 fils\n            # on cherche le max et son p\u00e8re\n            max = n.gauche\n            p = n\n            while max.droite is not None:\n                p = max\n                max = max.droite\n            p.droite = max.gauche     # on rattache la gauche du max \u00e0 p\n            n.valeur = max.valeur     # on remplace la valeur de n par le max\n</code></pre> <ol> <li> <p>D'autres algorithmes existent, par exemple la recherche arborescente Monte-Carlo.\u00a0\u21a9</p> </li> <li> <p><pre><code>class Noeud:\n    def parcours_prefixe(self):\n        parcours = []\n        pile = []\n        pile.append(self)\n        while len(pile) != 0:   # tant que la pile n'est pas vide\n            n = pile.pop()   # on prend le noeud au sommet de la pile\n            parcours.append(n.valeur)    # on note sa valeur\n            if n.droite is not None: pile.append(n.droite)  # ! attention, on empile le fils de DROITE d'abord\n            if n.gauche is not None: pile.append(n.gauche)  # on empile le fils gauche    \n</code></pre> \u21a9</p> </li> <li> <p>Dans un ABR, l'\u00e9tiquette est appel\u00e9e \u00ab cl\u00e9 \u00bb ou \u00ab valeur \u00bb.\u00a0\u21a9</p> </li> <li> <p>L'h\u00e9ritage est un des grands principes de la programmation orient\u00e9e objet (POO) permettant de cr\u00e9er une nouvelle classe \u00e0 partir d'une classe existante. La sous-classe h\u00e9rite des attributs et des m\u00e9thodes de la classe m\u00e8re et en ajoute de nouveaux.\u00a0\u21a9</p> </li> </ol>"},{"location":"algorithmique/2-graphes/","title":"Algorithmes sur les graphes.","text":"<p>Cours</p> <p>Parcourir un graphe consiste \u00e0 visiter ses sommets, en suivant les ar\u00eates qui les relient.</p> <p>On a vu dans le chapitre sur les structures de donn\u00e9es plusieurs impl\u00e9mentations possibles d'un graphe : avec une matrice d'adjacente ou avec une liste ou dictionnaire d'adjacence. </p> <p>Nous utilisons la seconde mettant en \u0153uvre un dictionnaire d'adjacence dans ce chapitre o\u00f9 les voisins sont stock\u00e9s dans des tableaux.</p> <pre><code>class Graphe:\n    \"\"\" \"\"\"\n    def __init__(self, oriente = True):\n        self.A = {}                # Dictionnaire d'adjacence\n        self.oriente = oriente     # Graphe orient\u00e9 ou pas\n\n    def est_vide(self):\n        return len(self.A) == 0\n\n    def ordre(self):\n        return len(self.A)\n\n    def __repr__(self):\n        return str(self.A)\n\n  def ajouter_sommet(self, x):\n        \"\"\" Ajoute un sommet x \"\"\"\n        if not x in self.A:\n            self.A[x] = []\n\n    def ajouter_arete(self, x, y):\n        \"\"\" Ajoute une ar\u00eate entre les sommets x et y \"\"\"\n        self.ajouter_sommet(x)\n        self.ajouter_sommet(y)\n        self.A[x].append(y)\n        if not self.oriente:\n            self.A[y].append(y)\n\n    def voisins(self, x):\n        \"\"\" Renvoie le tableau des voisins de x\"\"\"\n        return self.A[x]\n</code></pre> <p>et pour les exemples, le graphe orient\u00e9 suivant :  </p> <p>Cr\u00e9ons le graphe :</p> <pre><code>G = Graphe(True)\nG.ajouter_sommet(\"A\")   # sommet A\nG.ajouter_sommet(\"B\")   # sommet B\nG.ajouter_sommet(\"C\")   # sommet C\nG.ajouter_sommet(\"D\")   # sommet D\nG.ajouter_sommet(\"E\")   # sommet E\nG.ajouter_sommet(\"F\")   # sommet F\nG.ajouter_sommet(\"G\")   # sommet G\nG.ajouter_arc(\"A\", \"B\")  \nG.ajouter_arc(\"A\", \"D\")  \nG.ajouter_arc(\"B\", \"C\")  \nG.ajouter_arc(\"C\", \"E\")  \nG.ajouter_arc(\"C\", \"F\")  \nG.ajouter_arc(\"D\", \"E\")  \nG.ajouter_arc(\"E\", \"B\")\nG.ajouter_arc(\"G\", \"C\")  \n</code></pre> <p>A la diff\u00e9rence des arbres binaires, dans les graphes il n'y a pas de notion de gauche ou droite ou d'un ordre quelconque entre les voisins d'un sommet,  ni de \u00ab racine \u00bb du graphe. On parcourt donc les voisins dans n'importe quel ordre. Selon l'ordre dans lequel on regardera les voisins de chaque sommet, on pourra faire des parcours compl\u00e8tement diff\u00e9rents en partant d'un m\u00eame sommet.</p>"},{"location":"algorithmique/2-graphes/#parcours-en-largeur-bfs","title":"Parcours en largeur (BFS)","text":"<p>Cours</p> <p>Le parcours en largeur ou BFS (Breadth First Search), consiste \u00e0 visiter tous les sommets en \u00ab cercle concentriques \u00bb autour du sommet de d\u00e9part : d'abord les sommets \u00e0 une distance de 1, puis ceux \u00e0 une distance de 2, etc. </p> <p>A la diff\u00e9rence du parcours en largeur dans un arbre binaire, il n'y a pas de notion de gauche et droite dans les sommets suivants, on les parcourt donc dans n'importe quel ordre.</p> <p> </p> <p>Le parcours en largeur du graphe ci-dessus est A-B-D-C-E-F, mais on peut aussi avoir A-D-B-E-C-F.</p> <p>Comme pour le parcours en largeur d'un arbre binaire, l'impl\u00e9mentation n\u00e9cessite l'utilisation une structure de file : pour chaque sommet visit\u00e9 on met en attente dans une file (enfiler) les voisins qu'on n'a pas encore visit\u00e9s et qui ne sont pas d\u00e9j\u00e0 dans la file, puis on visite le premier sommet pr\u00e9sent dans la file (d\u00e9filer).</p> <p></p> <p>Voil\u00e0 un exemple d'impl\u00e9mentation avec une file de type Python list.</p> <pre><code>    def parcours_larg(self, depart):\n        \"\"\" Renvoie le parcours en largeur \u00e0 partir du sommet depart\"\"\"\n        parcours = []   # liste des sommets visit\u00e9s\n        file = [depart]   # file des sommets en attente\n        while file != []:\n            s = file.pop(0)        # on d\u00e9file\n            parcours.append(s)      # on l'ajoute au parcours\n            for v in self.voisins(s):\n                # on enfile les voisins qui n'ont pas \u00e9t\u00e9 visit\u00e9s ou en attente\n                if v not in parcours and v not in file:\n                    file.append(v)\n        return parcours\n</code></pre> <p>Chaque sommet entre une et une seule fois dans la file, la boucle <code>while</code> sera donc r\u00e9p\u00e9t\u00e9e \\(n\\) fois (\\(n\\) est l'ordre du graphe). Pour chaque sommet de la file : on suppose que le d\u00e9filement  est \u00e0 cout constant (ce qui n'est pas le cas avec <code>.pop(0)</code> sur le type <code>list</code>)<sup>1</sup>; alors la boucle <code>for</code> est r\u00e9p\u00e9t\u00e9e pour chaque voisin, donc une fois pour chaque ar\u00eate. Si on nomme \\(m\\) le nombre d'ar\u00eate du graphe, la complexit\u00e9 du parcours en largeur est en \\(O(n+m)\\).</p> <p>Il existe de nombreuses utilisations du parcours en largeur. Une premi\u00e8re utilisation toute simple permet de v\u00e9rifier si un graphe est fortement connexe<sup>2</sup>  ou pas. Peut-on acc\u00e9der \u00e0 tous les sommets du graphe depuis de chaque sommet ?</p> <pre><code>    def fort_connexe(self):\n        \"\"\" True si le graphe est fortement connexe\"\"\"\n        for s in self.sommet:\n            if self.parcours_largeur(s) != self.ordre():\n                return False\n        return True\n</code></pre>"},{"location":"algorithmique/2-graphes/#application-plus-court-chemin","title":"Application : Plus court chemin","text":"<p>A l'issue du parcours en largeur, <code>parcours</code> contient l'ensemble des sommets qui ont \u00e9t\u00e9 visit\u00e9s, on peut ainsi v\u00e9rifier facilement s'il existe ou pas un chemin menant du sommet de d\u00e9part vers un autre sommet. En revanche, l'ordre du parcours, donnant le chemin n'est pas m\u00e9moris\u00e9 par ce type de parcours.</p> <p>Pour calculer la distance ou le plus court chemin entre deux sommets, il faut conserver le sommet qui permet d'acc\u00e9der \u00e0 chaque sommet, par exemple en utilisant  un dictionnaire <code>viens_de</code>  qui associe \u00e0 chaque sommet visit\u00e9 au sommet qui a permis de l'atteindre (ou None pour au sommet de d\u00e9part). Il suffit ensuite de partir de l'arriv\u00e9e et de remonter jusqu'au sommet de d\u00e9part pour calculer  la distance ou construire le chemin.</p> <pre><code>    def chemin(self, depart, arrivee):\n        \"\"\" Renvoie le chemin entre deux sommets\"\"\"\n        viens_de = {depart: None}  # dict des sommets avec le sommet qui permet d'y acc\u00e9der\n        file = [depart]        # file des sommets en attente\n        while file != []:      # tant que la file n'est pas vide\n            s = file.pop(0)        # on d\u00e9file le premier sommet\n            for v in self.voisins(s):\n                # on enfile les voisins qui n'ont pas \u00e9t\u00e9 visit\u00e9s ou en attente\n                if v not in viens_de and v not in file:\n                    file.append(v)      # on l'enfile\n                    viens_de[v] = s     # et on note qu'on y acc\u00e8de depuis s\n        # on construit le chemin en partant d'arrivee\n        chemin = [arrivee]\n        if arrivee not in viens_de: return -1 # pas de chemin possible\n        s = viens_de[arrivee]\n        while s is not None:\n            chemin.insert(0, s)\n            s = viens_de[s]\n        return chemin\n</code></pre> <p>de m\u00eame pour la distance:</p> <pre><code>   def distance(self, depart, arrivee):\n    \u2026.\n       # on calcule la distance en partant d'arrivee\n        distance = 0\n        if arrivee not in viens_de: return -1 # pas de chemin possible\n        s = viens_de[arrivee]\n        while s is not None:\n            distance = distance + 1\n            s = viens_de[s]\n        return distance\n</code></pre> <p>Une autre utilisation typique du parcours en largeur est la coloration d'un graphe: comment attribuer une \u00ab couleur \u00bb \u00e0 chacun de ses sommets de mani\u00e8re que deux sommets reli\u00e9s par une ar\u00eate soient de couleurs diff\u00e9rentes ?  On cherche souvent \u00e0 utiliser le nombre minimal de couleurs, appel\u00e9 nombre chromatique.</p>"},{"location":"algorithmique/2-graphes/#parcours-en-profondeur-dfs","title":"Parcours en profondeur (DFS)","text":"<p>Cours</p> <p>Le parcours en profondeur ou DFS (Depth First Search) d'un graphe \u00e0 partir d'un sommet consiste \u00e0 suivre les ar\u00eates arbitrairement, le plus loin possible jusqu'\u00e0 un cul-de-sac ou alors jusqu'\u00e0 atteindre un sommet d\u00e9j\u00e0 visit\u00e9. Il revient alors sur le dernier sommet o\u00f9 on pouvait suivre un autre chemin puis explore un autre chemin. </p> <p>L'exploration s'arr\u00eate quand tous les sommets ont \u00e9t\u00e9 visit\u00e9s.</p> <p> </p> <p>Le parcours en profondeur du graphe ci-dessus est A-B-C-F-E-D, mais les ar\u00eates \u00e9tant choisies arbitrairement<sup>3</sup>, il faut s'attendre \u00e0 des visites dans des ordres compl\u00e9tements diff\u00e9rents. Ici, on pourrait tout aussi bien obtenir A-B-C-E-F-D ou A-D-E-B-C-F.</p> <p>  Comme pour les arbres, le parcours en  profondeur d'un graphe s'exprime naturellement de fa\u00e7on r\u00e9cursive, \u00e0 la diff\u00e9rence qu'il faut marquer les sommets d\u00e9j\u00e0 visit\u00e9s afin de ne pas y retourner depuis un autre sommet et risquer de \u00ab tourner en rond \u00bb. Le parcours termine lorsqu'il n'y a plus de sommets \u00e0 parcourir.</p> <pre><code>    def parcours_prof_rec(self, s, parcours=None):\n        \"\"\" Parcours en profondeur r\u00e9cursif \u00e0 partir du sommet s\n        parcours contient l'ensemble des sommets visit\u00e9s\n        \"\"\"\n        if parcours is None:  # on initialise parcours\n            parcours = []\n        if s not in parcours:\n            parcours.append(s)   # on l'ajoute au parcours\n            for v in self.voisins(s):  # on parcourt chaque voisin\n                self.parcours_prof_rec(v, parcours)\n        return parcours\n</code></pre> <p>Note : pour l'appel initial de la fonction avec le sommet de d\u00e9part, <code>parcours</code> est vide. Si on veut d\u00e9finir une valeur par d\u00e9faut par mot cl\u00e9, on ne peut pas \u00e9crire <code>def parcours_prof_rec(self, s, parcours=[])</code> car le type list est de type muable ce qui engendrera des erreurs<sup>4</sup>. </p> <p></p> <p>Voil\u00e0 un exemple d'impl\u00e9mentation avec une pile de type Python list<sup>6</sup>. </p> <pre><code>    def parcours_prof(self, depart):\n        \"\"\" Renvoie le parcours en profondeur au depart d'un sommet\"\"\"\n        parcours = []   # listes des sommets visit\u00e9s\n        pile = [depart]   # pile des sommets en attente\n        while pile != []:\n            s = pile.pop()        # on d\u00e9pile\n            parcours.append(s)  # on l'ajoute au parcours\n            for v in self.voisins(s):\n                # on empile les voisins qui n'ont pas \u00e9t\u00e9 visit\u00e9s ou en attente\n                if v not in parcours and v not in pile:\n                    pile.append(v)\n        return parcours\n</code></pre> <p>De la m\u00eame fa\u00e7on que le parcours en largeur, la complexit\u00e9 du parcours en profondeur est en \\(O(n+m)\\) o\u00f9 \\(n\\) est le nombre de sommets et \\(m\\) le nombre d'ar\u00eates.</p> <p>Comme pour le parcours en largeur, \u00e0 la fin du parcours en profondeur, <code>parcours</code> contient l'ensemble des sommets qui ont \u00e9t\u00e9 visit\u00e9s ce qui permet de v\u00e9rifier facilement s'il existe ou pas un chemin menant du sommet de d\u00e9part vers un autre sommet. Par contre, le parcours en profondeur est mal adapt\u00e9 pour d\u00e9terminer la distance entre deux sommets ou le chemin le plus court entre deux sommets, car rien n'indique qu'un chemin trouv\u00e9 est le plus court. </p>"},{"location":"algorithmique/2-graphes/#application-recherche-de-cycles","title":"Application : Recherche de cycles","text":"<p>Le parcours en profondeur est particuli\u00e8rement bien adapt\u00e9 \u00e0 la recherche de cycles dans un graphe. Voici un exemple de d\u00e9tection de cycle qui utilise un parcours en profondeur (applicable aussi \u00e0 un parcours en largeur). On empile les voisins jusqu'\u00e0 ce qu'on retombe sur un sommet qui a d\u00e9j\u00e0 \u00e9t\u00e9 parcouru</p> <pre><code>    def possede_cycle(self, depart):\n        \"\"\" Renvoie True si un cycle est det\u00e9ct\u00e9\"\"\"\n        parcours = []\n        pile = [depart]\n        while pile != []:\n            s = pile.pop()\n            if s in parcours:          # S a-t-il \u00e9t\u00e9 parcouru ?\n                return True     # dans ce cas on a un cycle\n            parcours.append(s)\n            for v in self.voisins(s):\n                # on empile les voisins qui n'ont pas \u00e9t\u00e9 visit\u00e9s ou en attente\n                if v not in parcours:\n                    pile.append(v)\n        return False\n</code></pre> <ol> <li> <p>Le type <code>list</code> n'est pas l'impl\u00e9mentation optimale d'une file car <code>.pop(0)</code> est en cout lin\u00e9aire, une liste cha\u00een\u00e9e ou de la classe <code>collections.deque</code> serait mieux adapt\u00e9e.\u00a0\u21a9</p> </li> <li> <p>Un graphe orient\u00e9 est fortement connexe si pour toute paire (x, y) de sommets, il existe un chemin de x \u00e0 y et un chemin de y \u00e0 x.\u00a0\u21a9</p> </li> <li> <p>On peut aussi faire quelque chose de plus \u00ab fin \u00bb en utilisant un algorithme glouton qui va s\u00e9lectionner le sommet non visit\u00e9 minimisant ou maximisant une fonction de score ou de co\u00fbt. C'est le cas de A*, par exemple.\u00a0\u21a9</p> </li> <li> <p>Voir https://docs.python.org/fr/3/tutorial/controlflow.html#default-argument-values \u2003 En cas d'un tr\u00e8s grand nombre de sommets, la m\u00e9thode r\u00e9cursive peut vite atteindre sa limite<sup>5</sup>.  On peut alternativement utiliser une approche it\u00e9rative, \u00e0 l'aide d'une *pile, de fa\u00e7on tr\u00e8s similaire au parcours en largeur.\u00a0\u21a9</p> </li> <li> <p>1000 par d\u00e9faut en Python.\u00a0\u21a9</p> </li> <li> <p>Ici, le type Python <code>list</code> est adapt\u00e9 \u00e0 l'impl\u00e9mentation d'une pile car le cout des m\u00e9thodes <code>.append()</code> et  <code>.pop()</code> est en \\(O(1)\\).\u00a0\u21a9</p> </li> </ol>"},{"location":"algorithmique/3-diviser-pour-regner/","title":"M\u00e9thode \u00ab diviser pour r\u00e9gner \u00bb","text":"<p>Cours</p> <p>La m\u00e9thode \u00ab diviser pour r\u00e9gner \u00bb consiste \u00e0 d\u00e9couper un probl\u00e8me en sous-probl\u00e8mes similaires de plus en plus petits jusqu'\u00e0 obtenir des cas simples permettant une r\u00e9solution directe. Elle consiste en trois \u00e9tapes :  </p> <ol> <li>Diviser : d\u00e9couper un probl\u00e8me initial de taille n en sous-probl\u00e8mes ind\u00e9pendants de taille n/2 (ou une fraction de n);</li> <li>R\u00e9gner : r\u00e9soudre les sous-probl\u00e8mes (r\u00e9cursivement ou directement s'ils sont assez petits) ;</li> <li>Combiner : calculer une solution au probl\u00e8me initial \u00e0 partir des solutions des sous-probl\u00e8mes.</li> </ol> <p>Cette m\u00e9thode tire souvent avantage de la r\u00e9cursivit\u00e9.  Le faible co\u00fbt des algorithmes diviser pour r\u00e9gner est l'un de leurs principaux int\u00e9r\u00eats.</p> <p>Cette technique fournit des algorithmes efficaces pour de nombreux probl\u00e8mes, comme la recherche dichotomique d'un \u00e9l\u00e9ment dans un tableau tri\u00e9, le tri fusion, la multiplication de grands nombres (algorithme de Karatsuba), etc.</p>"},{"location":"algorithmique/3-diviser-pour-regner/#recherche-dichotomique-dans-un-tableau-trie","title":"Recherche dichotomique dans un tableau tri\u00e9","text":"<p>Consid\u00e9rons un algorithme na\u00eff de recherche dans un tableau en parcourant tous les \u00e9l\u00e9ments du tableau :</p> <pre><code>def recherche(x, T):\n    for elt in T:\n        if x == elt: return True\n    return False\n</code></pre> <p>Dans le pire des cas (x n'est pas dans le tableau), l'algorithme parcourt l'ensemble du tableau, le co\u00fbt est donc en \\(O(n)\\).</p> <p>Le principe de la recherche dichotomique dans un tableau tri\u00e9 est celui suivi naturellement par les enfants quand ils jouent \u00e0 un jeu bien connu : un des joueurs doit d\u00e9couvrir en un minimum d'essais un nombre secret compris entre 0 et 100 choisi par l'autre joueur. A chaque proposition du premier joueur, le second lui r\u00e9pond s'il a trouv\u00e9 le nombre secret ou s'il est plus petit ou plus grand. La meilleure technique consiste \u00e0 proposer un nombre \u00ab au milieu \u00bb de la zone de recherche pour la r\u00e9duire le plus rapidement possible.</p> <p>Au d\u00e9but le joueur propose le nombre au milieu entre 0 et 100, c'est-\u00e0-dire 50. </p> <ul> <li>Si on lui r\u00e9pond \u00ab gagn\u00e9 \u00bb, il a eu de la chance et il a trouv\u00e9 le nombre secret imm\u00e9diatement. </li> <li>Si on lui r\u00e9pond \u00ab perdu, c'est plus grand \u00bb, alors il sait que le nombre secret est entre 51 et 100, il va donc proposer le nouveau milieu entre 51 et 100, c'est-\u00e0-dire 75.</li> <li>Si la r\u00e9ponse est \u00ab perdu, c'est moins \u00bb, alors le nombre secret est entre 0 et 49, il va proposer 25. </li> </ul> <p>Il va continuer ainsi de suite jusqu'\u00e0 trouver le nombre secret. Cette technique consiste \u00e0 diviser un probl\u00e8me en deux sous-probl\u00e8mes ind\u00e9pendants, c'est un algorithme du type diviser pour r\u00e9gner.</p> <p>Recherche dichotomique de <code>x</code> dans un tableau tri\u00e9 <code>T</code> :</p> Etape Description Diviser D\u00e9couper le tableau tri\u00e9 <code>[T[debut], T[debut+1], ..., T[fin]]</code> en son milieu (<code>(debut + fin)//2</code>) pour avoir deux sous-tableaux  <code>[T[debut], T[debut+1], ..., T[milieu-1]]</code> et <code>[T[milieu + 1], ..., T[fin]]</code> R\u00e9gner - si <code>x &lt; T[milieu]</code>, chercher <code>x</code> dans <code>[T[debut], T[debut+1], ..., T[milieu-1]]</code> - si <code>x &gt; T[milieu]</code> , chercher <code>x</code> dans <code>[T[milieu + 1], ..., T[fin]]</code>- si <code>x == T[milieu]</code>,  <code>x</code> a \u00e9t\u00e9 trouv\u00e9 Combiner <p>Faisons par exemple des recherches dans le tableau tri\u00e9 [5, 7, 12, 14, 23, 27, 35, 40 ,41, 45]. </p> <p>Plusieurs cas se pr\u00e9sentent :</p> Recherche de la valeur 40Recherche de la valeur 35Recherche de la valeur 34 <p> </p> <ol> <li>On cherche la valeur <code>40</code> dans le tableau <code>[5, 7, 12, 14, 23, 27, 35, 40 ,41, 45]</code>. </li> <li>On partage le tableau en deux parties en son milieu : <code>T[milieu] =  23</code>.</li> <li><code>40 &gt; T[milieu]</code>, on cherche la valeur <code>40</code> dans la partie sup\u00e9rieure du tableau <code>[27, 35, 40 ,41, 45]</code>.</li> <li>On partage le tableau en deux parties en son milieu : <code>T[milieu] = 40</code>.</li> <li><code>40 = T[milieu]</code>, on a trouv\u00e9 la valeur <code>40</code>.</li> </ol> <p> </p> <ol> <li>On cherche la valeur <code>35</code> dans le tableau <code>[5, 7, 12, 14, 23, 27, 35, 40 ,41, 45]</code>. </li> <li>On partage le tableau en deux parties en son milieu : <code>T[milieu] =  23</code>.</li> <li><code>35 &gt; T[milieu]</code>, on cherche la valeur <code>35</code> dans la partie sup\u00e9rieure du tableau <code>[27, 35, 40 ,41, 45]</code>.</li> <li>On partage le tableau en deux parties en son milieu : <code>T[milieu] = 40</code>.</li> <li><code>35 &lt; T[milieu]</code>, on cherche la valeur <code>35</code> dans la partie inf\u00e9rieure du tableau <code>[27, 35]</code>.</li> <li>On partage le tableau en deux parties en son milieu : <code>T[milieu] = 27</code>.</li> <li><code>35 &gt; T[milieu]</code>, on cherche la valeur <code>35</code> dans la partie sup\u00e9rieure du tableau <code>[35]</code>.</li> <li>On partage le tableau en deux parties en son milieu : <code>T[milieu] = 35</code>.</li> <li><code>35 = T[milieu]</code>, on a trouv\u00e9 la valeur <code>35</code>.</li> </ol> <p>On voit ici que la recherche s'effectue jusqu'\u00e0 ce que le tableau n'ait plus qu'une seule valeur, c'est \u00e0 dire que <code>debut</code> est \u00e9gal \u00e0 <code>fin</code>. </p> <p> </p> <ol> <li>On cherche la valeur <code>34</code> dans le tableau <code>[5, 7, 12, 14, 23, 27, 35, 40 ,41, 45]</code>. </li> <li>On partage le tableau en deux parties en son milieu : <code>T[milieu] =  23</code>.</li> <li><code>34 &gt; T[milieu]</code>, on cherche la valeur <code>34</code> dans la partie sup\u00e9rieure du tableau <code>[27, 35, 40 ,41, 45]</code>.</li> <li>On partage le tableau en deux parties en son milieu : <code>T[milieu] = 40</code>.</li> <li><code>34 &lt; T[milieu]</code>, on cherche la valeur <code>34</code> dans la partie inf\u00e9rieure du tableau <code>[27, 35]</code>.</li> <li>On partage le tableau en deux parties en son milieu : <code>T[milieu] = 27</code>.</li> <li><code>34 &gt; T[milieu]</code>, on cherche la valeur <code>34</code> dans la partie sup\u00e9rieure du tableau <code>[35]</code>.</li> <li>On partage le tableau en deux parties en son milieu : <code>T[milieu] = 35</code>.</li> <li><code>34 &lt; T[milieu]</code>, on cherche la valeur <code>34</code> dans la partie inf\u00e9rieure du tableau <code>[]</code></li> <li>On n'a pas trouv\u00e9 la valeur <code>34</code>.</li> </ol> <p>On voit ici que la recherche s'effectue jusqu'\u00e0 ce que le tableau soit vide , c'est-\u00e0-dire que <code>debut</code> est plus grand que <code>fin</code>. </p> <p>Voil\u00e0 ce que l'on peut \u00e9crire en mode it\u00e9ratif :</p> <p><pre><code>def recherche(x, T) :\n    debut = 0\n    fin = len(T) - 1\n    while debut &lt;= fin:      \n        milieu = (debut + fin)//2\n        if x &lt; T[milieu]: \n            fin = milieu - 1\n        elif x &gt; T[milieu]: \n            debut = milieu + 1\n        else:       # donc x == T[milieu]: \n            return True   # ou return milieu si on veut la position dans T\n\n    return False    # ou return None par exemple si on veut la position dans T \n</code></pre>  Un bug classique est d'\u00e9crire  <code>while debut &lt; fin:</code> \u00e0 la ligne 4, alors qu'on a vu dans l'exemple pr\u00e9c\u00e9dent (en recherchant la valeur 35 dans le tableau) que la recherche doit se poursuivre m\u00eame quand <code>debut</code> est \u00e9gal \u00e0 <code>fin</code>, on peut encore trouver la valeur. On ne s'arr\u00eate que quand <code>debut &gt; fin</code>, c'est seulement alors qu'il n'y a plus aucune valeur possible dans le tableau. </p> <p>Ce programme contient une boucle <code>while</code>, il faut donc s'assurer qu'elle termine. Ici le variant de boucle est <code>fin - debut</code>. A chaque it\u00e9ration de boucle, on voit qu'il y a trois cas :</p> <ul> <li><code>x &lt; T[milieu]</code> : dans ce cas, <code>fin</code> devient <code>milieu - 1</code>, donc le variant d\u00e9cro\u00eet strictement ; </li> <li><code>x &gt; T[milieu]</code> : dans ce cas, <code>debut</code> devient <code>milieu + 1</code>, donc le variant d\u00e9cro\u00eet strictement ;</li> <li><code>x == T[milieu]</code> : dans ce cas, l'instruction <code>return True</code> sort de la boucle et m\u00eame de la fonction.</li> </ul> <p>Tant qu'on est dans la boucle, le variant de boucle <code>fin - debut</code> d\u00e9cro\u00eet strictement, la boucle <code>while debut &lt;= fin:</code> terminera donc.</p> <p>PPour prouver la correction de cet algorithme, on va utiliser la technique de l'invariant de boucle. V\u00e9rifions que la proposition \u00ab si x est dans T alors <code>T[debut] &lt;= x &lt;= T[fin]</code> \u00bb  est un invariant de boucle. </p> <p>Au d\u00e9but, l'invariant est vrai, si x est dans la tableau alors il est compris entre la premi\u00e8re et la derni\u00e8re valeur du tableau.</p> <p>Si l'invariant est vrai quand on entre dans la boucle, alors il y a les m\u00eames trois possibilit\u00e9s :</p> <ul> <li><code>x &lt; T[milieu]</code> : alors la recherche se poursuit dans <code>[T[debut], ..., T[milieu-1]]</code>, l'invariant est encore vrai quand on retourne dans la boucle; </li> <li><code>x &gt; T[milieu]</code> : alors la recherche se poursuit dans <code>[T[milieu+1], ..., T[fin]]</code>, l'invariant est encore vrai quand on retourne dans la boucle ;  </li> <li><code>x == T[milieu]</code> : alors on l'a trouv\u00e9.</li> </ul> <p>On a donc bien un invariant de boucle et l'algorithme trouve bien si une valeur est dans un tableau tri\u00e9 ou pas.</p> <p>\u00c9tudions la complexit\u00e9 temporelle pour un tableau de taille \\(n\\). A chaque it\u00e9ration de la boucle on divise la taille du tableau par 2, cela revient donc \u00e0 se demander combien de fois faut-il diviser la taille du tableau par 2 pour obtenir dans le cas le plus d\u00e9favorable (<code>x</code> n'est pas dans <code>T</code>) un tableau vide ? Cela revient \u00e0 trouver le nombre \\(a\\) tel que \\(2^a  = n\\) . La solution est  \\(a= log_2(n)\\).</p> <p>Cours</p> <p>La complexit\u00e9 en temps de l'algorithme de recherche dichotomique est logarithmique en  \\(O(log_2(n))\\).</p> <p>On peut bien s\u00fbr \u00e9crire le m\u00eame algorithme en mode r\u00e9cursif, en passant en param\u00e8tre de la fonction les valeurs de <code>debut</code>et <code>fin</code>. Les param\u00e8tres sont des param\u00e8tres facultatifs par mot-cl\u00e9, ils sont initialis\u00e9s \u00e0 <code>0</code>et <code>lent(T)-1</code> au premier appel.</p> <pre><code>def recherche(x, T, debut=None, fin=None):\n\n    # initialisation de debut et fin au premier appel\n    if debut is None or fin is None:\n        debut = 0\n        fin = len(T)-1\n\n    if debut &gt; fin:\n        return False\n    else:\n        milieu = (debut + fin)//2\n        if x &lt; T[milieu]:\n            return recherche(x, T, debut, milieu-1)\n        elif x &gt; T[milieu]:\n            return recherche(x, T, milieu+1, fin)\n        else:\n            return True\n\nassert recherche(35, [5, 7, 12, 14, 23, 27, 35, 40 ,41, 45])\nassert not recherche(34, [5, 7, 12, 14, 23, 27, 35, 40 ,41, 45])\n</code></pre>"},{"location":"algorithmique/3-diviser-pour-regner/#tri-fusion-mergesort","title":"Tri fusion (mergesort)","text":"<p>On a vu en classe de premi\u00e8re plusieurs algorithmes de tri simples comme le tri par s\u00e9lection, tri par insertion  ou tri \u00e0 bulle. </p> Tri par s\u00e9lectionTri par insertionTri \u00e0 bulles <p>Le d\u00e9but du tableau \u00e9tant d\u00e9j\u00e0 tri\u00e9 (jusqu'\u00e0 <code>i</code> exclu), on parcourt le reste pour \"s\u00e9lectionner\" le plus petit \u00e9l\u00e9ment \u00e0 rajouter en fin de la partie tri\u00e9e (en <code>i</code>).  </p> <pre><code>def tri_selection(T):\n    n = len(T)\n    for i in range(n):   # On suppose T tri\u00e9 jusqu'\u00e0 i exclu\n        # On \"s\u00e9lectionne\" l'indice du plus petit \u00e9l\u00e9ment \u00e0 partir de i\n        i_min = i\n        for j in range(i, n):\n            if T[j] &lt; T[i_min]:\n                i_min = j\n        # On met le plus petit \u00e9l\u00e9ment en position i\n        T[i], T[i_min] = T[i_min], T[i]\n    return T\n</code></pre> <p>Le d\u00e9but du tableau \u00e9tant d\u00e9j\u00e0 tri\u00e9 (jusqu'\u00e0 <code>i</code> exclu), on ins\u00e8re l'\u00e9l\u00e9ment suivant (en <code>i</code>) \u00e0 la bonne position dans la partie d\u00e9j\u00e0 tri\u00e9e.    </p> <pre><code>def tri_insertion(T):\n    n = len(T)\n    for i in range(n):        # on suppose T tri\u00e9 jusqu'\u00e0 i exclu\n        # On ins\u00e8re T[i] \u00e0 la bonne position\n        valeur_insertion = T[i]\n        j = i\n        while j &gt; 0 and valeur_insertion &lt; T[j - 1]:\n            T[j] = T[j - 1]\n            j = j - 1\n        T[j] = valeur_insertion\n    return T\n</code></pre> <p>L'id\u00e9e est de parcourir le tableau en comparant chaque \u00e9l\u00e9ment au suivant et de les \u00e9changer s'ils ne sont pas dans l'ordre  :</p> <pre><code>n = len(T)\nfor j in range(n - 1):    # on s'arr\u00eate \u00e0 n - 1 pour faire la derni\u00e8re comparaison\n    # on \u00e9change T[j] avec le suivant s'ils ne sont pas dans l'ordre\n    if T[j] &gt; T[j + 1]:\n        T[j], T[j + 1 ] = T[j + 1], T[j]   \n</code></pre> <p>En faisant un passage sur tous les \u00e9l\u00e9ments de <code>T</code>, certaines \"grandes\" valeurs se sont d\u00e9cal\u00e9es vers la droite du tableau, la plus grande est arriv\u00e9e \u00e0 la derni\u00e8re position comme attendu. C'est l'id\u00e9e des bulles qui remontent dans un verre.</p> <p>Il suffit de r\u00e9p\u00e9ter l'op\u00e9ration en parcourant tout le tableau pour obtenir un tableau tri\u00e9 :</p> <pre><code>def tri_a_bulle(T):\n    n = len(T)\n    for i in range(n):   # on parcourt le tableau\n        for j in range(n - 1):    # ou alors range(n - i - 1) car les i derniers \u00e9l\u00e9ments sont \u00e0 leur place\n            # on \u00e9change T[j] avec le suivant s'ils ne sont pas dans l'ordre\n            if T[j] &gt; T[j + 1]:\n                T[j], T[j + 1] = T[j + 1], T[j]\n    return T\n</code></pre> <p>Ces algorithmes sont consid\u00e9r\u00e9s comme inefficaces car d'une complexit\u00e9 quadratique en \\(O(n^2)\\). </p> <p>L'efficacit\u00e9 du tri fusion repose sur la facilit\u00e9 de r\u00e9unir deux tableaux tri\u00e9s en un seul (leur \u00ab fusion \u00bb). En effet, pour construire le nouveau tableau \u00e9l\u00e9ment par \u00e9l\u00e9ment, il suffit de choisir \u00e0 chaque fois le plus petit entre le premier \u00e9l\u00e9ment du premier tableau et le premier \u00e9l\u00e9ment du second tableau. Inutile de regarder les \u00e9l\u00e9ments suivants de chaque tableau puisqu'ils seront plus grands que les premiers. De cette fa\u00e7on, la fusion entre deux tableaux tri\u00e9s se fait en temps lin\u00e9aire.</p> <p>Tri Fusion d'un tableau  <code>T</code> de taille <code>n</code>:</p> Etape Description Diviser D\u00e9couper le tableau  <code>T</code> en son milieu (<code>n//2</code>) pour avoir deux sous-tableaux  <code>T1</code> et <code>T2</code> de moiti\u00e9 de taille R\u00e9gner Trier les deux sous tableaux <code>T1</code> et <code>T2</code> Combiner Fusionner les deux sous-tableaux tri\u00e9s <code>T1</code> et <code>T2</code> <p> </p> <p>Commen\u00e7ons par \u00e9crire une fonction qui fusionne deux tableaux tri\u00e9s T1 et T2. On construit le nouveau tableau \u00e9l\u00e9ment par \u00e9l\u00e9ment en retirant tant\u00f4t le premier \u00e9l\u00e9ment du premier tableau, tant\u00f4t le premier \u00e9l\u00e9ment du deuxi\u00e8me tableau, en prenant \u00e0 chaque fois le plus petit des deux (\u00e0 supposer qu'aucun des deux tableaux ne soit vide, sinon la r\u00e9ponse est imm\u00e9diate).</p> <p>En voici une version it\u00e9rative<sup>1</sup> : </p> <pre><code>def fusion(T1: list, T2: list) -&gt; list:\n    \"\"\" (list, list) -&gt; list\n    T1 et T2 sont des tableaux tri\u00e9s\n    Renvoie le tableau tri\u00e9 des \u00e9l\u00e9ments de T1 et T2 ensembles\n    \"\"\"\n    T = []\n    i1, i2 = 0, 0     # Indices des \u00e9l\u00e9ments \u00e0 comparer de T1 et T2\n    # Tant qu'il reste des \u00e9l\u00e9ments dans les deux tableaux\n    while i1 &lt; len(T1) and i2 &lt; len(T2):\n        # On ajoute le plus petit des deux \u00e9l\u00e9ments dans T\n        if T1[i1] &lt;= T2[i2]:\n            T.append(T1[i1])\n            i1 += 1\n        else:\n            T.append(T2[i2])\n            i2 += 1\n    # Un des deux tableaux et vide, on transf\u00e8re tous les \u00e9l\u00e9ments restants dans T\n    while i1 &lt; len(T1):\n        T.append(T1[i1])\n        i1 += 1\n    while i2 &lt; len(T2):\n        T.append(T2[i2])\n        i2 += 1\n    return T\n</code></pre> <p>A partir de l\u00e0, le tri-fusion se construit naturellement de fa\u00e7on r\u00e9cursive :</p> <ol> <li>Si le tableau n'a qu'un \u00e9l\u00e9ment, il est d\u00e9j\u00e0 tri\u00e9.</li> <li>Sinon, \"diviser\" le tableau en deux parties \u00e0 peu pr\u00e8s \u00e9gales.</li> <li>Trier r\u00e9cursivement les deux parties avec l'algorithme du tri fusion.</li> <li>Fusionner les deux tableaux tri\u00e9s en un seul tableau tri\u00e9.</li> </ol> <pre><code>def tri_fusion(T: list) -&gt; list:\n    \"\"\" (list) -&gt; list\n    Renvoie le tableau tri\u00e9 (tri-fusion) des \u00e9l\u00e9ments de T\n    \"\"\"\n    if len(T) &lt;= 1:            # Si le tableau n'a qu'un \u00e9l\u00e9ment, il est d\u00e9j\u00e0 tri\u00e9\n        return T\n    else:\n        # On divise en deux parties \u00e0 peu pr\u00e8s \u00e9gales\n        T1 = T[:len(T)//2]     \n        T2 = T[len(T)//2:]\n        # Et on fusionne les deux tableaux apr\u00e8s les avoir tri\u00e9s\n        return fusion(tri_fusion(T1), tri_fusion(T2))\n</code></pre> <p>\u00c9tudions la complexit\u00e9 temporelle pour un tableau de taille \\(n\\).  Comme pour l'algorithme du tri par dichotomie, \u00e0 chaque appel r\u00e9cursif du tri fusion, la taille du tableau \u00e0 tri\u00e9 est divis\u00e9e par 2, la complexit\u00e9 en donc en \\(log_2(n)\\). Mais fusionner les deux tableaux n\u00e9cessite de faire entre \\(k/2\\) et \\(k\\) comparaisons, o\u00f9 \\(k\\) est la taille des sous-tableaux, c'est donc de l'ordre de \\(O(n)\\).  La complexit\u00e9 du tri fusion est donc de l'ordre  \\(O(n \\times log_2(n))\\)</p> <p>Cours</p> <p>La complexit\u00e9 en temps de l'algorithme de tri fusion est donc lin\u00e9arithmique en  \\(O(n \\times log_2(n))\\).</p> <p>Avec un tableau d'un milliard de valeurs, l'algorithme na\u00eff en \\(O(n^2)\\) demande de l'ordre de \\(10^{18}\\) op\u00e9rations. Avec des ordinateurs effectuant \\(10^9\\) op\u00e9rations par secondes, il faut de l'ordre de \\(10^9\\) secondes, soit environ 30 ans.</p> <p>Avec le tri fusion, le nombre d'op\u00e9rations est de l'ordre de \\(10^9 \u00d7 log_2(10^9) \\simeq 10^9 \\times 30\\), ce qui s'ex\u00e9cute en 30 secondes sur les ordinateurs pr\u00e9c\u00e9dents<sup>2</sup>. </p>"},{"location":"algorithmique/3-diviser-pour-regner/#rotation-dune-image-dun-quart-de-tour","title":"Rotation d'une image d'un quart de tour","text":"<p>Commen\u00e7ons par analyser un algorithme na\u00eff de rotation d'image pixel par pixel.</p> <p>Observons la rotation de deux pixel A et B sur le sch\u00e9ma suivant : Le pixel  initialement en position  <code>[2][4]</code> se d\u00e9place en position <code>[4][3]</code> dans une image de  6 x 6 pixels.  De fa\u00e7on g\u00e9n\u00e9rale, un pixel en position <code>[ligne][colonne]</code> se d\u00e9place en position<code>[colonne][nb pixels \u2013 1 - ligne]</code>.  </p> <p> </p> <p>Utilisons cette observation pour \u00e9crire une rotation pixel par pixel en utilisant l'import d'une image par la fonction <code>imread</code> de <code>matplotlib.pyplot</code> qui donne un tableau de tableaux des pixels :</p> <pre><code>import matplotlib.pyplot as plt\n\ndef rotation_naif(image):\n    n = len(image)\n    new = [[0 for i in range(n)] for j in range(n)]\n    for lig in range(n):\n        for col in range(n):\n            new[col][n-1-lig] = image[lig][col]\n    return new\n\nimage = plt.imread('R2D2.jpg')\nimage = rotation_naif (image)\n\nplt.imshow(image)\nplt.show()\n</code></pre> <p>Avec deux boucles imbriqu\u00e9es de taille \\(n\\), la complexit\u00e9 temporelle de cet algorithme naif est donc en \\(O(n^2)\\). </p> <p>Comparons cette algorithme na\u00eff \u00e0 une m\u00e9thode \u00ab diviser pour r\u00e9gner \u00bb effectuant une rotation d'un quart de tour sur une image carr\u00e9e, dont le c\u00f4t\u00e9 est une puissance de 2.</p> <ol> <li> <p>Consid\u00e9rons l'image suivante de 256 x 256 pixels :</p> <p></p> </li> <li> <p>La premi\u00e8re \u00e9tape consiste \u00e0 diviser l'image en 4 sous-images :</p> <p></p> </li> <li> <p>puis \u00e0 effectuer une permutation circulaire de ces quatre sous-images :</p> <p></p> </li> <li> <p>Effectuons maintenant une rotation d'un quart de tour de chaque sous-image :</p> <p></p> </li> <li> <p>Il ne reste plus qu'\u00e0 r\u00e9unir les quatres sous-images en une seule. La rotation d'un quart de tour a bien \u00e9t\u00e9 effectu\u00e9e.</p> </li> </ol> <p>L'\u00e9tape 4 consiste \u00e0 effectuer une rotation des quatres sous-images, la m\u00e9thode \u00ab diviser pour r\u00e9gner \u00bb est encore utilis\u00e9e. Le processus est donc r\u00e9cursif, il se r\u00e9p\u00e8te jusqu'\u00e0 obtenir des sous-images qui ne contiennent qu'un seul pixel, un pixel \u00e9tant uniform\u00e9ment colori\u00e9, il est inutile de le tourner.</p> <p>Rotation d'une image d'un quart de tour par la m\u00e9thode \u00ab diviser pour r\u00e9gner \u00bb: </p> Etape Description Diviser D\u00e9couper l'image en 4 sous-images et effectuer une permutation circulaire R\u00e9gner Effectuer une rotation d'1/4 de tour pour chaque sous-image Combiner R\u00e9unir les 4 sous-images ensemble <p>Voil\u00e0 ce qu'on obtient \u00e9tape par \u00e9tape :</p> <p></p> <p>On poursuit sans repr\u00e9senter le quadrillage devenu trop fin pour les deux derni\u00e8res \u00e9tapes.</p> <p> </p> <p>Traduisons ce processus en Python :</p> <pre><code>import matplotlib.pyplot as plt\n\ndef rotation(image):\n    n = len(image)\n\n    if n == 1:             # Il ne reste qu'un seul pixel\n        return image       # Inutile de le tourner\n\n    # Diviser en 4 sous-image\n    # Sous-image quart haut gauche\n    hg = [[image[lig][col] for col in range(n//2)] for lig in range(n//2)]\n    # Sous-image quart haut droit\n    hd = [[image[lig][col] for col in range(n//2, n)] for lig in range(n//2)]\n    # Sous-image quart bas gauche\n    bg = [[image[lig][col] for col in range(n//2)] for lig in range(n//2, n)]\n    # Sous-image quart bas droit\n    bd = [[image[lig][col] for col in range(n//2, n)] for lig in range(n//2, n)]\n\n    # Permutation circulaire des 4 sous-images\n    hg, hd, bg, bd = bg, hg, bd, hd\n\n    # Rotation r\u00e9cursive d'1/4 de tour de chaque sous-image\n    hg = rotation(hg)\n    hd = rotation(hd)\n    bd = rotation(bd)\n    bg = rotation(bg)\n\n    # R\u00e9unir les 4 sous-images\n    image = []\n    for li in range(n//2):   # les lignes du haut\n        image.append(hg[li] + hd[li])\n    for li in range(n//2):   # les lignes du bas\n        image.append(bg[li] + bd[li])           \n\n    return image\n\nimage = plt.imread('R2D2.jpg')\nimage = rotation(image)\nplt.imshow(image)\nplt.show()\n</code></pre> <p>Essayons d'estimer la complexit\u00e9 de cette rotation d'un quart de tour. La fonction <code>rotation</code> ex\u00e9cute 4 boucles imbriqu\u00e9es de taille \\(n/2\\) pour d\u00e9couper l'image en 4 sous-images, chaque boucle a donc une complexit\u00e9 en \\(O(n^2)\\). Ensuite, la fonction fait appel 4 fois \u00e0 elle-m\u00eame sur ces images d'une taille r\u00e9duite par un facteur 2, suivi \u00e0 nouveau de boucles imbriqu\u00e9es en \\(O(n^2)\\) pour combiner les 4 sous-images. On a donc un nombre d'op\u00e9rations qui v\u00e9rifie la relation \\(C(n) = 4 \\times O(n^2) + 4 \\times C(n/2) + 4 \\times O(n^2)\\). On peut montrer par un calcul math\u00e9matique que la complexit\u00e9 de cette rotation par la m\u00e9thode est de l'ordre de \\(O(n^2 \\times log_2(n))\\), donc un peu moins bonne que celle de l'algorithme na\u00eff<sup>3</sup>.</p>"},{"location":"algorithmique/3-diviser-pour-regner/#tri-rapide-quicksort","title":"Tri Rapide (quicksort)","text":"<p>La m\u00e9thode consiste \u00e0 choisir un \u00e9l\u00e9ment du tableau, appel\u00e9 pivot, pour le mettre \u00e0 sa place d\u00e9finitive en pla\u00e7ant tous les \u00e9l\u00e9ments du tableau qui lui sont inf\u00e9rieurs dans un sous-tableau \u00e0 sa gauche et tous ceux qui lui sont sup\u00e9rieurs dans un autre sous-tableau \u00e0 sa droite. Le pivot peut \u00eatre choisi au hasard ou de fa\u00e7on syst\u00e9matique, par exemple le premier ou le dernier \u00e9l\u00e9ment du tableau. </p> <p>L'algorithme est r\u00e9cursif, pour trier chacun des sous-tableaux on choisit un nouveau pivot et on r\u00e9p\u00e8te l'op\u00e9ration jusqu'\u00e0 ce que tous les sous-tableaux n'aient plus qu'une ou aucune valeur. Il ne reste plus qu'\u00e0 r\u00e9unir tous les sous-tableaux et l'ensemble sera tri\u00e9.</p> <p>Voyons un exemple dans lequel le pivot choisi est toujours le dernier \u00e9l\u00e9ment du tableau :</p> <p> </p> <p>Tri Rapide d'un tableau <code>T[1, \u2026, n]</code></p> Etape Description Diviser D\u00e9couper le tableau <code>T[1, \u2026, n]</code> de part et d'autre d'un pivot en trois sous-tableaux : le premier contenant toutes les valeurs inf\u00e9rieures au pivot, le second contenant celles \u00e9gales au pivot et le dernier celles sup\u00e9rieures au pivot R\u00e9gner Trier les sous-tableaux des valeurs inf\u00e9rieures et des valeurs sup\u00e9rieures au pivot (celui des valeurs \u00e9gales au pivot est d\u00e9j\u00e0 tri\u00e9) Combiner Regrouper les trois sous-tableaux tri\u00e9s <p>En pratique, le programme Python est construit en utilisant trois sous-tableaux contenant respectivement les valeurs inf\u00e9rieures, sup\u00e9rieures et \u00e9gales au pivot. On trie les deux premiers et on combine les trois.</p> <pre><code>from random import randint\n\ndef tri_rapide(T):\n    \"\"\" list[int]-&gt; list[int]\n    Renvoie le tableau T tri\u00e9 par tri rapide\n    \"\"\"\n    if len(T) &lt;= 1:    # si T n'a plus qu'une valeur ou qu'il est vide\n        return []       # il n'y a rien \u00e0 trier\n\n    # Diviser\n    pivot = T[randint(0, len(T)-1)]  # pivot au hasard, on peut utiliser T[-1] pour prendre le dernier \u00e9l\u00e9ment\n    val_inferieures = []\n    val_egales = []\n    val_superieures = []\n\n    for elem in T:\n        if elem &lt; pivot: val_inferieures.append(elem)\n        elif elem &gt; pivot: val_superieures.append(elem)\n        else: val_egales.append(elem)\n\n    # R\u00e9gner\n    return tri_rapide(val_inferieures) + val_egales + tri_rapide(val_superieures)\n\n\ntab = [randint(0, 100) for i in range(10000)]\nprint(tri_rapide(tab))\n</code></pre> <p>Dans le pire des cas o\u00f9 \u00e0 chaque it\u00e9ration toutes les valeurs se trouvent toutes du m\u00eame c\u00f4t\u00e9 du pivot, la complexit\u00e9 du tri rapide est quadratique en \\(O(n^2)\\).  Cependant en pratique,  pour des donn\u00e9es r\u00e9parties al\u00e9atoirement, la complexit\u00e9 moyenne est en \\(O(n \\times log_2(n))\\), faisant du tri rapide un des tris les plus rapides.</p> <ol> <li> <p>Il existe aussi une version r\u00e9cursive en utilisant les tranches de tableau : <pre><code>def fusion(T1: list, T2: list) -&gt; list:\n    \"\"\" (list, list) -&gt; list\n    T1 et T2 sont des tableaux tri\u00e9s\n    renvoie le tableau tri\u00e9 des \u00e9l\u00e9ments de T1 et T2 ensembles \n    \"\"\"\n    if len (T1) == 0: return T2\n    if len (T2) == 0: return T1\n    if T1[0] &lt; T2[0]:\n        return [T1[0]] + fusion(T1[1:], T2)\n    else:\n        return [T2[0]] + fusion(T1, T2[1:])\n</code></pre> \u21a9</p> </li> <li> <p><pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; math.log(10**9,2)\n29.897352853986263\n</code></pre> \u21a9</p> </li> <li> <p>L'impl\u00e9mentation pr\u00e9sent\u00e9e ici de la m\u00e9thode \u00ab diviser pour r\u00e9gner \u00bb n'est pas optimale en terme de complexit\u00e9 spatiale non plus. En copiant les quatre sous-image dans des images temporaires, elle n\u00e9cessite une utilisation de l'espace place m\u00e9moire sup\u00e9rieure \u00e0 la taille de l'image ! Il existe une impl\u00e9mentation \u00ab en place \u00bb permettant de r\u00e9duire l'espace m\u00e9moire utilis\u00e9. Source: https://eduscol.education.fr/document/10100/download \u21a9</p> </li> </ol>"},{"location":"algorithmique/4-programmation-dynamique/","title":"Programmation dynamique","text":""},{"location":"algorithmique/4-programmation-dynamique/#un-exemple-simple","title":"Un exemple simple","text":"<p> Le jeu de Dames se pratique sur un damier de 10 cases sur 10. Les pions sont plac\u00e9s sur les cases fonc\u00e9es et ne peuvent se d\u00e9placer que d'une case \u00e0 la fois, toujours vers l'avant en diagonale. Une des strat\u00e9gies du jeu consiste \u00e0 amener un pion sur la derni\u00e8re rang\u00e9e pour \u00eatre promu en dame. </p> <p>La question est la suivante :  Sur le damier ci-contre, combien de chemins peut emprunter le pion blanc depuis cette case de d\u00e9part pour arriver \u00e0 la case vide sur la rang\u00e9e du haut et \u00eatre promu en dame ? </p> <p>Si on essaie de compter tous les chemins on risque de vite perdre le compte. Une id\u00e9e simple pour r\u00e9pondre \u00e0 ce probl\u00e8me efficacement consiste \u00e0 noter \u00e0 chaque intersection le nombre de chemins en partant de la fin. D\u00e9coupons le processus en plusieurs \u00e9tapes.</p> Etape 1Etape 2Etape 3Etape 4Etape 5Etape 6 <p>On peut d\u00e9j\u00e0 observer qu'un certain nombre de cases ne peuvent pas \u00eatre atteintes par le pion blanc depuis sa position de d\u00e9part, ou ne peuvent pas mener \u00e0 la case d'arriv\u00e9e, on peut donc les exclure de nos calculs.</p> <p></p> <p>Il n'y a que deux cases sur la deuxi\u00e8me rang\u00e9e qui permettent d'aller sur la case d'arriv\u00e9e, et pour chacune il n'y a qu'un seul chemin possible. </p> <p>Marquons ces cases avec leur nombre de chemins possibles.</p> <p></p> <p>Il y a trois cases sur la troisi\u00e8me rang\u00e9e pouvant aller sur les deux cases pr\u00e9c\u00e9dentes. </p> <p>Un pion sur la case \u00e0 gauche ou celle \u00e0 droite n'a qu'un seul chemin possible. </p> <p>Par contre un pion sur la case au milieu peut se d\u00e9placer soit vers le haut \u00e0 droite, soit vers le haut \u00e0 gauche. Dans les deux cas, il n'a plus qu'un chemin possible ensuite. Il y a donc deux chemins possibles au d\u00e9part de cette case.</p> <p></p> <p>Continuons \u00e0 la rang\u00e9e suivante. Comme dans la rang\u00e9e pr\u00e9c\u00e9dente, un pion sur la case \u00e0 gauche ou celle \u00e0 droite n'a qu'un seul chemin possible.</p> <p>Les deux pions plac\u00e9s au milieu peuvent se d\u00e9placer soit vers le haut \u00e0 droite, soit vers le haut \u00e0 gauche. Selon le choix que l'on fait, ils pourront emprunter 1 ou 2 chemins diff\u00e9rents. Au total, il y a donc 3 chemins possibles au d\u00e9part de ces deux cases. On comprend que le nombre de chemins possibles \u00e0 partir d'une case est \u00e9gal \u00e0  la somme des nombres de chemins au d\u00e9part des cases \u00e0 gauche et \u00e0 droite de la rang\u00e9e du dessus.</p> <p>On a d\u00e9compos\u00e9 un probl\u00e8me en deux sous-probl\u00e8mes plus simples.</p> <p></p> <p>Appliquons cette m\u00eame id\u00e9e \u00e0 la rang\u00e9e suivante, et notons le nombre de chemins possibles \u00e9gal \u00e0 la somme des nombres de chemins indiqu\u00e9s dans les cases \u00e0 gauche et \u00e0 droite sur la rang\u00e9e du dessus.</p> <p>On constate le nombre de chemins calcul\u00e9 pour une case, par exemple 3, est utilis\u00e9 deux fois : pour la case qui a 4 chemins possibles et pour la case qui a 6 chemins possibles.</p> <p>Il faut donc garder en m\u00e9moire les r\u00e9sultats interm\u00e9diaires pour ne pas recalculer la m\u00eame chose plusieurs fois.</p> <p></p> <p>Continuons \u00e0 descendre dans le damier rang\u00e9 par rang\u00e9e en appliquant le m\u00eame principe : pour chaque case on ajoute les nombres de chemins trouv\u00e9s pour les cases \u00e0 gauche et \u00e0 droite de la rang\u00e9e de dessus.  </p> <p>On arrive au r\u00e9sultat final : il y a  126 chemins possibles pour aller de la case de d\u00e9part jusqu'\u00e0 l'arriv\u00e9e.</p> <p></p> <p>On peut observer deux choses dans la r\u00e9alisation de cet algorithme : </p> <ol> <li> <p>Pour chaque case, il suffit de faire la somme du nombre de chemins depuis la case de gauche et depuis la case de droite sur la rang\u00e9e au-dessus : on d\u00e9coupe le probl\u00e8me en sous-probl\u00e8mes plus faciles \u00e0 r\u00e9soudre.  </p> </li> <li> <p>Le nombre de chemins calcul\u00e9 pour une case est utilis\u00e9 pour calculer les nombres de chemins de plusieurs autres cases. Les sous-probl\u00e8mes se chevauchent. Il faut garder en m\u00e9moire les r\u00e9sultats interm\u00e9diaires pour ne pas recalculer la m\u00eame chose plusieurs fois.</p> </li> </ol> <p>Ce sont les deux principes de la programmation dynamique.</p> <p>Exercice corrig\u00e9</p> <p>Mario veut rejoindre la princesse Peach. Il ne peut se d\u00e9placer que vers la gauche et vers le haut, et ne peut jamais revenir en arri\u00e8re. Combien de chemins diff\u00e9rents peut-il emprunter ?</p> <p> </p> R\u00e9ponse <p>Notons \u00e0 chaque intersection le nombre de chemins en partant de la fin. Pour chaque intersection, il suffit de faire la somme du nombre de chemins depuis l\u2018intersection \u00e0 sa gauche et des chemins depuis l'intersection au dessus.   </p> <p> </p> <p>Mario peut prendre 10 chemins diff\u00e9rents.</p> <p>Cours</p> <p>La programmation dynamique<sup>1</sup> r\u00e9sout un probl\u00e8me en combinant des solutions de sous-probl\u00e8mes qui se chevauchent, c'est \u00e0 dire qu'il poss\u00e8de des sous-sous-probl\u00e8mes identiques.  </p> <p>Afin d'\u00e9viter les calculs redondants, chaque sous-sous-probl\u00e8me n'est r\u00e9solu qu'une seule fois et sa r\u00e9ponse est gard\u00e9e en m\u00e9moire.</p> <p>On peut voir la programmation dynamique comme une am\u00e9lioration ou une adaptation de la m\u00e9thode \u00ab diviser pour r\u00e9gner \u00bb puisqu'on divise un probl\u00e8me en sous probl\u00e8mes, \u00e0 la diff\u00e9rence que la programmation dynamique s'applique quand les sous-probl\u00e8mes se chevauchent, autrement dit un sous-probl\u00e8me peut \u00eatre utilis\u00e9 dans la solution de plusieurs sous-probl\u00e8mes diff\u00e9rents. Tandis que l'approche  \u00ab diviser pour r\u00e9gner \u00bb cr\u00e9e des sous-probl\u00e8mes qui sont compl\u00e8tement s\u00e9par\u00e9s et peuvent \u00eatre r\u00e9solus ind\u00e9pendamment les uns des autres.</p> <p> </p>"},{"location":"algorithmique/4-programmation-dynamique/#rendu-de-monnaie","title":"Rendu de monnaie","text":"<p>Probl\u00e8me : On dispose d'un nombre illimit\u00e9 de pi\u00e8ces de \u2460, \u2461, \u2464 et \u2469 euros pour rendre une certaine somme. Quel est le plus petit nombre de pi\u00e8ces n\u00e9cessaire ?</p>"},{"location":"algorithmique/4-programmation-dynamique/#algorithme-glouton","title":"Algorithme glouton","text":"<p>On a vu en classe de premi\u00e8re une solution donn\u00e9e par un algorithme glouton, qui consiste \u00e0 faire, \u00e9tape par \u00e9tape, un choix optimum local, dans l'espoir d'obtenir un r\u00e9sultat optimum global : dans ce cas on choisit de fa\u00e7on r\u00e9p\u00e9titive la pi\u00e8ce de plus grande valeur qui ne d\u00e9passe pas la somme restante : </p> Programme it\u00e9ratifProgramme r\u00e9cursif <pre><code>pieces = [10, 5, 2, 1]\n\ndef rendu_monnaie_glouton(n):\n    nombre_pieces = 0\n    i = 0 # on commence par la plus grande pi\u00e8ce\n    while n &gt; 0:\n        if n &gt;= pieces[i]: # on peut rendre pieces[i]\n            nombre_pieces += 1\n            n = n - pieces[i]\n        else:    # on passe \u00e0 la pi\u00e8ce suivante\n            i = i + 1\n    return nombre_pieces    \n</code></pre> <pre><code>pieces = [10, 5, 2, 1]\n\ndef rendu_monnaie_glouton(n, i=0):\n    if n == 0: \n       return 0  \n    if pieces[i] &lt;= n:  # on peut rendre pieces[i]\n        return 1 + rendu(n - pieces[i], i)\n    return rendu(n, i + 1)   # on passe \u00e0 la pi\u00e8ce suivante\n</code></pre> <p>Testons l'algorithme glouton pour rendre 13 euros. On obtient bien les 3 pi\u00e8ces \u2469 + \u2461 + \u2460 qui font un total de 13.</p> <pre><code>&gt;&gt;&gt; rendu_monnaie_glouton(13)\n3\n</code></pre> <p>Mais que se passe-t-il si on n'a pas de pi\u00e8ce de 1 euro ? Rempla\u00e7ons <code>pieces = [10, 5, 2]</code> et testons l'algorithme : </p> <pre><code>IndexError: list index out of range\n</code></pre> <p>Pourtant on peut rendre \u2464 + \u2461 + \u2461 + \u2461 + \u2461 qui font aussi un total de 13 euros !</p> <p>C'est le propre des algorithmes gloutons : une fois qu'une d\u00e9cision a \u00e9t\u00e9 prise, on ne revient pas en arri\u00e8re. Dans certains cas l'algorithme ne trouve pas de solution, ou pas la meilleure solution.  Ici l'algorithme choisit la pi\u00e8ce de 10 euros qui ne m\u00e8ne \u00e0 rien, il ne peut pas revenir en arri\u00e8re et ressayer avec une autre pi\u00e8ce !</p>"},{"location":"algorithmique/4-programmation-dynamique/#programmation-dynamique_1","title":"Programmation dynamique","text":"<p>La programmation dynamique consiste \u00e0 r\u00e9soudre notre probl\u00e8me en combinant les solutions de sous-probl\u00e8mes. Ici, rendre une somme \\(n\\) peut se faire de plusieurs mani\u00e8res  :</p> <ul> <li>rendre \\(n \u2013 10\\) et rajouter une pi\u00e8ce de \u2469, ou</li> <li>rendre \\(n \u2013 5\\) et rajouter une pi\u00e8ce de \u2464, ou</li> <li>rendre \\(n \u2013 2\\) et rajouter une pi\u00e8ce de \u2461.</li> </ul> <p>Dans notre exemple, pour rendre 13 euros on peut :</p> <ul> <li>rendre 3 et rajouter une pi\u00e8ce de \u2469, ou</li> <li>rendre 8 et rajouter une pi\u00e8ce de \u2464, ou</li> <li>rendre 11 et rajouter une pi\u00e8ce de \u2461.</li> </ul> <p> </p> <p>Chacun de ces sous-probl\u00e8mes peut \u00eatre r\u00e9solus de la m\u00eame fa\u00e7on. Constituons l'arbre des possibilit\u00e9s :</p> <p> </p> <p>Certaines branches m\u00e8nent \u00e0 une solution, quand il reste 0 euros \u00e0 rendre, d'autres pas. </p> <p>Impl\u00e9mentons cet algorithme en consid\u00e9rant trois cas :</p> <ul> <li>Si \\(n\\) est \u00e9gal \u00e0 0, alors on a rendu \\(n\\), il n'y a pas de pi\u00e8ces suppl\u00e9mentaires \u00e0 rendre, on renvoie 0.</li> <li>Si \\(n\\) est plus petit que la valeur de la plus petite pi\u00e8ce, on ne pourra pas rendre \\(n\\), on renvoie une tr\u00e8s grande valeur, par exemple en utilisant <code>inf</code> la valeur infinie du module avec <code>math</code>, afin de ne pas impacter une autre branche qui m\u00e8nerait \u00e0 une solution.</li> <li>Sinon, on renvoie 1 plus le plus petit nombre de pi\u00e8ces de tous les rendus de \\(n \u2013 p\\), pour toutes les pi\u00e8ces de valeur \\(p\\) telles que \\(p &lt;= n\\). </li> </ul> <p>Traduisons cet algorithme en Python :</p> <pre><code>from math import inf     # valeur infinie du module math\n\npieces = [10, 5, 2]\n\ndef rendu_monnaie_dynamique(n):\n    if n == 0:  # Il faut 0 piece pour rendre 0 euro\n        return 0                \n    if n &lt; min(pieces):   # n est plus petit que la plus petite piece\n        return inf          # on ne peut pas rendre n avec ces pieces\n    # Tableau de tous les rendus possibles de n - p\n    rendus = [rendu_monnaie_dynamique(n - p) for p in pieces if p &lt;= n]\n    # On rend 1 piece + le plus petit nombre de pieces de tous les rendus\n    return 1 + min(rendus)  \n\n&gt;&gt;&gt; rendu_monnaie_dynamique(13)\n5\n</code></pre> <p>Avec la programmation dynamique, tous les cas possibles ont \u00e9t\u00e9 trait\u00e9s, et plusieurs cas ont renvoy\u00e9 la m\u00eame solution. On a donc une solution optimale au probl\u00e8me.</p> <p>Mais testons maintenant cette fonction avec quelques valeurs plus grandes que <code>13</code>. Tr\u00e8s vite la fonction prend beaucoup de temps pour s'ex\u00e9cuter. Quelques secondes pour ex\u00e9cuter <code>rendu_monnaie_dynamique(60)</code>, dizaines de secondes pour <code>rendu_monnaie_dynamique(70)</code>, plusieurs minutes pour <code>rendu_monnaie_dynamique(80)</code>, etc.  Le programme devient vite trop lent, m\u00eame pour des rendus tr\u00e8s simples de quelques pi\u00e8ces de \u2469 euros !</p> <p>Essayons d'estimer la complexit\u00e9 temporelle de cette fonction. Le nombre d'op\u00e9rations pour rendre un montant \\(n\\) avec des pieces de 10, 5 et 2 est le nombre d'op\u00e9rations pour rendre \\(n-10\\), plus le nombre d'op\u00e9rations pour rendre \\(n-5\\), plus celui pour rendre \\(n-2\\), plus quelques op\u00e9rations \u00e9l\u00e9mentaires. Si on appelle \\(T(n)\\) le nombre d'op\u00e9rations pour rendre \\(n\\), alors on peut donc \u00e9crire que :</p> <p>\\(T(n) = T(n-10) + T(n-5) + T(n-2) + O(1)\\),</p> <p>avec \\(O(1)\\) pour les quelques op\u00e9rations suppl\u00e9mentaires. Pour de grandes valeurs de \\(n\\), on peut faire l'approximation que retirer 10, 5, 2 ou 1 euro \u00e0 \\(n\\) ne change pas grand chose, donc que \\(T(n-10)\\), \\(T(n-5)\\), et \\(T(n-2)\\) sont du m\u00eame ordre de grandeur que \\(T(n-1)\\), autrement dit  \\(T(n) \\approx 3 \\times T(n-1) + O(1)\\). A chaque fois que \\(n\\) augmente de 1, le nombre d'op\u00e9rations est multipli\u00e9 par 3, plus quelques op\u00e9rations. La complexit\u00e9 est donc exponentielle en \\(O(3^n)\\) ici, ou de fa\u00e7on g\u00e9n\u00e9rale en \\(O({nbPieces}^n)\\) pour un rendu avec \\(nbPieces\\) pieces.  </p>"},{"location":"algorithmique/4-programmation-dynamique/#version-descendante-top-down-recursivite-et-memoisation","title":"Version descendante (top-down), r\u00e9cursivit\u00e9 et m\u00e9mo\u00efsation","text":"<p>Les appels r\u00e9cursifs sont trop nombreux, la complexit\u00e9 est trop importante pour calculer un solution en temps raisonnable.</p> <p>En programmation dynamique les sous-probl\u00e8mes se chevauchent et les m\u00eames calculs reviennent plusieurs fois. Dans un exemple aussi simple que celui de rendre 13 euros, on retrouve 2 fois la branche qui part de \"6\" :</p> <p> </p> <p>La solution pour limiter le nombre d'op\u00e9rations consiste \u00e0 ne calculer les solutions des sous-probl\u00e8mes qu'une seule fois et de les garder en m\u00e9moire. C'est la technique de m\u00e9mo\u00efsation.</p> <p>Cours</p> <p>La m\u00e9mo\u00efsation consiste \u00e0 garder en m\u00e9moire les valeurs d\u00e9j\u00e0 calcul\u00e9es.</p> <p>Par exemple, avec un dictionnaire d\u00e9clar\u00e9 en variable globale :</p> <pre><code>from math import inf     # valeur infinie du module math\n\nmemoise = {0: 0}       # Il faut 0 piece pour rendre 0 euro\npieces = [10, 5, 2]\n\ndef rendu_monnaie_dynamique(n):\n    if n in memoise:             # Si on a d\u00e9j\u00e0 calcul\u00e9 le nombre de pi\u00e8ces pour n\n        return memoise[n]\n    if n &lt; min(pieces):   # n est plus petit que la plus petite piece\n        return inf          # On ne peut pas rendre n avec ces pieces\n\n    # Tableau de tous les rendus possibles de n - p\n    rendus = [rendu_monnaie_dynamique(n - p) for p in pieces if p &lt;= n]\n    # On rend 1 piece + le plus petit nombre de pieces de tous les rendus\n    memoise[n] = 1 + min(rendus)\n    return memoise[n]\u2003\n</code></pre> <p>Cette fois ci, le r\u00e9sultat est imm\u00e9diat, m\u00eame avec des valeurs de <code>n</code> de quelques milliers (dans la limite de la pile d'appels r\u00e9cursifs).</p>"},{"location":"algorithmique/4-programmation-dynamique/#version-ascendante-bottom-up","title":"Version ascendante (bottom-up)","text":"<p>On a d\u00e9j\u00e0 vu dans l'exemple pr\u00e9c\u00e9dent comment \u00e9crire un algorithme r\u00e9cursif en utilisant la m\u00e9mo\u00efsation. Une autre approche de la programmation dynamique consiste \u00e0 calculer d'abord les sous-probl\u00e8mes en partant d'un cas de base et \u00e0  \u00ab remonter \u00bb jusqu'\u00e0 r\u00e9soudre le probl\u00e8me initial : c'est la version ascendante, ou bottom-up.</p> <p> </p> <p>Appelons \\(nb_i\\) le nombre de pi\u00e8ces pour rendre une somme \\(i\\). Comme dans l'approche top-down,  \\(nb_i\\) est \u00e9gal \u00e0 1 + le plus petit nombre de pi\u00e8ces de tous les rendus de \\(i \u2013 p\\), pour toutes les pi\u00e8ces \\(p\\) telles que \\(p &lt;= i\\). Si aucune pi\u00e8ce p ne convient, alors il n'est pas possible de rendre \\(i\\), on peut repr\u00e9senter \\(nb_i\\) par l'infini<sup>2</sup>.</p> <p>On va cr\u00e9er le m\u00eame dictionnaire que celui utilis\u00e9 pour la m\u00e9mo\u00efsation, mais en le remplissant it\u00e9rativement en partant cette fois de 0 et en incr\u00e9mentant jusqu'\u00e0 n.</p> <pre><code>from math import inf\n\nnb = {0: 0}       # dictionnaire {montant i: nombres de pieces pour rendre i}\npieces = [10, 5, 2]\n\ndef rendu_bottom_up(n):\n    # On remplit le dictionnaire pour tous les montants i allant de 1 \u00e0 n\n    for i in range(1, n + 1):   \n        # Tableau de tous les rendus possibles de i - p\n        rendus = [nb[i - p] for p in pieces if p &lt;= i]\n\n        if rendus == []:   # Si c'est impossible de rendre i \n            nb[i] = inf\n        else:           # Sinon on prend le plus petit nombre de pieces des i - p et on ajoute 1 \n            nb[i] = 1 + min(rendus)\n    return nb[n]              # On renvoie la valeur pour la cl\u00e9 correspondant au montant n\n</code></pre> <p>Ici, aucun soucis avec la complexit\u00e9 de la fonction (ni de limite de pile d'appels r\u00e9cursifs), la fonction s'ex\u00e9cute instantan\u00e9ment m\u00eame avec de tr\u00e8s grandes valeurs de <code>n</code>. En effet, la fonction fait une double boucle imbriqu\u00e9e, sur la valeur \u00e0 rendre \\(n\\), et sur le nombre de pi\u00e8ces disponibles. La complexit\u00e9 est donc simplement lin\u00e9aire en \\(O(n \\times nbPieces)\\), ou plus simplement en \\(O(n)\\) si on consid\u00e8re un nombre limit\u00e9 de pi\u00e8ces disponibles.</p> <p>Cours</p> <p>La programmation dynamique peut prendre deux formes :</p> <ul> <li> <p>Une forme r\u00e9cursive descendante de haut en bas, ou top-down, avec m\u00e9mo\u00efsation : </p> <ul> <li>On utilise directement la formule de r\u00e9currence.</li> <li>Lors d'un appel r\u00e9cursif, avant d'effectuer un calcul on regarde si son r\u00e9sultat n'est pas gard\u00e9 en m\u00e9moire.</li> <li>Sinon, on fait le calcul et on le garde en m\u00e9moire.</li> </ul> </li> <li> <p>Une forme it\u00e9rative ascendante de bas en haut, ou bottom-up :</p> <ul> <li>On r\u00e9sout de fa\u00e7on it\u00e9rative d'abord les sous-probl\u00e8mes de la plus \"petite taille\", puis ceux de la taille \"d'au dessus\", etc. Au fur et \u00e0 mesure on garde les r\u00e9sultats en m\u00e9moire.</li> <li>On continue jusqu'\u00e0 la taille voulue.</li> </ul> </li> </ul>"},{"location":"algorithmique/4-programmation-dynamique/#decoupe-dune-tige-dacier","title":"D\u00e9coupe d'une tige d'acier","text":"<p>Probl\u00e8me : Soit une tige d'acier que l'on peut d\u00e9couper en plusieurs morceaux pour les revendre selon la grille de prix suivante :</p> Longueur (m) 0 1 2 3 4 5 6 7 8 9 10 Prix (\u20ac) 0 1 5 8 9 10 17 17 20 24 30 <p>Comment d\u00e9couper la tige de fa\u00e7on optimale pour en tirer un revenu maximum ?</p> <p>Prenons, l'exemple d'une tige de longueur 4 m. On peut la d\u00e9couper de 8 fa\u00e7ons diff\u00e9rentes :</p> <p> </p> <p>On voit que le revenu maximum est donc 10 \u20ac, obtenu en d\u00e9coupant la tige en 2 morceaux de 2 m. Mais comment le calculer de fa\u00e7on syst\u00e9matique ? </p> <p>Un algorithme glouton simple qui consiste \u00e0 choisir en priorit\u00e9 les longueurs de morceaux les plus chers ne donne pas le meilleur revenu puisqu'il proposera toujours de garder les morceaux les plus longs possibles, ce sont les plus chers selon la grille de prix. Une approche plus fine consiste \u00e0 prendre en compte le prix lin\u00e9aire (ratio prix/longueur) pour optimiser les d\u00e9coupes. Reprenons la grille de prix de l'exemple pr\u00e9c\u00e9dant pour les morceaux jusqu'\u00e0 4 m :</p> Longueur (m) 0 1 2 3 4 Prix (\u20ac) 0 1 5 8 9 Prix lin\u00e9aire (\u20ac/m) 0 1 2,5 2,67 2,25 <p>Cet algorithme glouton commence par choisir le meilleur ratio prix/longueur, c'est une d\u00e9coupe d'un morceau de 3 m, mais ensuite il ne reste plus qu'un autre morceau de 1 m, qui lui a une tr\u00e8s faible valeur lin\u00e9aire ! C'est trop tard, l'algorithme ne peut pas revenir en arri\u00e8re sur la d\u00e9coupe du premier morceau de 3 m, on obtient un revenu de 9 \u20ac, ce n'est pas le revenu maximum.</p> <p>ici encore, la programmation dynamique nous permet de trouver la solution optimale. </p> <p>Appelons <code>R[n]</code> le revenu maximum d'une tige de longueur <code>n</code> et <code>Prix</code> le tableau de la grille de prix pour diff\u00e9rentes longueurs. </p> <p>Comment calculer <code>R[4]</code>, le revenu maximum pour d\u00e9couper une tige de longueur <code>4</code> m ?  On peut voir ce qu'il se passe si on fait une d\u00e9coupe d'un premier morceau de 1 m, ou bien de 2 m, ou encore de 3 m, ou m\u00eame ne pas couper la tige, puis comparer le revenu obtenu dans chaque cas pour prendre le plus grand. <code>R[4]</code> est donc \u00e9gal \u00e0 la plus grande valeur entre :</p> <ul> <li>Le prix d'un morceau de longueur <code>1</code>  + le revenu maximum d'un tige de longueur <code>3</code> : <code>Prix[1] + R[3]</code></li> <li>Le prix d'un morceau de longueur <code>2</code>  + le revenu maximum d'un tige de longueur <code>2</code> : <code>Prix[2] + R[2]</code></li> <li>Le prix d'un morceau de longueur <code>3</code>  + le revenu maximum d'un tige de longueur <code>1</code> : <code>Prix[3] + R[1]</code></li> <li>Le prix d'un morceau de longueur <code>4</code>  + le revenu maximum d'un tige de longueur <code>0</code>:  <code>Prix[4] + R[0]</code></li> </ul> <p> </p> <p>La valeur de <code>R[0]</code> est imm\u00e9diate, c'est le revenu maximum d'une tige de longueur de z\u00e9ro, c'est-\u00e0-dire <code>0</code>. Mais comment calculer <code>R[1]</code>, <code>R[2]</code> et <code>R[3]</code> ? On applique le m\u00eame principe.</p> <p> </p> <p>On voit qu'on a ici d\u00e9coup\u00e9 le probl\u00e8me en plusieurs sous-probl\u00e8mes. Par ailleurs, les r\u00e9sultats de certains sous-probl\u00e8mes, par exemple le calcul de <code>R[2]</code>, sont r\u00e9utilis\u00e9s plusieurs fois. Les sous-probl\u00e8mes se chevauchent. Ce sont les deux grands principes de la programmation dynamique.</p> <p>G\u00e9n\u00e9ralisons cet algorithme \u00e0 une tige de longueur <code>n</code> pour \u00e9crire <code>R[n]</code> en consid\u00e9rant les deux cas :</p> <ul> <li>Si <code>n</code> est \u00e9gal \u00e0 <code>0</code>, alors la tige a une longueur de <code>0</code>, son revenu maximum est <code>0</code>.</li> <li>Sinon, <code>R[n]</code> est \u00e9gal \u00e0 la plus grande valeur entre les prix d'un morceau de longueur <code>i</code> (<code>prix[i]</code>) auquel on ajoute le revenu maximum d'une tige de longueur <code>n - i</code> (<code>R[n-i]</code>), calcul\u00e9s pour toutes les longueurs <code>i</code> possibles, c'est-\u00e0-dire toutes les valeurs de <code>i</code> allant de <code>1</code> \u00e0 <code>n + 1</code> (exclus) sans d\u00e9passer la taille de la grille des prix :  <code>1 &lt;= i &lt; min(len(Prix), n + 1)</code>.</li> </ul> <p>On peut donc \u00e9crire la formule :  <code>R[n] = max(Prix[i] + R[n - i] pour 1 \u2264 i  &lt; min(len(Prix), n + 1)</code>  et <code>R[0] = 0</code>. </p> <p>Traduisons maintenant cet algorithme de programmation dynamique en version descendante :</p> <pre><code>Prix = [0, 1 ,5, 8, 9, 10, 17, 17, 20, 24, 30]\n\ndef R(n):\n    if n == 0: # Le revenu d'une tige de longueur 0 est 0\n        return 0\n\n    # Tableau des revenus max de toutes les d\u00e9coupes possibles de la grille de prix\n    decoupes = [Prix[i] + R(n - i) for i in range(1, min(len(Prix), n + 1))]\n\n    # On renvoie le plus grand revenu de toutes les d\u00e9coupes possibles\n    return max(decoupes)\n</code></pre> <p>Avec la programmation dynamique, tous les cas possibles ont \u00e9t\u00e9 trait\u00e9s, et plusieurs cas ont renvoy\u00e9 la m\u00eame solution. On obtient donc une solution optimale au probl\u00e8me. </p> <pre><code>&gt;&gt;&gt; R(4)\n10\n</code></pre> <p>Mais testons maintenant cette fonction avec quelques valeurs plus grandes que <code>4</code>. Tr\u00e8s vite la fonction prend beaucoup de temps pour s'ex\u00e9cuter. Essayons d'estimer la complexit\u00e9 temporelle de cette fonction.</p> <p>Si on appelle \\(T(n)\\) le nombre d'op\u00e9rations pour calculer le revenu maximum pour une tige de longueur \\(n\\), il est \u00e9gal aux nombres d'op\u00e9rations de toutes les d\u00e9coupes de tiges de longueurs \\(n - i\\), \\(T(n - i)\\), pour toutes les valeurs de \\(i\\) de la grille de prix, plus quelques op\u00e9rations \u00e9l\u00e9mentaires.</p> <p>\\(T(n) = T(n-1) + T(n-2) + T(n-3) + ..T(n-i)+... + T(n - 10) + O(1)\\),</p> <p>Si on suppose que pour les grandes valeurs de \\(n\\), \\(i\\) reste tr\u00e8s petit en comparaison, par exemple ici il vaut entre 1 et 10, alors on peut \u00e9crire que :</p> <p>\\(T(n) \\approx 10 \\times T(n-1) + O(1)\\)</p> <p>A chaque fois que \\(n\\) augmente de 1, le nombre d'op\u00e9rations est multipli\u00e9 par la taille de la grille de prix, plus quelques op\u00e9rations. La complexit\u00e9 est donc exponentielle en \\(O(10^n)\\) ici, ou de fa\u00e7on g\u00e9n\u00e9rale en \\(O({tailleGrillePrix}^n)\\) pour une grille de prix de longueur \\(tailleGrillePrix\\) . </p> <p>Cette solution n'est donc pas utilisable pratiquement, mais on constate une fois de plus que les sous-probl\u00e8mes se chevauchent, on peut donc garder les r\u00e9sultats des sous-probl\u00e8mes en m\u00e9moire pour am\u00e9liorer cette situation. Appliquons la technique de m\u00e9mo\u00efsation :</p> <pre><code>Prix = [0, 1 ,5, 8, 9, 10, 17, 17, 20, 24, 30]\n\nmemo = {0: 0}    # Le revenu d'une tige de longueur 0 est 0\ndef R(n):\n    if n in memo:  return memo[n]\n\n    # Tableau des revenus max de toutes les d\u00e9coupes possibles de la grille de prix\n    decoupes = [Prix[i] + R(n - i) for i in range(1, min(len(Prix), n + 1))]\n\n    # On renvoie le plus grand revenu de toutes les d\u00e9coupes possibles\n    memo[n] = max(decoupes)\n    return memo[n]\n</code></pre> <p>L'ajout d'une variable globale dans la fonction permet de se convaincre facilement de l'effet sur la complexit\u00e9 temporelle : <pre><code>cpt = 0\ndef R(n):\n    global cpt\n    cpt + = 1\n    if n == 0: \n        #...\n</code></pre></p> <p>Alors que la premi\u00e8re fonction, sans m\u00e9mo\u00efsation, s'appelle 1024 fois pour le calcul de R(10) et 1 043 456 fois pour R(20), la version avec m\u00e9mo\u00efsation s'appelle seulement 56 et 156 pour les m\u00eames calculs ! Mais cela se fait aux d\u00e9pends de la complexit\u00e9 spatiale.</p> <p>La version ascendante est une autre fa\u00e7on efficace de palier au probl\u00e8me de complexit\u00e9 temporelle :</p> <pre><code>Prix = [0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30]\n\nrevenus = {0: 0}    # dictionnaire {longueur m :  revenu max pour une tige de longueur m}\n\ndef R(n):\n    # On remplit le dictionnaire pour toutes les longueurs m allant de 1 \u00e0 n\n    for m in range(1, n + 1):\n\n        # Tableau des revenus max de toutes les d\u00e9coupes possibles de m\n        decoupes = [Prix[i] + revenus[m - i] for i in range(1, min(len(Prix), m + 1))]\n        revenus[m] = max(decoupes)\n\n    return revenus[n]          # On renvoie la valeur pour la cl\u00e9 correspondant \u00e0 la longueur n\n</code></pre> <p>Ici, aucun soucis avec la complexit\u00e9 de la fonction (ni de limite de pile d'appels r\u00e9cursifs), la fonction s'ex\u00e9cute instantan\u00e9ment m\u00eame avec de tr\u00e8s grandes valeurs de <code>n</code>. En effet, la fonction fait une double boucle imbriqu\u00e9e, sur la longueur de la tige \\(n\\), et sur la longueur de la grille des prix. La complexit\u00e9 est donc simplement lin\u00e9aire en \\(O(n \\times tailleGrillePrix)\\), ou plus simplement en \\(O(n)\\) si on consid\u00e8re une grille de prix de petite taille.</p>"},{"location":"algorithmique/4-programmation-dynamique/#alignement-de-sequences","title":"Alignement de s\u00e9quences","text":"<p>Un probl\u00e8me utile aux g\u00e9n\u00e9ticiens est celui de l'alignement de s\u00e9quences, qui se d\u00e9cline en de nombreuses variations, dont plusieurs peuvent \u00eatre abord\u00e9es \u00e0 l'aide de la programmation dynamique.</p> <p>Nous nous int\u00e9ressons ici \u00e0 la recherche d'une plus longue sous-cha\u00eene commune. \u00c9tant donn\u00e9 deux cha\u00eene de caract\u00e8res <code>str1</code>  et <code>str2</code>, on cherche une cha\u00eene de caract\u00e8res, la plus longue possible, qui soit \u00e0 la fois extraite de <code>str1</code>  et de <code>str2</code>. Dire qu'une sous-cha\u00eene est extraite de <code>str1</code> signifie que l'on peut obtenir cette sous-cha\u00eene en effa\u00e7ant certains caract\u00e8res de <code>str1</code>. Autrement dit, tous les caract\u00e8res de la sous-cha\u00eene commune doivent appara\u00eetre dans l'ordre dans <code>str1</code> et <code>str2</code>, m\u00eame s'ils ne sont pas cons\u00e9cutifs dans ces deux cha\u00eenes, seul l'ordre des caract\u00e8res compte.</p> <p>Prenons l'exemple de : <pre><code>str1 = 'CGCATA'\nstr2 = 'GACT'\n</code></pre></p> <p>Une plus longue sous-cha\u00eene commune est  <code>'GAT'</code>. En effet, tous les caract\u00e8res de <code>'GAT'</code> apparaissent dans le m\u00eame ordre dans <code>str1</code> :</p> <pre><code>CGCATA\n-G-AT-\n</code></pre> <p>de m\u00eame dans <code>str2</code> :</p> <p><pre><code>G-ACT \nG-A-T\n</code></pre> On peut aligner les deux chaines l'une sous l'autre et faire appara\u00eetre la sous-cha\u00eene commune dans la troisi\u00e8me ligne : <pre><code>CGCA-TA\n-G-ACT- \n-G-A-T-\n</code></pre></p> <p>Les caract\u00e8res <code>G</code>, <code>A</code> et <code>T</code> sont align\u00e9s, on peut donc extraire la sous-cha\u00eene <code>'GAT'</code> \u00e0 la fois de <code>str1</code> et <code>str2</code></p> <p>Notons bien qu'il n'y a pas unicit\u00e9 de la plus longue sous-cha\u00eene commune ! <code>'GCT'</code> est \u00e9galement une plus longue sous-cha\u00eene commune, de m\u00eame longueur 3 : <pre><code>CG-CATA\n-GAC-T-\n-G-C-T-\n</code></pre></p> <p>Abordons ce probl\u00e8me sous l'approche de programmation dynamique. Pour trouver la plus longue sous-cha\u00eene commune entre <code>'CGCATA'</code> et <code>'GACT'</code> , on commence par aligner les deux chaines en partant de la fin et par comparer les deux derniers caract\u00e8res :</p> <p> </p> <p>Les deux caract\u00e8res <code>A</code> et <code>T</code> sont diff\u00e9rents, ils ne pourront pas \u00eatre align\u00e9s dans une plus longue sous-cha\u00eene commune. On peut avancer dans notre recherche en cherchant ces deux sous-probl\u00e8mes : </p> <ol> <li>la plus longue sous-cha\u00eene commune entre la premi\u00e8re cha\u00eene, <code>'CGCATA'</code>, et la seconde cha\u00eene r\u00e9duite de son dernier caract\u00e8re,  <code>'GAC'</code>, ou </li> <li>la plus longue sous-cha\u00eene commune entre la premi\u00e8re cha\u00eene r\u00e9duite de son dernier caract\u00e8re, <code>'CGCAT'</code>, et la seconde cha\u00eene, <code>'GACT'</code>.</li> </ol> <p> </p> <p>La  plus longue sous-cha\u00eene commune entre <code>str1</code> et <code>str2</code> sera la solution trouv\u00e9e la plus longue \u00e0 ces deux sous-probl\u00e8mes.</p> <p>Commen\u00e7ons par le premier sous-probl\u00e8me : trouver la plus longue sous-cha\u00eene commune entre <code>'CGCATA'</code> et <code>'GAC'</code>. A nouveau, les deux derniers caract\u00e8res sont diff\u00e9rents, ils ne pourront pas \u00eatre align\u00e9s dans une plus longue sous-cha\u00eene commune, on peut encore partager ce probl\u00e8me en deux sous probl\u00e8mes.</p> <p>Abordons ensuite, le second sous-probl\u00e8me : trouver la plus longue sous-cha\u00eene commune entre <code>'CGCAT'</code> et <code>'GACT'</code>. Cette fois-ci, les deux derniers caract\u00e8res sont identiques, ils pourront \u00eatre align\u00e9s dans la plus longue sous-cha\u00eene commune. On garde en m\u00e9moire le caract\u00e8re <code>'T'</code> qu'on rajoutera au r\u00e9sultat de la plus longue sous-cha\u00eene commune entre ces deux derni\u00e8re chaines r\u00e9duites de ce <code>'T'</code>  :   <code>'CGCA'</code> et <code>'GAC'</code>.</p> <p> </p> <p>Passons \u00e0 l'\u00e9tape suivante. Les cha\u00eenes <code>'CGCATA'</code> et <code>'GA'</code>  ont le m\u00eame dernier caract\u00e8re, ils pourront \u00eatre align\u00e9s dans la plus longue sous-cha\u00eene commune. On garde en m\u00e9moire le caract\u00e8re <code>'A'</code> qu'on rajoutera au r\u00e9sultat de la plus longue sous-cha\u00eene commune entre ces deux derni\u00e8re chaines r\u00e9duites de ce <code>'A'</code>  :  <code>'CGCAT'</code> et <code>'G'</code>.</p> <p>Par contre, les cha\u00eenes <code>'CGCAT'</code> et <code>'GAC'</code>  ont un dernier caract\u00e8re diff\u00e9rent, on va donc chercher les plus longues chaines communes entre <code>'CGCAT'</code> et <code>'GA'</code> d'une part  et <code>'CGCAT'</code> et <code>'GA'</code> d'autre part. Notons que le sous probl\u00e8me de la plus longue cha\u00eene commune entre <code>'CGCA'</code> et <code>'GAC'</code> a d\u00e9j\u00e0 \u00e9t\u00e9 rencontr\u00e9. C'est le propre de la programmation dynamique, les sous-probl\u00e8mes se chevauchent, il ne faut pas les recalculer plusieurs fois !</p> <p> </p> <p>On continue ainsi jusqu'\u00e0 trouver des sous-chaines vide, il n'y a alors plus de sous-cha\u00eene commune \u00e0 chercher.</p> <p> </p> <p>On trouve ici deux chemins qui permettent d'aligner 3 caract\u00e8res entre les deux chaines : <code>'GAT'</code>et <code>'GCT'</code>.</p> <p>G\u00e9n\u00e9ralisons l'approche que l'on vient de faire sur l'exemple. Soit deux sous-chaines <code>str1</code> et <code>str2</code> et essayons de calculer  la plus longue sous-cha\u00eene commune entre les deux, que l'on note <code>T(str1, str2)</code>. Deux cas se pr\u00e9sentent :</p> <ul> <li> <p>Si l'une des deux sous-cha\u00eene est vide, alors il n'y a pas de plus longue sous-cha\u00eene commune : <code>T(str1, str2) = ''</code>.</p> </li> <li> <p>Si les deux sous-cha\u00eene ont un ou plusieurs caract\u00e8res, alors :</p> <ol> <li> <p>Si les deux sous-cha\u00eenes ont le m\u00eame dernier caract\u00e8re, <code>str1[-1] == str2[-1]</code>, alors ces caract\u00e8res pourront \u00eatre align\u00e9s, la plus longue cha\u00eene commune est la plus longue cha\u00eene commune entre les deux sous-cha\u00eenes r\u00e9duite de leur dernier caract\u00e8re, \u00e0 laquelle on ajoute ce caract\u00e8re commun : <code>T(str1, str2) = T(str1[:-1], str2 [:-1]) + str[-1]</code>. </p> </li> <li> <p>Si les derniers caract\u00e8res sont diff\u00e9rents, <code>str1[-1] != str2[-1]</code>, alors ces caract\u00e8res ne  pourront pas \u00eatre align\u00e9s, la plus longue cha\u00eene commune est la cha\u00eene qui a le plus de caract\u00e8res entre :</p> <ul> <li> <p>la plus longue cha\u00eene commune de la premi\u00e8re cha\u00eene et de la seconde r\u00e9duite de son dernier caract\u00e8re d'une part, et</p> </li> <li> <p>La plus longue cha\u00eene commune de la seconde cha\u00eene et de la premi\u00e8re r\u00e9duite de son dernier caract\u00e8re d'autre part,</p> </li> </ul> <p>Donc   <code>T(str1, str2) =  max_len(T(str1, str2[:-1]), T(str1[:-1], str2))</code>, o\u00f9 <code>max_len</code> renvoie la cha\u00eene la plus longue entre les deux.</p> </li> </ol> </li> </ul> <p>Cette relation de r\u00e9currence se traduit directement en Python en version dynamique descendante :</p> <pre><code>str1 = 'CGCATA'\nstr2 = 'GACT'\n\ndef max_len(str1, str2):\n    \"\"\" str, str -&gt; str\n    Renvoie la plus longue cha\u00eene des deux\n    ou la premiere si les deux chaines ont la m\u00eame longueur\n    \"\"\"\n    if len(str1) &gt;= len(str2):\n        return str1\n    else:\n        return str2\n\n\nmemo = {}\ndef alignement_sequence_top_down(str1, str2):\n    \"\"\" str, str -&gt; str\n    Renvoie une plus longue cha\u00eene commune\n    \"\"\"\n    if (str1, str2) in memo: return memo[(str1, str2)]\n    if str1 =='' or str2 == '': memo[(str1, str2)] = ''\n    elif str1[-1] == str2[-1]:\n        memo[(str1, str2)] = alignement_sequence_top_down(str1[:-1], str2[:-1]) + str1[-1]\n    else:\n        # on garde str1 et enl\u00e8ve le dernier car de str2\n        lsc1 = alignement_sequence_top_down(str1, str2[:-1])\n        # on garde str2 et enl\u00e8ve le dernier car de str1\n        lsc2 = alignement_sequence_top_down(str1[:-1], str2)\n        if len(lsc1) &gt;= len(lsc2):\n            memo[(str1, str2)] = lsc1\n        else:\n            memo[(str1, str2)] = lsc2\n    return memo[(str1, str2)]\n\n\nprint(alignement_sequence_top_down(str1, str2))\n</code></pre> <p>La version ascendante utilise la m\u00eame relation de r\u00e9currence mais de fa\u00e7on un peu plus complexe que les exemples pr\u00e9c\u00e9dents. L'id\u00e9e est de construire un tableau de tableaux <code>T</code> rempli des r\u00e9sultats des sous-probl\u00e8mes rencontr\u00e9s, c'est-\u00e0-dire des plus longues sous-cha\u00eenes communes entre les chaines <code>str1[ :i+1]</code> et <code>str[:j+1]</code> pour les valeurs de <code>i</code> allant et <code>j</code> allant de <code>0</code> \u00e0 <code>len(str1)</code> et <code>len(str2)</code> respectivement.</p> <p>On peut faire les constatations suivantes : </p> <ul> <li> <p>Pour <code>i = 0</code> on remplit la premi\u00e8re ligne pour les valeur de <code>j</code> avec <code>''</code> si <code>str1[0]</code>  n'est pas pr\u00e9sent dans  <code>str2[:j+1]</code> car il n'y a pas d'alignement possible ; ou sinon avec <code>str1[0]</code> s'il est pr\u00e9sent. </p> </li> <li> <p>Pour  <code>j = 0</code>, alors on remplit la premi\u00e8re colonne pour les valeur de <code>i</code> avec <code>''</code> si <code>str2[0]</code>  n'est pas pr\u00e9sent dans  <code>str1[:i+1]</code> car il n'y a pas d'alignement possible ; ou sinon  avec <code>str2[0]</code> s'il est pr\u00e9sent. </p> </li> <li> <p>Ensuite pour chaque valeur de <code>i</code> et <code>j</code> \u00e0 partir de <code>1</code>, deux cas de figure se pr\u00e9sentent :</p> <ul> <li> <p>Si les deux dernier caract\u00e8res de <code>str1[:i+1]</code> et <code>str2[:j+1]</code> sont identiques ,  c'est-\u00e0-dire <code>str1[i] == str2[j]</code>, alors ils peuvent \u00eatre align\u00e9s : <code>T[i][j] = T[i-1][j-1] + str[i]</code></p> </li> <li> <p>S'ils sont diff\u00e9rents, c'est-\u00e0-dire <code>str1[i] != str2[j]</code>, alors ils ne peuvent pas \u00eatre align\u00e9s, il faut prendre la plus longue sous-cha\u00eene entre les deux sous-cha\u00eenes calcul\u00e9es en enlevant l'un des dernier caract\u00e8re :  <code>T[i][j] = max_len(T[i][j-1], T[i-1][j])</code></p> </li> </ul> <p>La plus longue sous-cha\u00eene commune est calcul\u00e9e dans la derni\u00e8re ligne derni\u00e8re colonne du tableau de tableaux.</p> </li> </ul> <p> </p> <p>Traduite en Python, on obtient le code suivant :</p> <pre><code>def alignement_sequence_bottom_up(str1, str2):\n    \"\"\" str, str -&gt; str\n    Renvoie une plus longue cha\u00eene commune\n    \"\"\"\n    n1, n2 = len(str1), len(str2)\n    T = [['' for j in range(n2)] for i in range(n1)]\n    for i in range(n1):\n        if str2[0] in str1[:i+1]:\n            T[i][0] = str2[0]\n    for j in range(n2):\n        if str1[0] in str2[:j+1]:\n            T[0][j] = str1[0]\n\n    for i in range(1, n1):\n        for j in range(1, n2):\n            if str1[i] == str2[j]:\n                T[i][j] = T[i-1][j-1] + str1[i]\n            else:\n                T[i][j] = max_len(T[i][j-1], T[i-1][j])\n\n    return T[n1-1][n2-1]\n\nprint(alignement_sequence_bottom_up(str1, str2))\n</code></pre>"},{"location":"algorithmique/4-programmation-dynamique/#probleme-du-sac-a-dos","title":"Probl\u00e8me du sac \u00e0 dos","text":"<p>Probl\u00e8me : On dispose d'un sac \u00e0 dos avec une capacit\u00e9 maximum de poids \u00e0 transporter. Parmi plusieurs objets de poids et de valeurs diff\u00e9rents, lesquels peut-on mettre dans le sac \u00e0 dos de fa\u00e7on \u00e0 maximiser la somme des valeurs des objets choisis sans que leur poids total ne d\u00e9passe la capacit\u00e9 du sac. C'est un probl\u00e8me d'optimisation avec contrainte.</p> <p>Par exemple, on peut consid\u00e9rer les objets suivants et un sac \u00e0 dos avec une capacit\u00e9 maximum de 15 kg.</p> Poids (kg) 12 4 2 1 1 Prix (\u20ac) 40 100 20 20 10 <p>On peut choisir plusieurs combinaisons d'objets, par exemple les objets de poids 12 kg, 2 kg, 1 kg et 1 kg ont un poids total inf\u00e9rieur \u00e0 la capacit\u00e9 du sac de 15kg et une valeur totale de 90 \u20ac, ou encore les objets de poids 4 kg, 2 kg, 1 kg et 1 kg pour une valeur totale de 150 \u20ac. Mais comment trouver la combinaison optimale dans toutes les situations ?</p> <p> </p> <p>Repr\u00e9sentons les objets dans une liste de p-uplets nomm\u00e9s :</p> <pre><code>objets = [{'poids': 12, 'valeur': 40},\n           {'poids': 4, 'valeur': 100},\n           {'poids': 2, 'valeur': 20},\n           {'poids': 1, 'valeur': 20},\n           {'poids': 1, 'valeur': 10}]\n</code></pre>"},{"location":"algorithmique/4-programmation-dynamique/#algorithme-glouton_1","title":"Algorithme glouton","text":"<p>L'algorithme glouton le plus simple consiste \u00e0 prendre les objets en ordre de valeur d\u00e9croissante tant que leur poids ne fait pas d\u00e9passer la capacit\u00e9 du sac. On peut \u00e9crire le code suivant :</p> <p>L'utilisation de la fonction <code>sorted()</code> permet de ne pas modifier la liste <code>objets</code>.</p> <pre><code>def sac_glouton(poids_max):\n    \"\"\" int -&gt; int\n    Renvoie la valeur maximale d'une liste d'objets [{'poids', 'valeur'}]\n    qui peuvent \u00eatre mis dans le sac sans que leur poids d\u00e9passe poids_max\n    \"\"\"\n\n    poids_sac = 0\n    valeur_sac = 0\n    # objets pris en ordre de valeur d\u00e9croissante\n    for objet in sorted(objets, key=lambda x: x['valeur'], reverse=True):\n        # si le poids de objet ne fait pas d\u00e9passer la capacit\u00e9 du sac\n        if objet['poids'] + poids_sac &lt;= poids_max:\n            # on le met dans le sac\n            poids_sac += objet['poids']\n            valeur_sac += objet['valeur']\n    return valeur_sac\n\nassert sac_glouton(15) == 150\n</code></pre> <p>L'algorithme glouton renvoie <code>150</code> pour l'exemple pr\u00e9c\u00e9dent, c'est bien la valeur maximale que l'on peut mettre dans le sac :</p> <p> </p> <p> </p> <p>Mais en favorisant les objets ayant la plus grande valeur, l'algorithme ne prend pas en compte leur poids ce qui conduit \u00e0 une solution qui n'est pas optimale dans tous cas. </p> <p>Regardons ce qu'il se passe avec la liste d'objets suivante :</p> <pre><code>objets = [{'poids': 12, 'valeur': 40},\n          {'poids': 15, 'valeur': 100},\n          {'poids': 1, 'valeur': 90}]\n</code></pre> <p>L'algorithme choisit d'abord l'objet de 15 kg, il n'est plus possible d'en ajouter d'autres, ni de revenir en arri\u00e8re pour enlever l'objet. C'est le principe des algorithmes gloutons, on ne revient pas en arri\u00e8re sur une d\u00e9cision qui a \u00e9t\u00e9 prise. L'algorithme renvoie donc <code>100</code>, ce n'est pas optimal, les objets de 1 kg et 12 kg avaient une valeur totale de 130 \u20ac.</p> <p>Une approche plus fine consiste \u00e0 prendre en priorit\u00e9 les objets ayant le meilleur ratio valeur/poids. Modifions la boucle <code>for</code> dans le programme pour trier les objets par ce ratio :</p> <pre><code>    # objets pris en l'ordre de ratio valeur/poids d\u00e9croissant\n    for objet in sorted(objets, key=lambda x: x['valeur']/x['poids'], reverse=True):\n</code></pre> <p>Ce nouvel algorithme glouton renvoie aussi la valeur attendue <code>150</code> pour le premier exemple, c'est \u00e0 nouveau la valeur maximale : </p> <p> </p> <p>Essayons maintenant cette nouvelle liste d'objets :</p> <p> </p> <pre><code>objets = [{'poids': 12, 'valeur': 70},\n          {'poids': 9, 'valeur': 100},\n          {'poids': 5, 'valeur': 20},\n          {'poids': 2, 'valeur': 10}]\n</code></pre> <p>Les objets tri\u00e9s par ratio valeur/poids d\u00e9croissants sont 9 kg, 12 kg, 2 kg puis 5 kg. L'algorithme glouton commence par mettre l'objet de 9 kg dans le sac et ensuite celui de 2 kg, il renvoie donc la valeur <code>110</code>.  La solution n'est encore pas optimale, le premier algorithme glouton par valeur d\u00e9croissante renvoyait <code>120</code> ! </p>"},{"location":"algorithmique/4-programmation-dynamique/#programmation-dynamique_2","title":"Programmation dynamique","text":"<p>Une fois de plus la programmation dynamique offre une solution optimale au probl\u00e8me.</p> <p>Reprenons l'exemple d'un sac de capacit\u00e9 15 kg avec les objets du premier exemple et calculons la valeur maximale des objets qui peuvent \u00eatre mis dans ce sac. On la note <code>V[15]</code>.</p> <p></p> <p>Au d\u00e9but le sac est vide. On se pose la question de mettre un premier objet dans le sac, par exemple l'objet de 1 kg avec une valeur de 10 \u20ac. Deux cas se pr\u00e9sentent :</p> <ol> <li>Cas 1 : On met l'objet d'1 kg dans le sac, il restera \u00e0 calculer la valeur maximale d'un sac de 14 kg, <code>V[14]</code>, puis de lui ajouter la valeur de 10 \u20ac de cet objet.</li> <li>Cas 2 : On ne met pas l'objet dans le sac, il restera \u00e0 calculer la valeur maximale  d'un sac de 15 kg, <code>V[15]</code>, sans lui ajouter aucune valeur ensuite.</li> </ol> <p>Si on peut trouver la solution de ces deux sous-probl\u00e8mes, il suffira ensuite de prendre la plus grande valeur entre les deux. On remarque que pour calculer <code>V[15]</code>, le deuxi\u00e8me cas consiste \u00e0 calculer <code>V[15]</code>, c'est circulaire ! Alors quelle est la diff\u00e9rence ? </p> <p>La diff\u00e9rence r\u00e9side dans la liste d'objets disponibles. Au d\u00e9but, tous les objets sont disponibles pour \u00eatre mis, ou pas, dans la sac \u00e0 dos. Ensuite l'objet pesant 1 kg de valeur 10 \u20ac n'est plus disponible, soit il a \u00e9t\u00e9 mis dans le sac (cas 1), soit il a \u00e9t\u00e9 \u00e9cart\u00e9 (cas 2) et on ne le consid\u00e8re plus pour \u00eatre mis dans le sac.</p> <p> </p> <p>On en d\u00e9duit que le calcul de la valeur maximale d'un sac de capacit\u00e9 \\(p\\) ne d\u00e9pend pas que de la valeur de \\(p\\), mais aussi de la liste d'objets disponibles. On identifie les objets par leur indice \\(i\\) dans la liste, et on notera \\(V_{i,p}\\) la valeur maximale d'un sac de capacit\u00e9 \\(p\\) en choisissant parmi les objets d'indices \\(0\\), \\(1\\), \\(2\\), \u2026, \\(i-1\\), \\(i\\).</p> <p>G\u00e9n\u00e9ralisons cette approche. Soit un sac de capacit\u00e9 p et une liste d'objet  d'indices \\(0\\), \\(1\\), \\(2\\), \u2026, \\(i-1\\), \\(i\\), et essayons de calculer \\(V_{i,p}\\). On se pose la question de mettre le dernier objet de la liste, de poids \\(poids_{i}\\)  et de valeur \\(valeur_{i}\\) dans le sac, ou pas. Plusieurs cas se pr\u00e9sentent :</p> <ul> <li> <p>Si \\(poids_{i} &gt; p\\), alors l'objet est trop lourd pour le sac, il est \u00e9cart\u00e9. On calculera la valeur maximale pour la m\u00eame capacit\u00e9 de sac \\(p\\), mais avec une liste d'objet qui s'arr\u00eate \u00e0 \\(i-1\\) : \\(V_{i, p}= V_{i-1, p}\\).</p> </li> <li> <p>Si \\(poids_{i} \\leq p\\), alors l'objet \\(i\\) peut rentrer dans le sac. On retombe sur les deux cas de l'exemple pr\u00e9c\u00e9dant :</p> <ol> <li> <p>Cas 1 : On met l'objet \\(i\\) dans le sac, il reste \u00e0 calculer la valeur maximale d'un sac de capacit\u00e9 \\(p - poids_{i}\\) avec les objets restants, \\(V_{i-1,p - poids_i}\\),  puis de lui ajouter la valeur de l'objet \\(valeur_{i}\\).</p> </li> <li> <p>Cas 2 : On ne met pas l'objet \\(i\\) dans le sac, il reste \u00e0 calculer la valeur maximale d'un sac de capacit\u00e9 \\(p\\) avec les objets restants, sans lui ajouter aucune valeur ensuite : \\(V_{i-1, p}\\).</p> </li> <li> <p>\\(V_{i, p}\\) est le cas le plus favorable entre les deux : \\(V_{i, p} = \\max(valeur_{i} + V_{i-1, p - poids_{i}}, V_{i-1, p})\\)</p> </li> </ol> </li> </ul> <p>Bien s\u00fbr, une fois qu'on a consid\u00e9r\u00e9 tous les objets de la liste les uns apr\u00e8s les autres pour les mettre dans le sac, ou pas, et qu'il ne reste plus que le premier objet de la liste, la solution est imm\u00e9diate car il suffit de v\u00e9rifier si son poids est inf\u00e9rieur \u00e0 la capacit\u00e9 du sac ou pas. Si c'est le cas, on met l'objet dans le sac et la valeur maximale du sac est donc la valeur de l'objet. Sinon, on ne peut pas prendre l'objet, la valeur maximale est 0. </p> <p> </p> <p>Cette relation de r\u00e9currence se traduit directement en Python en version dynamique descendante (noter l'ordre des param\u00e8tres invers\u00e9, <code>i</code> est apr\u00e8s <code>p_max</code> car les param\u00e8tres par mots cl\u00e9s sont toujours plac\u00e9s apr\u00e8s les positionnels) :</p> <pre><code>objets = [{'poids': 12, 'valeur': 40},\n           {'poids': 4, 'valeur': 100},\n           {'poids': 2, 'valeur': 20},\n           {'poids': 1, 'valeur': 20},\n           {'poids': 1, 'valeur': 10}]\n\nV = {}   # dictionnaire {(capacit\u00e9 du sac, objets jusqu'\u00e0 i): valeur maximale} de memoisation\n\ndef sac_dynamique_top_down(poids_max, i=len(objets)-1):\n    \"\"\" int, int -&gt; int\n    Renvoie la valeur maximale d'une liste d'objets [{'poids', 'valeur'}]\n    qui peuvent \u00eatre mis dans le sac sans que leur poids d\u00e9passe poids_max\n    Note : on ne consid\u00e8re que premiers objets de la liste jusqu'\u00e0 l'indice i (inclus)\n    \"\"\"\n    # s'il ne reste plus qu' objets[0] \u00e0 consid\u00e9rer dans la liste \n    if i == 0:\n        # s'il est moins lourd que la capacit\u00e9 du sac, on le met dans le sac\n        if objets[i]['poids'] &lt;= poids_max:\n            val_max = objets[i]['valeur']\n        # sinon il est trop lourd pour le sac\n        else:\n              val_max = 0\n\n    # s'il reste plusieurs objets, on consid\u00e8re objets[i]\n    # soit il est plus lourd que la capacit\u00e9 du sac, on ne le met pas dans le sac\n    elif objets[i]['poids'] &gt; poids_max:\n        val_max = sac_a_dos_dynamique(poids_max, i-1)\n    else:   # soit il est moins lourd  et\n        # on garde la plus grande valeur entre ne pas prendre objets[i] \n        val_max = max(sac_dynamique_top_down(poids_max, i-1),\n        # et ajouter objets[i] dans le sac\n     objets[i]['valeur'] + sac_dynamique_top_down(poids_max - objets[i]['poids'], i-1))\n\n    # on met \u00e0 jour le dictionnaire et on renvoie la valeur maximale pour poids_max\n    V[(poids_max, i)] = val_max\n    return val_max\n\n\nassert sac_dynamique_top_down(15) == 150\n</code></pre> <p>La version ascendante consiste \u00e0 construire un tableau de tableaux <code>V</code> dont les \u00e9l\u00e9ments <code>V[i][p]</code> sont les valeurs maximales du probl\u00e8me pour un sac de capacit\u00e9 <code>p</code> en ne consid\u00e9rant que les premiers objets de la liste jusqu'\u00e0 l'objet <code>objets[i]</code> inclus . </p> <p>La premi\u00e8re ligne du tableau, quand <code>i</code> est \u00e9gal \u00e0 <code>0</code>, donne la valeur du sac en ne consid\u00e9rant que le premier objet de la liste, <code>objet[0]</code>. Deux cas se pr\u00e9sentent :</p> <ul> <li> <p>si <code>objet[0]</code> est plus lourd que la capacit\u00e9 du sac (<code>objet[0][poids] &gt; p</code>), alors on ne peut pas le mettre dans le sac et la valeur maximale du sac est 0.</p> </li> <li> <p>si <code>objet[0]</code> est moins lourd que la capacit\u00e9 du sac (<code>objet[0][poids] &lt;= p</code>), alors on le met dans le sac et la valeur maximale du sac est la valeur de l'objet : <code>objet[0][valeur]</code>.</p> </li> </ul> <p>Les autres valeurs de <code>V[i][p]</code> sur les autres lignes sont calcul\u00e9es \u00e0 partir de la relation de r\u00e9currence pr\u00e9c\u00e9dente. La solution du probl\u00e8me se trouve sur la derni\u00e8re ligne et la derni\u00e8re colonne de <code>V</code>:</p> <p> </p> <pre><code>def sac_dynamique_bottom_up(poids_max):\n    \"\"\" int -&gt; int\n    Renvoie la valeur maximale d'une liste d'objets [{'poids', 'valeur'}]\n    qui peuvent \u00eatre mis dans le sac sans que leur poids d\u00e9passe poids_max\n    \"\"\"\n\n    # on cr\u00e9e le tableau de tableau, une ligne par objet ajout\u00e9 (ou pas)\n    # une colonne pour chaque capacit\u00e9 de sac\n    V = [[None]*(poids_max + 1) for i in range(len(objets))]\n\n\n    # V[i][p] est la valeur max d'un sac de capacit\u00e9 p\n    # avec les premiers objets jusqu'\u00e0 objets[i] inclus\n\n    # s'il n'y a qu' objets[0] \u00e0 consid\u00e9rer dans la liste\n    for p in range(poids_max + 1):\n        # s'il est moins lourd que la capacit\u00e9 du sac, on le met dans le sac\n        if objets[0]['poids'] &lt;= p:\n            V[0][p] = objets[0]['valeur']\n        # sinon il est trop lourd pour le sac\n        else:\n            V[0][p] = 0\n\n\n    # s'il reste plusieurs objets, on regarde l'objet d'indice i\n    for i in range(1, len(objets)):\n\n    # on remplit les lignes suivantes\n        for p in range(poids_max + 1):\n            # soit il est plus lourd que la capacit\u00e9 du sac\n            if p &lt; objets[i]['poids']:\n                # on ne le met pas dans le sac\n                V[i][p] = V[i-1][p]\n            # soit il est moins lourd\n            else:\n                # on prend la plus grande valeur entre ne pas prendre objets[i]\n                V[i][p] = max(V[i-1][p],\n                    # et ajouter objets[i] au sac\n                    V[i-1][p - objets[i]['poids']] + objets[i]['valeur'])\n    return V[len(objets)-1][poids_max]\n\nassert sac_dynamique_bottom_up(15) == 150\n</code></pre> <ol> <li> <p>Cette m\u00e9thode a \u00e9t\u00e9 introduite au d\u00e9but des ann\u00e9es 1950 par Richard Bellman.  Le terme \"programmation\" dans \"programmation dynamique\", ne doit pas s'entendre comme \"utilisation d'un langage de programmation\", mais comme synonyme de planification et ordonnancement.\u00a0\u21a9</p> </li> <li> <p>\\(nb_i\\) est donn\u00e9 par la formule de r\u00e9currence \\(nb_i = \\underset{p \\leq i}{\\min}\u2061 (1+ nb_{i-p})\\).\u00a0\u21a9</p> </li> </ol>"},{"location":"algorithmique/5-recherche-textuelle/","title":"Recherche textuelle","text":"<p>Chercher un mot dans une cha\u00eene de caract\u00e8res est un besoin tr\u00e8s fr\u00e9quent, par exemple quand on utilise <code>CTRL+F</code>  dans un fichier ou sur une page web.  En Python, la recherche textuelle est nativement pr\u00e9sente avec les instructions <code>motif in chaine</code> ou <code>chaine.index(motif)</code> et <code>chaine.find(motif)</code>. En Linux, la commande <code>grep motif nom_fichier</code>permet de rechercher une cha\u00eene de caract\u00e8re <code>motif</code>dans le fichier <code>nom_fichier</code>.</p> <p>Cours</p> <p>La recherche  textuelle consiste \u00e0 trouver les occurrences d'une sous-cha\u00eene, appel\u00e9e motif ou cl\u00e9, dans une cha\u00eene de caract\u00e8res. </p> <p>Il existe de nombreux algorithmes de recherche textuelle, on \u00e9tudie dans ce chapitre l'algorithme de Boyer-Moore et sa version simplifi\u00e9e de Horpsool sur un exemple de bio-informatique : chercher la s\u00e9quence <code>TCACTC</code> (le motif) dans un brin d'ADN <code>CTTCCGCTCGTATTCGTCTCACTCG</code> (la cha\u00eene).</p>"},{"location":"algorithmique/5-recherche-textuelle/#recherche-naive-par-force-brute","title":"Recherche na\u00efve par \u00ab force brute \u00bb","text":"<p>Il s'agit de faire \u00ab glisser \u00bb caract\u00e8re apr\u00e8s caract\u00e8re le motif de gauche \u00e0 droite pour parcourir toute la cha\u00eene, et de v\u00e9rifier pour chaque caract\u00e8re du motif s'il correspond \u00e0 celui de la cha\u00eene. Ce traitement est long, mais on est certain d'obtenir le bon r\u00e9sultat.</p> <p>Commen\u00e7ons par aligner le motif \u00e0 gauche de la cha\u00eene et par comparer le premier caract\u00e8re du motif \u00e0 celui de la cha\u00eene :</p> <p></p> <p>Le <code>T</code> du motif ne correspond pas au <code>C</code> de la cha\u00eene. On d\u00e9cale le motif d'un caract\u00e8re vers la droite et on essaie \u00e0 nouveau :</p> <p></p> <p>Cette fois le <code>T</code> du motif correspond \u00e0 celui de la cha\u00eene. On passe au caract\u00e8re suivant \u00e0 droite : le <code>C</code> du motif ne correspond pas au <code>T</code>. On d\u00e9cale le motif d'un caract\u00e8re vers la droite :</p> <p></p> <p>Le <code>T</code> puis le <code>C</code> du motif correspondent aux caract\u00e8res de la cha\u00eene, mais le <code>A</code> ne correspond pas au <code>C</code>. On d\u00e9cale le motif d'un caract\u00e8re vers la droite :</p> <p></p> <p>Le <code>T</code> du motif ne  correspond pas au <code>C</code> de la cha\u00eene. On d\u00e9cale le motif d'un caract\u00e8re vers la droite :</p> <p>L'op\u00e9ration se r\u00e9p\u00e8te jusqu'\u00e0 trouver tous les caract\u00e8res du motif qui correspondent \u00e0 ceux de la cha\u00eene. </p> <p></p> <p>Le recherche na\u00efve est tr\u00e8s longue car il faut parcourir toute la cha\u00eene, caract\u00e8re par caract\u00e8re, et \u00e0 chaque fois comparer un ou plusieurs caract\u00e8res du motif avec ceux de la cha\u00eene jusqu'\u00e0 en trouver un qui ne co\u00efncide pas.  Dans le pire des cas, le motif et la cha\u00eene contiennent tous les deux une seule et m\u00eame lettre, le co\u00fbt est donc en \\(O(n \\times m)\\), o\u00f9 \\(n\\) est la longueur de la cha\u00eene et \\(m\\) celle du motif. Et dans le meilleur des cas, le premier caract\u00e8re du motif n'est pas pr\u00e9sent dans la cha\u00eene, le co\u00fbt est en \\(O(n)\\).</p> <p>Cours</p> <p>L'algorithme de recherche na\u00efve, ou par \u00ab force brute \u00bb, consiste \u00e0 comparer les caract\u00e8res du motif avec ceux de la cha\u00eene un par un de gauche \u00e0 droite jusqu'\u00e0 trouver une diff\u00e9rence. Quand une diff\u00e9rence est trouv\u00e9e, on fait \u00ab glisser \u00bb le motif d'un caract\u00e8re vers la droite et on recommence.</p> <p>Traduit en Python, on obtient le programme suivant :</p> <pre><code>def naive(motif, chaine):\n    \"\"\" str, str -&gt; list\n    Renvoie la liste des positions trouv\u00e9es du motif dans la cha\u00eene\n    \"\"\"\n    positions = []\n    n = len(chaine)\n    m = len(motif)\n    i = 0    # position du d\u00e9but du motif dans la chaine\n    while i &lt;= n - m :\n        j = 0       # position du caract\u00e8re dans le motif\n        while j &lt;= m - 1 and chaine[i + j] == motif[j]:\n            j = j + 1\n        if j == m:       # on a trouv\u00e9 le motif\n            positions.append(i)\n        i = i + 1   # on d\u00e9cale d'un caract\u00e8re vers la droite\n    return positions\n\n\nchaine = 'CTTCCGCTCGTATTCGTCTCACTCG'\nmotif = 'TCACTC'\n\nassert naive(motif, chaine) == [18]\nassert naive('AAA', 'AAAAA') == [0, 1, 2]\nassert naive('AT', 'ATATAT') == [0, 2, 4]\nassert naive('AZ', chaine) == []\n</code></pre> <p> </p> <p>Attention \u00e0 prendre soin de terminer la boucle sur le dernier caract\u00e8re quand <code>i</code> vaut <code>n \u2013 m</code> inclus.</p> <p>On constate que si l'algorithme fonctionne tr\u00e8s bien, il est co\u00fbteux en temps machine et peut donc \u00eatre optimis\u00e9. </p>"},{"location":"algorithmique/5-recherche-textuelle/#recherche-naive-a-rebours","title":"Recherche na\u00efve \u00e0 rebours","text":"<p>Une premi\u00e8re modification consiste \u00e0 inverser l'ordre dans lequel on compare les caract\u00e8res du motif \u00e0 ceux de la chaine : on part du dernier caract\u00e8re du motif et s'il correspond \u00e0 celui de la cha\u00eene on passe au caract\u00e8re pr\u00e9c\u00e9dent jusqu'\u00e0 trouver une discordance ou avoir parcouru l'ensemble du motif (on a alors trouv\u00e9 le motif).</p> <p></p> <p>Le <code>C</code> du motif  ne correspond pas au <code>G</code> de la chaine, on d\u00e9cale le motif d'un caract\u00e8re vers la droite et on essaie \u00e0 nouveau :</p> <p></p> <p>Le <code>C</code> du motif correspond \u00e0 celui de la cha\u00eene, mais le <code>T</code> ne correspond pas au <code>G</code>, on d\u00e9cale le motif d'un caract\u00e8re vers la droite :</p> <p></p> <p>Le <code>C</code> du motif ne correspond pas au <code>T</code>, on d\u00e9cale le motif d'un caract\u00e8re vers la droite :</p> <p></p> <p>Le dernier <code>C</code>, puis le <code>T</code>  et encore le <code>C</code> correspondent aux caract\u00e8res de la cha\u00eene, mais pas le <code>A</code>, on d\u00e9cale le motif d'un caract\u00e8re vers la droite :</p> <p>Et ainsi de suite...</p> <p>Il suffit de modifier le code de la fonction Python pour parcourir les caract\u00e8res du motif de droite \u00e0 gauche, c'est-\u00e0-dire pour que <code>j</code> aille de <code>n - 1</code> jusqu'\u00e0 <code>0</code> en d\u00e9croissant :</p> <pre><code>    while i &lt;= n - m:\n        j = m -  1       # position du caract\u00e8re dans le motif\n        while j &gt;= 0 and chaine[i + j] == motif[j]:\n            j = j - 1\n        if j == -1:       # on a trouv\u00e9 le motif\n            positions.append(i)\n        i = i + 1   # on d\u00e9cale d'un caract\u00e8re vers la droite\n    return positions\n</code></pre> <p>La modification n'a pas chang\u00e9 le co\u00fbt de l'algorithme. Mais alors quel est l'int\u00e9r\u00eat ?</p>"},{"location":"algorithmique/5-recherche-textuelle/#lalgorithme-de-horspool","title":"L'algorithme de Horspool","text":"<p>Horspool<sup>1</sup> propose une version simplifi\u00e9e de l'algorithme de Boyer-Moore.</p> <p>Dans la recherche na\u00efve \u00e0 rebours, lorsque que le dernier caract\u00e8re ne correspond pas au caract\u00e8re de la cha\u00eene, on d\u00e9cale le motif d'un caract\u00e8re vers la droite. Mais on peut faire beaucoup mieux en regardant si ce caract\u00e8re de la cha\u00eene est pr\u00e9sent, ou pas, autre part dans le motif :</p> <p></p> <p>Le <code>C</code> du motif ne correspond pas au <code>G</code> de la cha\u00eene. Plut\u00f4t que de d\u00e9caler le motif d'un seul caract\u00e8re vers la droite, on voit qu'il n'y a aucun <code>G</code> dans tout le motif. Il est inutile de comparer le motif apr\u00e8s l'avoir d\u00e9cal\u00e9 d'un seul caract\u00e8re vers la droite, il y aura toujours une diff\u00e9rence avec ce <code>G</code> dans la cha\u00eene.</p> <p>On d\u00e9cale donc le motif vers la droite en  \u00ab sautant \u00bb de toute la longueur du motif ce qui permet de gagner beaucoup de temps :</p> <p></p> <p>Le <code>C</code> du motif ne correspond pas au <code>A</code> de la cha\u00eene. Mais il y a un <code>A</code> autre part dans la motif qui pourrait correspondre.  Il est plac\u00e9 3 caract\u00e8res avant le dernier caract\u00e8re du motif. Alignons ce <code>A</code> du motif sur le <code>A</code> de la cha\u00eene. On d\u00e9cale le motif en \u00ab sautant \u00bb de 3 caract\u00e8res vers la droite :</p> <p></p> <p>Le dernier <code>C</code> puis le <code>T</code> du motif correspondent aux caract\u00e8res de la cha\u00eene, mais pas le <code>C</code> plac\u00e9 avant. Le caract\u00e8re de la cha\u00eene qui est align\u00e9 sur le dernier caract\u00e8re du motif est un <code>C</code>, or il y a d'autres <code>C</code> dans le motif qui pourraient correspondre : un plac\u00e9 5 caract\u00e8res avant le dernier caract\u00e8re du motif et un autre 2 caract\u00e8res avant.</p> <p>On ne peut pas aligner le premier <code>C</code>, celui plac\u00e9 5 caract\u00e8res avant le dernier caract\u00e8re du motif, car on irait trop loin sans avoir l'occasion d'essayer le deuxi\u00e8me <code>C</code>. Alignons plut\u00f4t ce deuxi\u00e8me <code>C</code>, celui plac\u00e9 2 caract\u00e8res avant le dernier caract\u00e8re du motif, sur celui de la cha\u00eene. On d\u00e9cale le motif en \u00ab sautant \u00bb de 2 caract\u00e8res vers la droite : </p> <p></p> <p>Le <code>C</code> du motif ne correspond pas au <code>T</code> de la cha\u00eene. Or il y a d'autres <code>T</code> dans le motif qui pourraient correspondre : un plac\u00e9 6 caract\u00e8res avant le dernier caract\u00e8re du motif et un autre 1 caract\u00e8re avant. Comme \u00e0 l'\u00e9tape pr\u00e9c\u00e9dente, on choisit le deuxi\u00e8me <code>T</code> du motif pour l'aligner sur celui de la cha\u00eene. On d\u00e9cale le motif en \u00ab sautant \u00bb de 1 caract\u00e8re vers la droite :</p> <p></p> <p>Le <code>C</code> et le <code>T</code> du motif correspondent aux caract\u00e8res de la cha\u00eene, mais ensuite le  <code>C</code> ne correspond pas au <code>G</code> de la cha\u00eene. On d\u00e9cale le motif en \u00ab sautant \u00bb de 2 caract\u00e8res vers la droite pour aligner les <code>C</code> :</p> <p></p> <p>Le <code>C</code>, le <code>T</code> et le <code>C</code> du motif correspondent aux caract\u00e8res de la cha\u00eene, mais pas le <code>A</code> au <code>T</code> de la cha\u00eene. On d\u00e9cale le motif en \u00ab sautant \u00bb de 2 caract\u00e8res vers la droite pour aligner les <code>C</code> :</p> <p></p> <p>Le <code>C</code> du motif correspond \u00e0 la cha\u00eene, mais pas le <code>T</code> avec le <code>A</code> de la cha\u00eene. On d\u00e9cale encore le motif en \u00ab sautant \u00bb de 2 caract\u00e8res vers la droite pour aligner les <code>C</code> :</p> <p></p> <p>Tous les caract\u00e8res du motif correspondent \u00e0 ceux de la cha\u00eene. On a trouv\u00e9 le motif en 8 \u00e9tapes, au lieu de 18 avec l'algorithme na\u00eff !</p> <p>On voit que les sauts sont d\u00e9termin\u00e9s par le caract\u00e8re de la chaine qui est align\u00e9 sur le dernier caract\u00e8re du motif, appelons le \u00ab caract\u00e8re de droite \u00bb . Ce saut est toujours le m\u00eame pour un m\u00eame caract\u00e8re, quelle que soit la position o\u00f9 la diff\u00e9rence est trouv\u00e9e. Ici, dans notre exemple :</p> <ul> <li>Quand le caract\u00e8re de droite est un <code>A</code>, on fait toujours un saut de 3 caract\u00e8res.</li> </ul> <p></p> <ul> <li>Quand le caract\u00e8re de droite est un <code>C</code>, on fait toujours un saut de 2 caract\u00e8res quel que soit l'endroit o\u00f9 l'on trouve une diff\u00e9rence avec la cha\u00eene.</li> </ul> <p></p> <p>On voit aussi que si le caract\u00e8re de droite appara\u00eet plusieurs fois dans le motif, on ne consid\u00e8re que celui qui est le plus \u00e0 droite du motif.  Par exemple, ici <code>T</code> appara\u00eet plusieurs fois dans le motif, on calcule son saut en consid\u00e9rant celui qui est le plus \u00e0 droite du motif, c'est-\u00e0-dire un saut de 1 caract\u00e8re.</p> <p></p> <p>Enfin, on voit que le dernier caract\u00e8re du motif n'est pas pris en compte pour calculer les sauts (puisqu'il aurait un saut de 0). Par exemple, ici le dernier <code>C</code> n'est pas pris en compte pour calculer le saut correspondant au caract\u00e8re <code>C</code>, on utilise celui qui est 2 caract\u00e8res avant le dernier caract\u00e8re du motif.</p> <p></p> <p>Plut\u00f4t que de recalculer ces sauts \u00e0 chaque fois qu'une diff\u00e9rence est trouv\u00e9e, on peut donc faire un pr\u00e9traitement de l'algorithme de Horspool en calculant au d\u00e9but une seule fois le saut de chaque lettre du motif. </p> <p>Dans notre exemple, la table des sauts pour le motif  <code>'TCACTC'</code> est donc la suivante :</p> A C T autres 3 2 1 6 <p>Un dictionnaire Python permet d'enregistrer simplement les valeurs des sauts calcul\u00e9s pendant le pr\u00e9traitement : <code>{'A': 3, 'C': 2, 'T': 1}</code>. Les autres caract\u00e8res qui n'apparaissent pas dans le dictionnaire auront un saut \u00e9gal \u00e0 la longueur du motif.</p> <p>Cours</p> <p>L'algorithme de Horspool consiste \u00e0 comparer les caract\u00e8res du motif avec ceux de la cha\u00eene un par un en remontant de droite \u00e0 gauche jusqu'\u00e0 trouver une diff\u00e9rence.</p> <p>Quand une diff\u00e9rence est trouv\u00e9e, on regarde le caract\u00e8re de la cha\u00eene align\u00e9 sur le dernier caract\u00e8re du motif. </p> <ul> <li> <p>Si ce caract\u00e8re est pr\u00e9sent dans le motif, on d\u00e9cale le motif d'un saut pour aligner ce caract\u00e8re de la cha\u00eene avec sa derni\u00e8re occurrence dans le motif.</p> </li> <li> <p>Si ce caract\u00e8re n'est pas pr\u00e9sent dans le motif, on d\u00e9cale le motif d'un saut de la longueur du motif pour passer au del\u00e0 de ce caract\u00e8re.</p> </li> </ul> <p>Pr\u00e9traitement des sauts :  Pour chaque lettre du motif (sauf la derni\u00e8re), le saut \u00e0 effectuer est \u00e9gal \u00e0 l'\u00e9cart entre la derni\u00e8re occurrence de cette lettre dans le motif et la fin du motif. On ne calcule pas de saut pour le dernier caract\u00e8re.</p> <p>Ecrivons le pr\u00e9traitement en Python :</p> <pre><code>def table_sauts(motif):\n    d = {}\n    m = len(motif)\n    for i in range(m - 1):  # on exclut la derniere lettre du motif\n        d[motif[i]] = m - i - 1\n    return d\n</code></pre> <p>et le reste de l'algorithme de Horspool :</p> <pre><code>def horspool(motif, chaine):\n    positions = []\n    n = len(chaine)\n    m = len(motif)\n    sauts = table_sauts(motif) # on construit le dictionnaire \u00ab table de saut \u00bb\n    print(chaine)\n    i = 0\n    while i &lt;= n - m:\n        print(' ' * i + motif)     # affiche le motif align\u00e9 avec la chaine\n        j = m -  1       # position du caract\u00e8re dans le motif\n        car_droite = chaine[j]    # caract\u00e8re de droite\n        while j &gt;= 0 and chaine[i + j] == motif[j]:\n            j = j - 1\n        # si on a trouv\u00e9 le motif\n        if j == -1:\n            positions.append(i)\n            i = i + sauts[car_droite] \n        # sinon si le caract\u00e8re de droite est dans la table des sauts\n        elif car_droite in sauts:\n            i = i + sauts[car_droite]   # on saute de la table de sauts\n        # sinon\n        else:      # le caract\u00e8re de droite n'est pas dans le motif\n            i = i + m    # on saute tout le motif\n    return positions\n</code></pre> <p>L'algorithme de Horspool n'am\u00e9liore pas le pire des cas de la recherche na\u00efve, si le motif et la chaine contiennent tous les deux une seule et m\u00eame lettre, le co\u00fbt est toujours en \\(O(n \\times m)\\), o\u00f9 \\(n\\) est la longueur de la chaine et \\(m\\) celle du motif. Par contre dans le meilleur des cas, si le dernier caract\u00e8re du motif n'est pas pr\u00e9sent dans la chaine, les sauts permettent d'am\u00e9liorer fortement le co\u00fbt en \\(O(n/m)\\).</p>"},{"location":"algorithmique/5-recherche-textuelle/#lalgorithme-de-boyer-moore","title":"L'algorithme de Boyer-Moore","text":"<p>On pr\u00e9sente ici une version de l'algorithme de Boyer-Moore que l'on trouve sur la page https://en.wikipedia.org/wiki/Boyer\u2013Moore_string-search_algorithm et dans certains livres de NSI<sup>2</sup> , il en existe d'autres l\u00e9g\u00e8rement diff\u00e9rentes.</p>"},{"location":"algorithmique/5-recherche-textuelle/#la-regle-du-mauvais-caractere-bad-character-rule","title":"La r\u00e8gle du mauvais caract\u00e8re (bad-character rule)","text":"<p>On peut adapter l'id\u00e9e d'un saut calcul\u00e9 sur le caract\u00e8re de droite en utilisant \u00e0 la place le premier mauvais caract\u00e8re.</p> <p></p> <p>Comme avec Horspool, quand on trouve dans la chaine un caract\u00e8re qui n'est pas pr\u00e9sent dans le motif, on peut \u00ab sauter \u00bb  derri\u00e8re celui-ci. Le <code>C</code> du motif ne correspond pas au <code>G</code> de la chaine. Il n'y a aucun <code>G</code> dans le motif, on d\u00e9cale  le motif vers la droite en \u00ab sautant \u00bb de toute la longueur du motif :</p> <p></p> <p>Le <code>C</code> du motif ne correspond pas au <code>A</code> de la chaine, mais il y a un <code>A</code> dans la cha\u00eene 3 caract\u00e8res \u00e0 droite du dernier caract\u00e8re du motif. On peut aligner ce dernier <code>A</code> du motif en \u00ab sautant \u00bb de 3 caract\u00e8res (m\u00eame chose qu'avec Horspool) :</p> <p></p> <p>Le <code>C</code> et le <code>T</code> du motif correspondent aux caract\u00e8res de la chaine, mais pas le <code>C</code> avec le <code>T</code> de la chaine. Plut\u00f4t que de calculer le saut en fonction du <code>C</code> align\u00e9 avec le caract\u00e8re \u00e0 droite du motif comme le fait l'algorithme d'Horspool (c'est-\u00e0-dire un saut de 2 caract\u00e8res), on utilise le premier mauvais caract\u00e8re, ici <code>T</code>, pour calculer le saut. Il y a un <code>T</code> dans le motif \u00e0 gauche de ce mauvais caract\u00e8re, on peut aligner ces <code>T</code> et  sauter de 3 caract\u00e8res.  Attention, on ne prend pas en compte le <code>T</code> dans le motif plac\u00e9 \u00e0 droite du mauvais caract\u00e8re.</p> <p>C'est comme si on calculait la table des sauts pour un motif r\u00e9duit \u00e0 la sous-chaine r\u00e9duite \u00e0 la gauche du mauvais caract\u00e8re, <code>TCAC</code> :</p> A C T autres 1 2 3 4 <p></p> <p>Le <code>C</code>  et le <code>T</code> du motif correspondent \u00e0 la chaine, mais pas le <code>C</code> avec le <code>G</code> de la chaine.  Il n'y a pas de <code>G</code> dans la partie droite du motif (il n'y en a pas du tout), on \u00ab saute \u00bb de toute la longueur du motif \u00e0 gauche du mauvais caract\u00e8re, c'est-\u00e0-dire de 4 caract\u00e8res, pour placer le motif apr\u00e8s le <code>G</code> :</p> <p></p> <p>Le <code>C</code> du motif correspond \u00e0 la chaine, mais pas le <code>T</code> avec le <code>A</code>. Le mauvais caract\u00e8re est un <code>A</code> et il y a un <code>A</code> dans le motif \u00e0 droite du mauvais caract\u00e8re, on \u00ab saute \u00bb de 2 caract\u00e8res pour aligner les <code>A</code>. </p> <p></p> <p>Tous les caract\u00e8res correspondent. On a trouv\u00e9 le motif en 6 \u00e9tapes, au lieu de 8 avec Horspool !</p> <p>A la diff\u00e9rence de Horspool, les sauts ne d\u00e9pendent pas que d'un seul caract\u00e8re dans la chaine (le caract\u00e8re \u00e0 droite), ils d\u00e9pendent du mauvais caract\u00e8re et de sa position dans le motif.  La table des sauts a donc deux entr\u00e9es : les caract\u00e8res du motif qui pourraient \u00eatre des mauvais caract\u00e8res et la position <code>j</code> \u00e0 laquelle ils se trouveraient dans le motif :</p> <ul> <li> <p>Pour <code>j = 5</code>, les sauts sont calcul\u00e9s sur la position du dernier caract\u00e8re du motif, on retrouve les sauts de Horspool.</p> </li> <li> <p>Pour les autres valeurs de <code>j</code>, il faut calculer les sauts sans prendre en compte les caract\u00e8res qui co\u00efncident, par exemple pour <code>j = 3</code>, les sauts correspondent aux sauts Horpsool pour le motif  <code>TCAC</code>, c'est-\u00e0-dire en ignorant les derniers caract\u00e8res <code>TC</code> (puisqu'ils co\u00efncident avec la cha\u00eene).</p> </li> <li> <p>Certaines valeurs ont un <code>X</code> pour les caract\u00e8res qui correspondent au motif (ce n'est pas un mauvais caract\u00e8re). </p> </li> </ul> j (lettre) A C T autres 0 (T) 1 1 X 1 1 (C) 2 X 1 2 2 (A) X 1 2 3 3 (C) 1 X 3 4 4 (T) 2 1 X 5 5 (C) 3 X 1 6 <p>Cours</p> <p>L'algorithme de Boyer-Moore consiste \u00e0 comparer les caract\u00e8res du motif avec ceux de la chaine un par un en remontant de droite \u00e0 gauche jusqu'\u00e0 trouver une diff\u00e9rence.</p> <p>R\u00e8gle du mauvais caract\u00e8re : Quand une diff\u00e9rence est trouv\u00e9e, on regarde le caract\u00e8re de la chaine qui est diff\u00e9rent du motif, c'est le mauvais caract\u00e8re. </p> <ul> <li> <p>Si ce mauvais caract\u00e8re de la chaine est aussi pr\u00e9sent dans la partie du motif qui est \u00e0 gauche de l'emplacement du mauvais caract\u00e8re, on d\u00e9cale le motif d'un saut pour aligner ce mauvais caract\u00e8re de la chaine avec sa derni\u00e8re occurrence dans le motif \u00e0 gauche de la diff\u00e9rence trouv\u00e9e.</p> </li> <li> <p>Si ce mauvais caract\u00e8re de la chaine n'est pas pr\u00e9sent dans la partie du motif qui \u00e0 gauche de l'emplacement du mauvais caract\u00e8re, on d\u00e9cale le motif d'un saut pour passer au del\u00e0 de la diff\u00e9rence trouv\u00e9e.</p> </li> </ul> <p>Pr\u00e9traitement des sauts :  Pour chaque lettre du motif (sauf la derni\u00e8re), et pour chaque position du mauvais caract\u00e8re, le saut \u00e0 effectuer est \u00e9gal \u00e0 l'\u00e9cart entre la derni\u00e8re occurrence de cette lettre dans le motif (en restant \u00e0 gauche du mauvais caract\u00e8re) et la position du mauvais caract\u00e8re. On ne calcule pas de saut pour le dernier caract\u00e8re.</p> <p>En Python, on peut construire cette table des sauts avec un tableau de dictionnaire :</p> <pre><code>[{},\n {'T': 1},\n {'C': 1, 'T': 2},\n {'A': 1, 'T': 3},\n {'A': 2, 'C': 1},\n {'A': 3, 'T': 1}]\n</code></pre> <p>La programmation de l'algorithme de Boyer-Moore d\u00e9passe le niveau attendu en NSI. </p> <pre><code>def table_sauts_bm(motif):\n    \"\"\" str -&gt; list(dict)\n    Renvoie un tableau de dictionnaires de sauts pour les valeurs de j\n    \"\"\"\n    tab = []\n    for j in range(len(motif)):\n        tab.append(table_sauts(motif[:j+1]))\n    return tab\n\ndef boyer_moore(motif, chaine):\n    positions = []\n    n = len(chaine)\n    m = len(motif)\n    sauts = table_sauts_bm(motif) # on construit le dictionnaire \u00ab table de saut \u00bb\n    print(chaine)\n    i = 0\n    while i &lt;= n - m: \n        print(' ' * i + motif)     # affiche le motif align\u00e9 avec la chaine\n        j = m - 1   # position du caract\u00e8re dans le motif\n        coincide = 0\n        while j &gt;= 0 and chaine[i + j] == motif[j]:\n            j = j - 1\n        # si on a trouv\u00e9 le motif\n        if j == -1:\n            positions.append(i)\n            i = i + 1\n        # sinon si le mauvais caract\u00e8re est dans le motif\n        elif chaine[i + j] in sauts[j]:    #\n            i = i + sauts[j][chaine[i + j]]    # on saute de la table de sauts\n        else:                # le caract\u00e8re n'est pas dans le motif\n            i = i + j + 1    # on saute tout le motif\n    return positions\n</code></pre>"},{"location":"algorithmique/5-recherche-textuelle/#regle-du-bon-suffixe-good-suffix-rule","title":"R\u00e8gle du bon suffixe (good-suffix rule)","text":"<p>Dans le cas o\u00f9 certains caract\u00e8res du motif correspondent \u00e0 ceux de la chaine, l'algorithme de Boyer-Moore calcule un saut suppl\u00e9mentaire en utilisant les \u00ab bons \u00bb caract\u00e8res plac\u00e9s \u00e0 droite du mauvais caract\u00e8re : le \u00ab bon suffixe \u00bb.</p> <p>Reprenons \u00e0 l'\u00e9tape 3 : </p> <p>Le <code>C</code> et le <code>T</code> du motif correspondent \u00e0 la chaine, mais pas le <code>C</code>  avec le <code>T</code> de la chaine. </p> <p>La r\u00e8gle du mauvais caract\u00e8re, ici <code>T</code>, nous dit d'aligner ce  <code>T</code> avec le <code>T</code> du motif plac\u00e9 \u00e0 gauche du mauvais caract\u00e8re, c'est \u00e0 dire un saut de 3 caract\u00e8res.</p> <p>On observe par ailleurs que les deux premiers caract\u00e8res du motif que l'on a compar\u00e9s \u00e0 la chaine, le <code>C</code> et le <code>T</code> du motif, \u00e9taient \u00ab bons \u00bb, ils forment un \u00ab bon suffixe \u00bb. Hors ce bon suffixe appara\u00eet aussi dans le motif, tout \u00e0 gauche du motif, et pas apr\u00e8s. On peut donc aussi aligner ces bons suffixes, ce qui permet de faire un saut de 4 caract\u00e8res.</p> <p>L'algorithme de Boyer-Moore applique le meilleur des deux, c'est un saut de 4 caract\u00e8res :</p> <p></p> <p>Ici, le mauvais caract\u00e8re est <code>T</code>, la r\u00e8gle du  mauvais caract\u00e8re nous permet d'aligner ce <code>T</code> avec le <code>T</code> du motif \u00e0 gauche, c'est-\u00e0-dire de \u00ab sauter \u00bb d'1 caract\u00e8re. Il n'y a pas de bon suffixe, on saute d'un caract\u00e8re :</p> <p></p> <p>Le <code>C</code>, puis le <code>T</code>, puis le <code>C</code> du motif correspondent \u00e0 la chaine, mais le <code>A</code> ne correspond pas au <code>T</code> de la chaine. On a donc un mauvais caract\u00e8re <code>T</code> et un bon suffixe <code>CTC</code> .</p> <p>La r\u00e8gle du \u00ab mauvais caract\u00e8re \u00bb nous permet de \u00ab sauter \u00bb de seulement 2 caract\u00e8res (on ne prend en compte que le premier <code>T</code> du motif, le second est trop \u00e0 droite). La r\u00e8gle du bon suffixe nous permet d'aligner les <code>TC</code> en \u00ab sautant \u00bb de 4 caract\u00e8res. On applique la meilleure des deux r\u00e8gles :</p> <p></p> <p>On a trouv\u00e9 le motif en 6 \u00e9tapes.</p> <p>La r\u00e8gle du \u00ab bon suffixe \u00bb consiste \u00e0 calculer une seconde table :</p> Bon suffixe Saut <code>C</code> 2 Si le bon suffixe est <code>C</code>, on peut \u00ab sauter \u00bb de 2 caract\u00e8res comme Horspool <code>TC</code> 4 <code>CTC</code> 4 On aligne avec le <code>TC</code> du d\u00e9but du motif <code>ACTC</code> 4 <code>CACTC</code> 4 <p>Cours</p> <p>L'algorithme de Boyer-Moore consiste \u00e0 comparer les caract\u00e8res du motif avec ceux de la chaine un par un en remontant de droite \u00e0 gauche jusqu'\u00e0 trouver une diff\u00e9rence.</p> <p>R\u00e8gle du bon suffixe : Quand une diff\u00e9rence est trouv\u00e9e, on regarde les caract\u00e8res de la chaine \u00e0 droite du mauvais caract\u00e8re, c'est le bon suffixe. </p> <ul> <li> <p>Si ce bon suffixe est pr\u00e9sent dans le motif \u00e0 droite, on d\u00e9cale le motif d'un saut pour aligner ce bon suffixe avec sa derni\u00e8re occurrence dans le motif.</p> </li> <li> <p>Si ce bon suffixe n'est pas pr\u00e9sent dans le motif, on d\u00e9cale le motif d'un saut de la longueur du motif pour passer \u00e0 droite du bon suffixe.</p> </li> </ul> <p>L'algorithme de Boyer Moore consiste \u00e0 prendre \u00e0 chaque \u00e9tape le plus grand saut entre les deux tables.</p> <p>On peut regarder l'animation de http://fred.boissac.free.fr/AnimsJS/recherchetextuelle/index.html </p> <ol> <li> <p>https://webhome.cs.uvic.ca/~nigelh/Publications/stringsearch.pdf \u21a9</p> </li> <li> <p>Thibaut Balabonski, Sylvain Conchon, Jean-Christophe Filli\u00e2tre, Kim Nguyen, Num\u00e9rique et Sciences Informatiques, 24 le\u00e7ons avec exercices corrig\u00e9s, Ellipses\u00a0\u21a9</p> </li> </ol>"},{"location":"architectures-materielles-et-systemes-d-exploitation/","title":"Architectures mat\u00e9rielles et syst\u00e8mes d'exploitation","text":"<p>La r\u00e9duction de taille des \u00e9l\u00e9ments des circuits \u00e9lectroniques a conduit \u00e0 l'av\u00e8nement de syst\u00e8mes sur puce (SoCs pour Systems on Chips en anglais) qui regroupent dans un seul circuit nombre de fonctions autrefois effectu\u00e9es par des circuits s\u00e9par\u00e9s assembl\u00e9s sur une carte \u00e9lectronique. Un tel syst\u00e8me sur puce est con\u00e7u et mis au point de fa\u00e7on logicielle, ses briques \u00e9lectroniques sont accessibles par des API, comme pour les biblioth\u00e8ques logicielles.</p> <p>Toute machine est dot\u00e9e d'un syst\u00e8me d'exploitation qui a pour fonction de charger les programmes depuis la m\u00e9moire de masse et de lancer leur ex\u00e9cution en leur cr\u00e9ant des processus, de g\u00e9rer l'ensemble des ressources, de traiter les interruptions ainsi que les entr\u00e9es-sorties et enfin d'assurer la s\u00e9curit\u00e9 globale du syst\u00e8me.</p> <p>Dans un r\u00e9seau, les routeurs jouent un r\u00f4le essentiel dans la transmission des paquets sur Internet : les paquets sont rout\u00e9s individuellement par des algorithmes. Les pertes logiques peuvent \u00eatre compens\u00e9es par des protocoles reposant sur des accus\u00e9s de r\u00e9ception ou des demandes de renvoi, comme TCP.</p> <p>La protection des donn\u00e9es sensibles \u00e9chang\u00e9es est au coeur d'Internet. Les notions de chiffrement et de d\u00e9chiffrement de paquets pour les communications s\u00e9curis\u00e9es sont explicit\u00e9es.</p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/1-systeme-sur-puce/","title":"Syst\u00e8me sur puce ou SoC (System on a Chip)","text":""},{"location":"architectures-materielles-et-systemes-d-exploitation/1-systeme-sur-puce/#vers-une-miniaturisation-sans-fin","title":"Vers une miniaturisation sans fin ?","text":""},{"location":"architectures-materielles-et-systemes-d-exploitation/1-systeme-sur-puce/#de-leniac-au-premier-microprocesseur","title":"De l'ENIAC au premier microprocesseur","text":"<p>Construit en 1945, le premier ordinateur enti\u00e8rement \u00e9lectronique est l'ENIAC (Electronic Numerical Integrator And Computer). Il est compos\u00e9 de 42 armoires de 3 m de hauteur qui abritent 18 000 tubes \u00e9lectroniques (tubes \u00e0 vide). </p> <p>Par Auteur inconnu \u2014 Domaine public, Lien</p> <p>Dans les ann\u00e9es 1950, l'invention des transistors, souvent d\u00e9crite comme l'invention du si\u00e8cle, puis des circuits int\u00e9gr\u00e9s permet la miniaturisation des \u00e9quipements informatiques.</p> <p>Pour envoyer des hommes sur la lune dans les ann\u00e9es 1960, les missions Apollo maximisent la puissance de calcul dans un espace restreint avec l'Apollo Guidance Computer (AGC), un ordinateur pesant seulement 32kg. L'AGC poss\u00e8de une m\u00e9moire de stockage de 72ko et une RAM de 2ko. </p> <p></p> <p>Transistor : circuit \u00e9lectronique fonctionnant comme un interrupteur pouvant prendre deux \u00e9tats auxquels sont associ\u00e9es les valeurs 0 et 1.</p> <p>Circuit int\u00e9gr\u00e9 ou puce \u00e9lectronique : ensemble de transistors qui se pr\u00e9sente sous la forme d'un boitier noir rectangulaire \u00e9quip\u00e9 de \u00ab pattes \u00bb (appel\u00e9es aussi broches ou pins) pour \u00e9tablir des connexions \u00e9lectriques.</p> <p>Microprocesseur ou CPU (Central Processeur Unit) : processeur dont les composants miniaturis\u00e9s sont regroup\u00e9s dans un unique circuit int\u00e9gr\u00e9.</p> <p>Jusqu'au d\u00e9but des ann\u00e9es 1970, les diff\u00e9rents composants \u00e9lectroniques, n\u00e9cessaires au fonctionnement d'un processeur ne peuvent pas tenir sur un seul circuit int\u00e9gr\u00e9, ce qui n\u00e9cessite d'interconnecter de nombreux composants dont plusieurs circuits int\u00e9gr\u00e9s.</p> <p>En 1971, la soci\u00e9t\u00e9 am\u00e9ricaine Intel r\u00e9ussit \u00e0 placer tous les composants sur un seul circuit int\u00e9gr\u00e9 donnant ainsi naissance au microprocesseur : c'est le 4004 d'Intel. Il int\u00e8gre dans une seule puce 2300 transistors ce qui lui donne une puissance de calcul comparable \u00e0 l'ENIAC !</p> <p></p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/1-systeme-sur-puce/#loi-de-moore","title":"Loi de Moore","text":"<p>En 1975, Gordon E. Moore (cofondateur d'Intel) \u00e9nonce la conjecture suivante appel\u00e9e loi de Moore : </p> <p>Dans les microprocesseurs, le nombre de transistors va doubler tous les deux ans.</p> <p>Par Max Roser, Hannah Ritchie \u2014 https://ourworldindata.org/uploads/2020/11/Transistor-Count-over-time.png, CC BY 4.0, Lien</p> <p>Exercice corrig\u00e9</p> <p>Observer l'\u00e9volution du nombre de transistors d'un microprocesseur et conclure si la loi de Moore s'est r\u00e9alis\u00e9e au cours des ann\u00e9es.</p> R\u00e9ponse <p>Selon la loi de Moore, tous les 20 ans, le nombre de transistors dans un microprocesseur est multipli\u00e9 par environ un facteur de mille ( 2^10 = 1024) ce qui semble en effet correspondre \u00e0 l'\u00e9volution qui appara\u00eet sur ce graphe : </p> <ul> <li>Entre 1971 et le d\u00e9but des ann\u00e9es 1990, il passe de 2300 \u00e0 environ  2 000 000.</li> <li>Entre le d\u00e9but des ann\u00e9es 1990 et 2010, il passe de 1-5 million \u00e0 1-5 milliards.</li> <li>Entre les ann\u00e9es 2000 et 2020, il passe de 50 millions \u00e0 50 milliards.</li> </ul> <p></p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/1-systeme-sur-puce/#la-miniaturisation-de-la-gravure-mene-au-telephone-portable","title":"La miniaturisation de la gravure m\u00e8ne au t\u00e9l\u00e9phone portable","text":"<p>A partir des ann\u00e9es 1980, l'architecture des ordinateurs n'\u00e9volue plus beaucoup : La miniaturisation de la gravure de la puce permet d'int\u00e9grer de plus en plus de composants et d'augmenter la fr\u00e9quence d'horloge : les ordinateurs vont de plus en plus vite et consomment de moins en moins d'\u00e9nergie.</p> <p>A partir des ann\u00e9es 2000, l'augmentation des fr\u00e9quences d'horloge atteint ses limites dues \u00e0 la plus grande consommation \u00e9lectrique et les probl\u00e8mes de refroidissement. Les constructeurs se tournent vers les microprocesseurs multi-c\u0153ur (multi-core) pour accroitre les performances.</p> <p>L'aboutissement de cette miniaturisation est le t\u00e9l\u00e9phone portable qui int\u00e8gre tout ce que la technologie peut nous apporter : un microprocesseur puissant, de la m\u00e9moire, des interfaces de communication rapides (4G, 5g, Wifi...), un contr\u00f4leur graphique digne d'une console de jeu, tout cela fonctionnant sur batterie avec une dur\u00e9e de fonctionnement de plusieurs heures.</p> <p>Cette augmentation du nombre de transistors par puce ne sera pas possible ind\u00e9finiment Aujourd'hui la finesse de gravure descend en dessous de 10nm, soit quelques dizaines d'atomes. Un jour, il faudra utiliser une solution autre que celle des puces en silicium, pour continuer \u00e0 augmenter la puissance des ordinateurs\u2026</p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/1-systeme-sur-puce/#systeme-sur-puce","title":"Syst\u00e8me sur puce","text":"<p>Dans un ordinateur de bureau le CPU effectue les diff\u00e9rents calculs permettant par exemple de faire tourner le syst\u00e8me d'exploitation. Les diff\u00e9rentes cartes (graphique (GPU), son, r\u00e9seau...) et les m\u00e9moires sont branch\u00e9es sur la carte m\u00e8re et interconnect\u00e9es \u00e0 l'aide de bus.</p> <p>Dans une tablette, un smartphone, etc\u2026 tous ces \u00e9l\u00e9ments ne constituent plus qu'un seul \u00e9l\u00e9ment, la puce. Tout ce que contient un ordinateur de bureau est concentr\u00e9 sur cette puce, c'est un ordinateur \u00e0 elle toute seule.</p> <p>Cours</p> <p>Un \u00ab syst\u00e8me sur puce \u00bb, ou SoC (pour \u00ab System on a Chip \u00bb), est un syst\u00e8me complet embarqu\u00e9 sur un seul circuit int\u00e9gr\u00e9, ou  \"puce\", regroupant le (ou plusieurs) microprocesseur, un processeur graphique, de la m\u00e9moire, des modules de communication sans fil (4G, 5G, puce radio pour le Bluetooth, Wi-Fi ), des p\u00e9riph\u00e9riques externes (E/S, capteurs, cam\u00e9ra), etc. </p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/1-systeme-sur-puce/#architecture-harvard","title":"Architecture Harvard","text":"<p>Les SoC utilisent g\u00e9n\u00e9ralement l'architecture d'Harvard, diff\u00e9rente de Von Neumann :  - Les m\u00e9moires des donn\u00e9es et des programmes sont s\u00e9par\u00e9es. - Deux bus distincts permettent de transf\u00e9rer simultan\u00e9ment les donn\u00e9es et les instructions\u00a0\u00e0 ex\u00e9cuter \u2192 plus grande rapidit\u00e9</p> <p></p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/1-systeme-sur-puce/#a-linterieur-dun-telephone-portable","title":"A l'int\u00e9rieur d'un t\u00e9l\u00e9phone portable","text":"<p>Le microprocesseur n'est qu'un composant du SoC qui est au c\u0153ur du t\u00e9l\u00e9phone. On peut voir un SoC comme un PC miniaturis\u00e9 \u00e0 l'extr\u00eame. Il comprend donc des composants et contr\u00f4leurs lui permettant de g\u00e9rer tous les \u00e9quipements de votre smartphone, qu'il s'agisse de l'appareil photo, de la m\u00e9moire interne, ou encore des modules radio.</p> <p>Voici la photo d'un iPhone 4S d\u00e9mont\u00e9 . Comme vous le voyez, le nombre de composants est tr\u00e8s r\u00e9duit au regard des fonctionnalit\u00e9s ! Le SoC de l'iPhone 4S, sur le circuit imprim\u00e9 \u00e0 droite, est une puce A5 qui combine principalement deux processeurs ARM Cortex-A9 et deux processeurs graphiques.</p> <p></p> <p>Exercice corrig\u00e9</p> <p>Trouver le nom du SoC de votre tablette scolaire (ou smartphone personnel)) et ses caract\u00e9ristiques techniques.</p> R\u00e9ponse <p>Informations trouv\u00e9es dans le menu Param\u00e8tres/Syst\u00e8me\\\u00c0 propos de la tablette :</p> <ul> <li>CPU : Qualcomm Snapdragon 450</li> <li>Stockage (ou ROM) : 32 GB</li> <li>RAM : 3 GB</li> </ul> <p>Note : \u00c0 la diff\u00e9rence d'un ordinateur, la m\u00e9moire ROM (Read-Only Memory) correspond au disque dur qui accueille le syst\u00e8me d'exploitation et les donn\u00e9es : apps, fichiers, photos, vid\u00e9os, SMS, etc\u2026. </p> <p>Exercice corrig\u00e9</p> <p>Associer \u00e0 chaque composant sur l'image \u00e0 son nom et trouver la description correspondante :</p> <p>Batterie -  Circuit imprim\u00e9 \u2013 M\u00e9moire-  Ecran tactile  \u2013 Cam\u00e9ras \u2013 GSM / WiFi / Bluetooth \u2013 Syst\u00e8me sur Puce  (SoC)        </p> R\u00e9ponse Num\u00e9ro Composant Description 1 Ecran tactile C'est le composant le plus connu, car le plus sujet \u00e0 la casse. Il faut bien faire la distinction entre la vitre tactile et la dalle d'affichage, mais sur la grande majorit\u00e9 des mod\u00e8les les plus r\u00e9cents la fonctionnalit\u00e9 tactile est d\u00e9sormais souvent int\u00e9gr\u00e9e \u00e0 la dalle d'affichage et non la vitre. 2 M\u00e9moire Elle correspond au disque dur de votre ordinateur. Vous y stockerez les applications que vous installerez, les photos et selfies que vous r\u00e9aliserez et bien d'autres donn\u00e9es encore (SMS, fichiers t\u00e9l\u00e9charg\u00e9s\u2026). 3 SoC Il regroupe presque tout le contenu d'un ordinateur sur un seul circuit int\u00e9gr\u00e9 : CPU, m\u00e9moire et autres composants interconnect\u00e9s. 4 Cam\u00e9ras Il existe y en a souvent deux une \u00e0 l'avant et une \u00e0 l'arri\u00e8re. Les derniers mod\u00e8les sont m\u00eames \u00e9quip\u00e9s de double, triple voire quadruple capteur avec t\u00e9l\u00e9objectif et grand angle. 5 GSM / WiFi / Bluetooth Il int\u00e8gre plusieurs types de connexions et r\u00e9seaux pour offrir la 43G, 4G ainsi que les connexions habituelles Wi-Fi et Bluetooth. 6 Circuit imprim\u00e9 Appel\u00e9 aussi PCB (printed circuit board) est un support, en g\u00e9n\u00e9ral une plaque, permettant de maintenir et de relier \u00e9lectriquement un ensemble de composants \u00e9lectroniques entre eux. 7 Batterie La technologie lithium-ion (ou li-ion) lui donne une \u00e9nergie massive. Ses inventeurs ont re\u00e7u le prix Nobel de chimie 2019."},{"location":"architectures-materielles-et-systemes-d-exploitation/1-systeme-sur-puce/#ordinateur-sur-carte-unique","title":"Ordinateur sur carte unique","text":"<p>Les ordinateurs sur carte unique ou SBC (Single Board Computers) sont une autre utilisation des SoC. Le Raspberry Pi en est un exemple. </p> <p>Cette carte est assez puissante pour faire fonctionner le syst\u00e8me d'exploitation Linux et \u00eatre utilis\u00e9 comme ordinateur de bureau, mini serveur ou pour des projets IoT.</p> <p></p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/1-systeme-sur-puce/#comparaison-entre-soc-et-ordinateurs-de-bureau","title":"Comparaison entre SoC et ordinateurs de bureau","text":"<p>Cours</p> <p>Les SoC offrent de nombreux avantages par rapport aux ordinateurs de bureau:</p> <ul> <li> <p>son faible encombrement est particuli\u00e8rement adapt\u00e9 pour  les smartphones et les tablettes tactiles ainsi que les syst\u00e8mes embarqu\u00e9s de petite taille</p> </li> <li> <p>sa consommation d'\u00e9nergie r\u00e9duite lui donne une grande autonomie sur batterie  et \u00e9vite la pr\u00e9sence d'un ventilateur (appareil silencieux). </p> </li> <li> <p>Notons \u00e9galement que les donn\u00e9es y circulent plus vite du fait de la distance r\u00e9duite entre les composants.</p> </li> </ul> <p>Mais aussi des inconv\u00e9nients : </p> <ul> <li> <p>Le manque de flexibilit\u00e9 : l'extr\u00eame int\u00e9gration du SoC n'autorise aucune mise \u00e0 jour du mat\u00e9riel ou de remplacement en cas de panne d'un composant alors qu'on peut faire \u00e9voluer individuellement  les composants sur la carte m\u00e8re d'un ordinateur.</p> </li> <li> <p>Enfin, les SoC sont souvent plus lents que les PC.</p> </li> </ul> <p></p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/1-systeme-sur-puce/#architectures-des-soc","title":"Architectures des SoC","text":"<p>Suivant les fabricants et les besoins, il existe plusieurs architectures. Deux d'entre elles prennent place dans la grande majorit\u00e9 des produits \u00e9lectroniques con\u00e7us ces vingt derni\u00e8res ann\u00e9es.</p> <ul> <li> <p>L'architecture ARM : Les SoC d'ARM se retrouvent ainsi dans la plupart des smartphones et des objets connect\u00e9s. Cette architecture est bas\u00e9e sur des jeux d'instructions RISC (Reduced Instruction Set Computing) qui sont plus petits, n\u00e9cessitent moins d'\u00e9nergie pour \u00eatre trait\u00e9s et se terminent rapidement, lib\u00e9rant ainsi les ressources du syst\u00e8me ou permettant \u00e0 l'appareil de \"rester en veille\" pour \u00e9conomiser la batterie.</p> </li> <li> <p>L'architecture X86 : Cette architecture a permis de d\u00e9velopper les processeurs des ordinateurs, des serveurs ou encore de certaines tablettes mais elle est beaucoup moins utilis\u00e9e pour d\u00e9velopper les SoCs (seul Asus d\u00e9veloppe des produits con\u00e7us \u00e0 partir des SoC X86). Cette architecture est bas\u00e9e sur des jeux d'instructions complexes CISC (Complex Instruction Set Computer).</p> </li> </ul>"},{"location":"architectures-materielles-et-systemes-d-exploitation/1-systeme-sur-puce/#microcontroleur","title":"Microcontr\u00f4leur","text":"<p>Le microcontr\u00f4leur est la forme la plus simple d'un SoC qui a donn\u00e9 naissance aux cartes Arduino et micro:bit, mais il y a de nombreuses diff\u00e9rences entre les SoC et les microcontroleurs.</p> Soc Microcontr\u00f4leur applications V\u00e9ritables ordinateurs : jeu, navigateur Web, cr\u00e9ation de document, etc.) Souvent d\u00e9di\u00e9s \u00e0 une tache sp\u00e9cifique (appareil photo, machine \u00e0 laver, etc.) Structure interne M\u00e9moire et p\u00e9riph\u00e9riques E/S externes CPU, m\u00e9moire et E/S internes Cout Elev\u00e9 Faible Consommation \u00e9lectrique Elev\u00e9e Faible Fr\u00e9quence 1 \u00e0 4 GHz 1 \u00e0 300 MHz M\u00e9moire (RAM) 512 Mo \u00e0 32 Go 2 Ko \u00e0 256 ko M\u00e9moire de masse (ROM) Disque dur (128 Go \u00e0 2To) M\u00e9moire flash (32ko \u00e0 2MB) Registers et bus 32 ou  64 bits 8, 16, 32 bits <p>Par exemple, la carte BBC micro:bit embarque un microcontr\u00f4leur qui est un syst\u00e8me complet comprenant de la m\u00e9moire RAM, de la m\u00e9moire FLASH, un microprocesseur, des p\u00e9riph\u00e9riques d'interface et un circuit radio.</p> <p></p> <p>Exercice corrig\u00e9</p> <p>Identifier le SoC pr\u00e9sent sur  la carte micro:bit et rechercher ses caract\u00e9ristiques (c\u0153ur, fr\u00e9quence, ROM et RAM) sur internet.</p> R\u00e9ponse <p>nRF51822 est un SoC \u00e0 c\u0153ur ARM Cortex-M0, une m\u00e9moire Flash et des p\u00e9riph\u00e9riques analogiques/num\u00e9riques sur un seul circuit.</p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/1-systeme-sur-puce/#fpga-et-asic","title":"FPGA et ASIC","text":"<p>Les puces reprogrammables FPGA (Field Programmable Gate Array) sont des circuits logiques qui peuvent \u00eatre reconfigur\u00e9s en pour obtenir une puce aux fonctionnalit\u00e9s d\u00e9sir\u00e9es. Elles utilisent des langages de programmation sp\u00e9cialis\u00e9s (VHDL, Verilog, ABEL, etc.) et sont utilis\u00e9s dans le prototypage de circuits int\u00e9gr\u00e9s</p> <p>Les puces ASIC (Application-specific integrated circuit) sont des circuits int\u00e9gr\u00e9s sp\u00e9cialis\u00e9s, con\u00e7u pour une t\u00e2che sp\u00e9cifique (stimulateurs cardiaques, minage de bitcoins, etc.).</p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/2-processus/","title":"Gestion des processus et des ressources par un syst\u00e8me d'exploitation","text":""},{"location":"architectures-materielles-et-systemes-d-exploitation/2-processus/#roles-et-fonctions-des-systemes-dexploitation","title":"R\u00f4les et fonctions des syst\u00e8mes d'exploitation","text":"<p>Cours</p> <p>Un syst\u00e8me d'exploitation (souvent appel\u00e9 OS de l'anglais Operating System) est un ensemble de programmes qui r\u00e9alise l'interface entre les utilisateurs et le mat\u00e9riel contenu dans une machine. Il a deux objectifs principaux :</p> <ul> <li>transformer le mat\u00e9riel en une machine utilisable par les utilisateurs ind\u00e9pendamment des caract\u00e9ristiques physiques,</li> <li>optimiser l'utilisation et le partage des ressources (mat\u00e9rielles et logicielles).</li> </ul> <p>Ces deux objectifs doivent \u00eatre atteints en garantissant le niveau de :</p> <ul> <li>la s\u00e9curit\u00e9 : int\u00e9grit\u00e9, contr\u00f4le des acc\u00e8s, confidentialit\u00e9, etc.</li> <li>la fiabilit\u00e9 : satisfaction des utilisateurs m\u00eame dans des conditions hostiles et impr\u00e9vues,</li> <li>la performance du syst\u00e8me informatique.</li> </ul> <p>Aujourd'hui, il existe sur PC trois syst\u00e8mes d'exploitation principaux : Mac OS, Linux et Windows. Mac OS et Linux sont tous les deux bas\u00e9s sur Unix, l'anc\u00eatre des syst\u00e8mes d'exploitation, tandis que Windows est une branche \u00e0 part issue de MS-DOS.</p> <p> </p> <p>Pour permettre le fonctionnement d'un ordinateur, de nombreuses t\u00e2ches ou applications doivent \u00eatre ex\u00e9cut\u00e9es simultan\u00e9ment, par le syst\u00e8me d'exploitation et les diff\u00e9rents utilisateurs) et plusieurs programmes doivent pouvoir acc\u00e9der \u00e0 un m\u00eame p\u00e9riph\u00e9rique sans conflit. Pour permettre cela, le syst\u00e8me d'exploitation g\u00e9n\u00e8re de nombreux processus, puis g\u00e8re leur ex\u00e9cution : c'est l'ordonnancement.</p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/2-processus/#les-processus","title":"Les processus","text":"<p>Un programme est un fichier ex\u00e9cutable contenant une suite d'instruction en langage machine stock\u00e9es en m\u00e9moire (par exemples sur le disque dur). Pour ex\u00e9cuter ce programme, le syst\u00e8me d'exploitation cr\u00e9\u00e9 un processus de la mani\u00e8re suivante:</p> <ol> <li>Le fichier contenant le programme est copi\u00e9 dans la RAM \u00e0 une certaine adresse</li> <li>Cette adresse est donn\u00e9e au processeur pour \u00eatre ex\u00e9cut\u00e9e \u00e0 son prochain cycle d'horloge.</li> </ol> <p>Cours</p> <p>Un processus est un programme en cours d'ex\u00e9cution. Le programme est statique et le processus est la repr\u00e9sentation dynamique de son ex\u00e9cution.</p> <p>Les notions de programme et de processus sont donc diff\u00e9rentes : le m\u00eame programme ex\u00e9cut\u00e9 plusieurs fois (dans le temps ou par plusieurs utilisateurs simultan\u00e9ment) g\u00e9n\u00e9rera plusieurs processus. Chaque processus poss\u00e8de en m\u00e9moire des instructions \u00e0 ex\u00e9cuter et des donn\u00e9es qui lui sont propres.</p> <p>Au sein du syst\u00e8me d'exploitation, le processus est repr\u00e9sent\u00e9 par une structure de donn\u00e9es appel\u00e9e bloc de contr\u00f4le de processus (PCB pour Process Control Bloc) qui contient notamment les informations suivantes :</p> <ul> <li>Un identifiant unique (un entier) appel\u00e9 PID;</li> <li>Un processus parent dont il h\u00e9rite la plupart des caract\u00e9ristiques appel\u00e9 PPID,</li> <li>Son \u00e9tat (\u00e9lu, pr\u00eat, bloqu\u00e9) ;</li> <li>Le contexte du processeur et de le m\u00e9moire li\u00e9s \u00e0 son ex\u00e9cution ;</li> <li>Des informations sur les ressources qu'il utilise ; etc.</li> </ul> <p>Le PCB permet la sauvegarde et la restauration du processus en cours d'ex\u00e9cution.</p> <p>Observons le PID de processus g\u00e9n\u00e9r\u00e9s par un programme Python :</p> <pre><code>from os import getpid\npid = str(getpid())\nprint(pid)\ninput('termin\u00e9?')\n</code></pre> <p>Quand on lance plusieurs fois le m\u00eame programme on observe les PID diff\u00e9rents.</p> <p></p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/2-processus/#creation-dun-processus","title":"Cr\u00e9ation d'un processus","text":"<p>La cr\u00e9ation d'un processus peut intervenir :</p> <ul> <li>au d\u00e9marrage du syst\u00e8me : le tout premier processus est cr\u00e9\u00e9 au moment du d\u00e9marrage de l'ordinateur,</li> <li>par un appel d'un autre processus : un processus peut cr\u00e9er un ou plusieurs processus. Si un processus P cr\u00e9e un processus F, on dira que P est le p\u00e8re de F et que F est le fils de P. F peut, \u00e0 son tour cr\u00e9\u00e9 un processus, etc.</li> <li>par l'action d'un utilisateur (lancement d'application).</li> </ul>"},{"location":"architectures-materielles-et-systemes-d-exploitation/2-processus/#etats-dun-processus","title":"\u00c9tats d'un processus","text":"<p>Le syst\u00e8me d'exploitation attribut des \"\u00e9tats\" au processus. Voici les diff\u00e9rents \u00e9tats :</p> <ul> <li>le processus est dans l'\u00e9tat \"\u00e9lu\" lorsqu'il est en train de s'ex\u00e9cuter (il utilise le microprocesseur) ; un seul processus peut se trouver dans l'\u00e9tat \"\u00e9lu\" : le microprocesseur ne peut \"s'occuper\" que d'un seul processus \u00e0 la fois</li> <li>le processus est dans l'\u00e9tat \"bloqu\u00e9\" lorsque de l'\u00e9tat \u00e9lu, il demande \u00e0 acc\u00e9der \u00e0 une ressource qui n'est pas forc\u00e9ment disponible instantan\u00e9ment (par exemple lire une donn\u00e9e sur le disque dur). Comme le processus ne peut pas poursuivre son ex\u00e9cution tant qu'il n'a pas obtenu cette ressource, il passe de l'\u00e9tat \"\u00e9lu\" \u00e0 l'\u00e9tat \"bloqu\u00e9\".</li> <li>le processus est dans l'\u00e9tat \"pr\u00eat\" lorsqu'il finit par obtenir la ressource attendue mais qu'il ne peut pas forc\u00e9ment reprendre son ex\u00e9cution imm\u00e9diatement car un autre processus est pass\u00e9 dans l'\u00e9tat \"\u00e9lu\" \u00e0 \"sa place\" pendant qu'il \u00e9tait dans \u00e0 \u00e9tat \"bloqu\u00e9\". Cet \u00e9tat signifie : \"j'ai obtenu ce que j'attendais, je suis pr\u00eat \u00e0 reprendre mon ex\u00e9cution d\u00e8s que la \"place sera lib\u00e9r\u00e9e\".</li> </ul> <p>Remarque : Un processus qui quitte l'\u00e9tat bloqu\u00e9 ne repasse pas \u00e0 l'\u00e9tat \"\u00e9lu\" imm\u00e9diatement, il passe dans l'\u00e9tat \"pr\u00eat\" en attendant que \"la place se lib\u00e8re\". </p> <p>Le passage de l'\u00e9tat \"pr\u00eat\" vers l'\u00e9tat \"\u00e9lu\" constitue l'op\u00e9ration \"d'\u00e9lection\". Le passage de l'\u00e9tat \"\u00e9lu\" vers l'\u00e9tat bloqu\u00e9 est l'op\u00e9ration de \"blocage\". Un processus est toujours cr\u00e9\u00e9 dans l'\u00e9tat \"pr\u00eat\".</p> <p> </p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/2-processus/#lordonnancement","title":"L'ordonnancement","text":"<p>A un instant donn\u00e9, de nombreux processus peuvent \u00eatre ex\u00e9cut\u00e9s simultan\u00e9ment (processus du syst\u00e8me d'exploitation, des applications utilisateurs, etc.). On dit que ces processus sont concurrents<sup>1</sup>. </p> <p>Une des t\u00e2ches du syst\u00e8me d'exploitation est d'allouer \u00e0 chacun des processus concurrents les ressources dont il a besoin en termes de m\u00e9moire, entr\u00e9es-sorties ou temps processeur, et de s'assurer que les processus ne se g\u00eanent pas les uns les autres. </p> <p>Cours</p> <p>Une ressource d\u00e9signe tout ce dont un processus a besoin pour s'ex\u00e9cuter. Ce peut-\u00eatre une ressource mat\u00e9rielle (processeur, p\u00e9riph\u00e9rique) ou logicielle (fichier, variable)</p> <p>Au sein du syst\u00e8me d'exploitation, c'est l'ordonnanceur qui est responsable qui permet de choisir \u00e0 un instant donn\u00e9 quel processus va s'ex\u00e9cuter. Pour \u00e9viter qu'un processus  s'ex\u00e9cute jusqu'\u00e0 sa derni\u00e8re instruction et monopolise le processeur avant de se terminer, le syst\u00e8me d'exploitation utilise un m\u00e9canisme d'interruptions.</p> <p>Cours</p> <p>Une interruption est un signal envoy\u00e9 au processeur pour interrompre son ex\u00e9cution \u00e0 la fin de l'instruction courante.</p> <p>Il existe plusieurs types d'interruptions, par exemple lorsqu'un processus attend une r\u00e9ponse de l'utilisateur, attend qu'une ressource se lib\u00e8re ou une carte r\u00e9seau indique que des donn\u00e9es arrivent et doivent \u00eatre trait\u00e9es, etc. il existe aussi des interruptions d'horloge g\u00e9n\u00e9r\u00e9es \u00e0 intervalles de temps fixe  pour permettre d'ex\u00e9cuter plusieurs programmes en m\u00eame temps. </p> <p>Cours</p> <p>Comme une ressource ne peut pas \u00eatre partag\u00e9e, c'est son temps d'utilisation qui va l'\u00eatre. C'est le r\u00f4le de l'ordonnanceur de partager le temps d'utilisation d'une ressource entre les processus.</p> <p>Quand l'ordonnanceur interrompt un processus, il enregistre son \u00e9tat (PCB) dans un emplacement de la m\u00e9moire, choisit le processus suivant \u00e0 ex\u00e9cuter et restaure  son dernier \u00e9tat enregistr\u00e9.  C'est la commutation de contexte.</p> <p>Plusieurs algorithmes d'ordonnancement sont possibles, voyons les plus r\u00e9pandus.</p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/2-processus/#le-premier-entre-premier-sorti-fifo-first-in-first-out","title":"Le premier entr\u00e9, premier sorti (FIFO : First In, First Out)","text":"<p>L'exemple le plus \u00e9vident de cet algorithme est la file d'impression des documents sur une imprimante.</p> <p>Exemple : Soit trois processus P1, P2 et P3 soumis au m\u00eame instant dans l'ordre 1, 2, 3</p> Processus Dur\u00e9e d'ex\u00e9cution Ordre de soumission P1 16 1 P2 4 2 P3 6 3 <p>On peut repr\u00e9senter l'ex\u00e9cution des trois processus sur le chronogramme suivant :</p> <p> </p> <p>On obtient les temps d'attente et temps de r\u00e9ponse de chaque processus : |Processus|Temps d'attente|Temps de r\u00e9ponse| |:-:|:-:|:-:| |P1|0|16| |P2|16|20| |P3|20|26|</p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/2-processus/#le-plus-court-dabord","title":"Le \u00ab plus court d'abord \u00bb","text":"<p>Tr\u00e8s efficace pour satisfaire au mieux les utilisateurs, mais il n'est pas toujours simple d'\u00e9valuer le temps d'ex\u00e9cution d'une t\u00e2che avant son d\u00e9but. Exemple : Soit trois processus P1, P2 et P3 soumis au m\u00eame instant </p> Processus Dur\u00e9e d'ex\u00e9cution P1 16 P2 4 P3 6 <p>On obtient le chronogramme d'ex\u00e9cution suivant : </p> <p> </p> Processus Temps d'attente Temps de r\u00e9ponse P1 0 4 P2 4 10 P3 14 26"},{"location":"architectures-materielles-et-systemes-d-exploitation/2-processus/#par-priorite","title":"Par priorit\u00e9","text":"<p>L'ordre d'affectation de la ressource sera alors fonction de la priorit\u00e9 de la t\u00e2che, mais le niveau de priorit\u00e9 de chaque t\u00e2che n'est pas toujours simple \u00e0 d\u00e9terminer. </p> <p>Exemple : Soit trois processus P1, P2 et P3 soumis au m\u00eame instant avec des priorit\u00e9s moyenne, haute, faible</p> Processus Dur\u00e9e d'ex\u00e9cution Priorit\u00e9 P1 16 Moyenne P2 4 Haute P3 16 Faible <p>On obtient le chronogramme d'ex\u00e9cution suivant : </p> <p> </p> Processus Temps d'attente Temps de r\u00e9ponse P1 0 4 P2 4 20 P3 20 26"},{"location":"architectures-materielles-et-systemes-d-exploitation/2-processus/#le-tourniquet","title":"Le tourniquet","text":"<p>La ressource est affect\u00e9e \u00e0 chaque processus \u00e0 tour de r\u00f4le. Pour l'ex\u00e9cution simultan\u00e9e des processus, c'est la rapidit\u00e9 de ce tour de r\u00f4le qui va donner l'impression \u00e0 chaque utilisateur que son processus est seul \u00e0 utiliser le processeur. Cette m\u00e9thode ancienne a les avantages de sa simplicit\u00e9, de sa rapidit\u00e9 de gestion et de sa robustesse.</p> <p>Exemple : Soit trois processus P1, P2 et P3 soumis au m\u00eame instant dans l'ordre 1, 2, 3 et des interruptions toutes les 2 unit\u00e9s de temps</p> Processus Dur\u00e9e d'ex\u00e9cution Ordre de soumission P1 16 1 P2 4 2 P3 16 3 <p>On obtient le chronogramme d'ex\u00e9cution suivant : </p> <p> </p> Processus Temps d'attente Temps de r\u00e9ponse P1 0 26 P2 1 10 P3 2 16 <p>Programmons un algorithme du tourniquet en Python :</p> <pre><code># Processus \u00e0 ex\u00e9cuter et suite d'instructions\nliste_processus = [\n        # Processus 1\n        [\"P1_instruction_1\",\n         \"P1_instruction_2\",\n         \"P1_instruction_3\",\n         \"P1_instruction_4\",\n         \"P1_instruction_5\",\n         \"P1_instruction_6\",\n         \"P1_instruction_7\"],\n        # Processus 2\n        [\"P2_instruction_1\",\n         \"P2_instruction_2\",\n         \"P2_instruction_3\"],\n        # Processus 3\n        [\"P3_instruction_1\",\n         \"P3_instruction_2\",\n         \"P3_instruction_3\",\n         \"P3_instruction_4\",\n         \"P3_instruction_5\"]]\n\nexiste_instruction=1\nindice_instruction=0\n\n# Tant qu'il existe des instructions \u00e0 ex\u00e9cuter\nwhile (existe_instruction != 0) :\n    indice_processus=0\n    existe_instruction=0\n    # Partage entre les processus\n    while indice_processus != len(liste_processus):\n        # si le processus a encore des instructions \u00e0 executer\n        if indice_instruction &lt; len(liste_processus[indice_processus]):\n            # l'instruction est execut\u00e9e\n            print (liste_processus[indice_processus][indice_instruction])\n            # il existe encore au moins une instruction \u00e0 executer\n            existe_instruction = 1\n        indice_processus = indice_processus + 1\n\n    indice_instruction = indice_instruction +1\n</code></pre>"},{"location":"architectures-materielles-et-systemes-d-exploitation/2-processus/#observer-les-processus","title":"Observer les processus","text":"<p>Chaque processus est identifi\u00e9 par un identifiant unique appel\u00e9 PID (Process Identifier). Le premier processus cr\u00e9\u00e9 au d\u00e9marrage du syst\u00e8me a pour PID 0, le second 1, le troisi\u00e8me 2... Le syst\u00e8me d'exploitation utilise un compteur qui est incr\u00e9ment\u00e9 de 1 \u00e0 chaque cr\u00e9ation de processus. </p> <p>Les processus comprennent de nombreuses autres informations sur leur \u00e9tat notamment  </p> <ul> <li>le processus parent  dont il h\u00e9rite la plupart des caract\u00e9ristiques : <code>PPID</code></li> <li>le propri\u00e9taire (<code>User</code>, <code>UID</code>, etc..) d\u00e9terminant les droits d'acc\u00e8s aux ressources</li> <li>un terminal d'attache pour les entr\u00e9es/sorties (<code>tty</code>)</li> <li>son niveau de priorit\u00e9, sa date de lancement,  les quantit\u00e9s de ressources consomm\u00e9es, etc\u2026 </li> </ul>"},{"location":"architectures-materielles-et-systemes-d-exploitation/2-processus/#sous-windows","title":"Sous Windows","text":"<p>On peut utiliser le gestionnaire de taches Windows (ALT+CTRL+DEL), la commande <code>tasklist</code> ou des logiciels \u00e9quivalents par exemple Process Explorer.</p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/2-processus/#sous-linux","title":"Sous linux","text":""},{"location":"architectures-materielles-et-systemes-d-exploitation/2-processus/#arborescence-des-processus","title":"Arborescence des processus","text":"<p>Sous Linux, le tout premier processus appel\u00e9 processus 0 est cr\u00e9\u00e9 \u00e0 partir de \"rien\" (il n'est le fils d'aucun processus). Ensuite, ce processus 0 cr\u00e9e un processus souvent appel\u00e9 \"init\" (\"init\" est donc le fils du processus 0) ; \"init\" a donc un PID de 1 et un PPID de 0.</p> <p>\u00c0 partir de \"init\", les processus n\u00e9cessaires au bon fonctionnement du syst\u00e8me  sont cr\u00e9\u00e9s (par exemple les processus \"inetd\", \"crond\", \u2026, \"getty\"). Puis d'autres processus  sont cr\u00e9\u00e9s \u00e0 partir des fils de \"init\"...</p> <p>Deux types de processus existent:</p> <ul> <li>Les processus utilisateurs, tous issus du shell de connexion;</li> <li>Les processus \u00ab daemon \u00bb  (pour deferred auxiliary executive monitor) qui assurent un service et sont souvent lanc\u00e9s au d\u00e9marrage de la machine. Les principaux services assur\u00e9s par des processus daemon sont l'impression, les t\u00e2ches p\u00e9riodiques, les communications, la comptabilit\u00e9, le suivi de t\u00e2che. \u2003</li> </ul>"},{"location":"architectures-materielles-et-systemes-d-exploitation/2-processus/#voir-et-supprimer-les-processus","title":"Voir et supprimer les processus","text":""},{"location":"architectures-materielles-et-systemes-d-exploitation/2-processus/#commande-ps","title":"Commande ps","text":"<p>Cours</p> <p>La commande ps affiche les caract\u00e9ristiques des processus \u00e0 un instant donn\u00e9. Par d\u00e9faut, <code>ps</code> affiche les processus de l'utilisateur.</p> <p> </p> <p>G\u00e9n\u00e9ralement un processus se termine \u00e0 la fin de l'ex\u00e9cution de sa derni\u00e8re instruction ; il est alors d\u00e9truit par le syst\u00e8me d'exploitation . </p> <p>Cours</p> <p>La commande <code>kill  PID_processus</code> permet \u00e9galement d'interrompre un processus.</p> <p>Remarque : Le droit de d\u00e9truire un processus est r\u00e9serv\u00e9 \u00e0 son propri\u00e9taire.</p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/2-processus/#ressources-partagees","title":"Ressources partag\u00e9es","text":"<p>Certaines ressources ne peuvent \u00eatre utilis\u00e9es que par un seul processus \u00e0 la fois. Le syst\u00e8me d'exploitation doit fournir un  m\u00e9canisme pour en contr\u00f4ler l'utilisation. Le plus courant est un syst\u00e8me de verrou ou mutex (mutual exclusion).</p> <p>Exemple :</p> <ul> <li>Deux processus concurrents P1 et P2 ont tous les deux besoins de la m\u00eame ressource D pour la modifier, c'est-\u00e0-dire de mani\u00e8re exclusive.</li> <li>P1 est le premier \u00e0 demander le mutex, il verrouille l'acc\u00e8s \u00e0 D.</li> <li>P2 demande le mutex, il n'est pas disponible, P2 passe \u00e0 l'\u00e9tat bloqu\u00e9 jusqu'\u00e0 ce que le mutex soit lib\u00e9r\u00e9.</li> </ul> <p> </p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/2-processus/#interblocages","title":"Interblocages","text":"<p>Cours</p> <p>Dans certains cas, plusieurs processus peuvent \u00eatre en attente d\u2019une ressource bloqu\u00e9s les uns par les autres. Rien ne pourra \u00e9voluer sans une intervention ext\u00e9rieure : cette situation porte le nom d'interblocage (ou deadlock en anglais).</p> <p>Exemple : </p> <ul> <li>P1 et P2 ont tous les deux besoins de deux donn\u00e9es D1 et D2. P1 verrouille l\u2019acc\u00e8s \u00e0 D1 et est en attente de D2 et P2 verrouille D2 et est en attente de D1.</li> </ul> <p> </p> <ol> <li> <p>A ne pas confondre avec des processus parall\u00e8les qui s'ex\u00e9cutent au m\u00eame instant donc sur une machine multiprocesseurs ou sur un processeur multi-c\u0153ur.\u00a0\u21a9</p> </li> </ol>"},{"location":"architectures-materielles-et-systemes-d-exploitation/3-securisation-des-communications/","title":"S\u00e9curisation des communications","text":""},{"location":"architectures-materielles-et-systemes-d-exploitation/3-securisation-des-communications/#communications-sur-internet","title":"Communications sur Internet","text":"<p>On a vu que les donn\u00e9es circulent sur internet d\u00e9coup\u00e9es en petits paquets (par les protocoles TCP et UDP) qui sont relay\u00e9s par des routeurs depuis leur \u00e9metteur jusqu'\u00e0 leur destinataire (par le protocole IP).</p> <p></p> <p>Les paquets pourraient donc \u00eatre intercept\u00e9s en chemin pour en conna\u00eetre le contenu ou les modifier. Cela pose un probl\u00e8me de la s\u00e9curit\u00e9 des communications, en particulier quand des donn\u00e9es sensibles sont \u00e9chang\u00e9es (donn\u00e9es bancaires, m\u00e9dicales, militaires, etc.), selon trois aspects :</p> <ul> <li>Confidentialit\u00e9 : s'assurer que des donn\u00e9es confidentielles ne soient pas divulgu\u00e9es ;</li> <li>Authenticit\u00e9 : s'assurer que les donn\u00e9es re\u00e7ues proviennent de leur \u00e9metteur l\u00e9gitime ;</li> <li>Int\u00e9grit\u00e9 : s'assurer que les donn\u00e9es \u00e9chang\u00e9es ne sont pas modifi\u00e9es de fa\u00e7on malveillante.</li> </ul> <p>Cours</p> <p>La cryptographie consiste \u00e0 prot\u00e9ger les donn\u00e9es (confidentialit\u00e9, authenticit\u00e9 et int\u00e9grit\u00e9) \u00e0 l'aide de secrets appel\u00e9s cl\u00e9s de chiffrement.</p> <p>Le chiffrement des communications consiste \u00e0 rendre un message incompr\u00e9hensible en utilisant une cl\u00e9 de chiffrement.</p> <p>Le d\u00e9chiffrement  consiste \u00e0 retrouver le message original en utilisant la cl\u00e9 de chiffrement. Lorsqu'on peut retrouver le message sans la cl\u00e9, par exemple dans le cas de piratage informatique, on parle de d\u00e9cryptage.</p> <p> Ne pas confondre les termes chiffrer/d\u00e9chiffrer avec coder/d\u00e9coder<sup>1</sup> et \u00e9viter l'anglicisme crypter parfois utilis\u00e9 au lieu de chiffrer. </p> <p>On peut visionner \u00ab Comprendre le chiffrement SSL / TLS avec des emojis (et le HTTPS) \u00bb pour d\u00e9couvrir ce chapitre.</p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/3-securisation-des-communications/#cryptographie-symetrique-ou-a-cle-secrete","title":"Cryptographie sym\u00e9trique ou \u00ab \u00e0 cl\u00e9 secr\u00e8te \u00bb","text":"<p>Cours</p> <p>La cryptographie sym\u00e9trique, \u00e9galement appel\u00e9e \u00ab \u00e0 cl\u00e9 secr\u00e8te \u00bb, est la plus ancienne forme de chiffrement. Elle permet \u00e0 la fois de chiffrer et de d\u00e9chiffrer des messages \u00e0 l'aide d'une m\u00eame cl\u00e9.</p> <p>Prenons un exemple : Alice (A) et Bob (B)<sup>2</sup> connaissent tous les deux une m\u00eame cl\u00e9 secr\u00e8te qui leur permet de chiffrer et d\u00e9chiffrer des messages qu'ils s'\u00e9changent.</p> <p> </p> <p>Avec cette cl\u00e9, Alice peut chiffrer des messages et les envoyer \u00e0 Bob, puis Bob peut les d\u00e9chiffrer. Dans l'autre sens, Alice peut aussi d\u00e9chiffrer des messages chiffr\u00e9s en provenance de Bob. La communication est s\u00e9curis\u00e9e dans les deux sens par une cl\u00e9 unique.</p> <p>C'est un moyen simple et efficace de communiquer de mani\u00e8re s\u00e9curis\u00e9e, mais qui a deux inconv\u00e9nients :</p> <ul> <li> <p>Il faut que Alice et Bob trouvent un moyen s\u00fbr de se transmettre la cl\u00e9 au pr\u00e9alable et \u00e0 l'abri des regards.</p> </li> <li> <p>Si Alice veut communiquer de fa\u00e7on s\u00e9curis\u00e9e avec plusieurs correspondants ind\u00e9pendamment, elle doit g\u00e9rer autant de cl\u00e9s diff\u00e9rentes qu'elle a de correspondants.</p> </li> </ul> <p>Voyons quelques exemples historiques de cryptographie sym\u00e9trique : </p> <ul> <li>Le chiffrement par d\u00e9calage, ou code de C\u00e9sar, est une m\u00e9thode de chiffrement basique utilis\u00e9e par Jules C\u00e9sar dans ses correspondances secr\u00e8tes, qui consiste \u00e0 d\u00e9caler chaque lettre d'un message clair d'un nombre fixe de lettres dans l'alphabet, par exemple avec un d\u00e9calage de 3, A devient D (la lettre D est 3 lettres apr\u00e8s A dans l'alphabet) et R devient U (U est 3 lettres apr\u00e8s R).</li> </ul> <p></p> <ul> <li> <p>Le chiffrement de Vigen\u00e8re, datant du 16e si\u00e8cle, agit un peu comme un code de C\u00e9sar, \u00e0 la diff\u00e9rence que tous les caract\u00e8res ne sont pas d\u00e9cal\u00e9s de la m\u00eame valeur. Les d\u00e9calages d\u00e9pendent d'une cl\u00e9, en g\u00e9n\u00e9ral donn\u00e9e par un mot ou une phrase. La cl\u00e9 est align\u00e9e avec le message \u00e0 chiffrer et r\u00e9p\u00e9t\u00e9e jusqu'\u00e0 la fin du message. </p> <p>Par exemple, si la cl\u00e9 est \"NSI\", les lettres du message clair seront d\u00e9cal\u00e9es dans l'ordre de :</p> <ul> <li>14 lettres (N est la 14e lettre de l'alphabet) ; puis de</li> <li>19 lettres (S est la 19e lettre de l'alphabet) ; puis de</li> <li>9 lettres (I est la 5e lettre de l'alphabet) ; </li> <li>puis on recommence avec 14 lettres, 19 lettres, etc. jusqu'\u00e0 la fin du message.</li> </ul> <p>Pour chiffrer le message \"BONJOUR\", on aligne la cl\u00e9 avec le message et on la r\u00e9p\u00e8te autant de fois que n\u00e9cessaire pour appliquer le d\u00e9calage correspondant \u00e0 chaque lettre :</p> <pre><code>message :   BONJOUR\ncl\u00e9 :       NSINSIN \n            -------\nVigen\u00e8re :  PHWXHDF\n</code></pre> </li> <li> <p>Le chiffrement XOR consiste \u00e0 appliquer l'op\u00e9ration logique XOR (OU exclusif, not\u00e9 \u00ab \u2295 \u00bb) bit \u00e0 bit entre le message clair et une cl\u00e9 secr\u00e8te. Comme pour le chiffrement de Vigen\u00e8re, la cl\u00e9 est align\u00e9e avec le message \u00e0 chiffrer et r\u00e9p\u00e9t\u00e9e jusqu'\u00e0 la fin du message. Beaucoup utilis\u00e9 aux d\u00e9buts de l'informatique, il appara\u00eet encore aujourd'hui dans les algorithmes de chiffrement modernes comme RSA ou AES.</p> <p>Par exemple, pour chiffrer le mot \"BONJOUR\" avec la cl\u00e9 \"NSI\" :</p> <pre><code>message :   B       O        N        J        O        U        R\n        01000010 01001111 01001110 01001010 01001111 01010101 01010010\ncl\u00e9 :       N       S        I        N        S        I        N\n        01001110 01010011 01001001 01001110 01010011 01001001 01001110\n        -------- -------- -------- -------- -------- -------- -------- \nXOR :   00001100 00011100 00000111 00000100 00011100 00011100 00011100\n</code></pre> </li> </ul> <p>On peut observer dans les trois exemples pr\u00e9c\u00e9dents l'aspect sym\u00e9trique de la cl\u00e9 permettant \u00e0 la fois de chiffer et de d\u00e9chiffrer un message. Pour le code de C\u00e9sar ou de Vigen\u00e8re, les m\u00eames d\u00e9calages sont utilis\u00e9s pour d\u00e9chiffrer un message, mais dans l'autre sens, c'est-\u00e0-dire en calculant la lettre plac\u00e9e avant dans l'alphabet. Dans le cas du chiffrement XOR, on utilise la propri\u00e9t\u00e9 (A \u2295 B) \u2295 B = A qui montre qu'il suffit d'appliquer une seconde fois un chiffrement XOR au message chiffr\u00e9 pour retrouver le message en clair.</p> <p>Exercice corrig\u00e9</p> <p>Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l'alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, \u2026, le X en A, le Y en B et le Z en C.  Pour simplifier, on suppose que la cha\u00eene \u00e0 chiffrer ne contient que des lettres ASCII en majuscule, les espaces et autres caract\u00e8res ('!','?', etc.) ne sont pas chiffr\u00e9s.</p> <p>La fonction <code>position_alphabet</code> ci-dessous prend en param\u00e8tre un caract\u00e8re <code>lettre</code> et renvoie la position de <code>lettre</code> dans la cha\u00eene de caract\u00e8res <code>ALPHABET</code> s'il s'y trouve.</p> <p>La fonction <code>cesar</code> prend en param\u00e8tres une cha\u00eene de caract\u00e8res <code>message</code> et un nombre entier <code>decalage</code> et renvoie le nouveau message chiffr\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage <code>decalage</code>.</p> <pre><code>ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\ndef position_alphabet(lettre):\n    '''Renvoie la position de la lettre dans l'alphabet'''\n    return ord(lettre) - ord('A')\n\ndef cesar(message, decalage):\n    '''Renvoie le message chiffr\u00e9 par la m\u00e9thode de C\u00e9sar\n    pour le decalage donn\u00e9'''\n    resultat = ''\n    for ... in message:\n        if 'A' &lt;= c and c &lt;= 'Z':\n            indice = (...) % 26\n            resultat = resultat + ALPHABET[indice]\n        else:\n            resultat = ...\n    return resultat\n</code></pre> <p>Compl\u00e9ter la fonction <code>cesar</code>.</p> <p>Exemples :</p> <p><pre><code>&gt;&gt;&gt; cesar('BONJOUR A TOUS. VIVE LA MATIERE NSI !', 4)\n'UTQBTOK D YINX. ACOJ DF FFWAJLX QKN !'\n&gt;&gt;&gt; cesar('UTQBTOK D YINX. ACOJ DF FFWAJLX QKN !', -5)\n'BONJOUR A TOUS. VIVE LA MATIERE NSI !'\n</code></pre> Source: Epreuve Pratique 24-NSI-46</p> R\u00e9ponse <pre><code>def cesar(message, decalage):\n    '''Renvoie le message chiffr\u00e9 par la m\u00e9thode de C\u00e9sar\n    pour le decalage donn\u00e9'''\n    resultat = ''\n    for c in message:\n        if 'A' &lt;= c and c &lt;= 'Z':\n            indice = (position_alphabet(c) + decalage) % 26\n            resultat = resultat + ALPHABET[indice]\n        else:\n            resultat = resultat + c\n    return resultat\n</code></pre> <p>Exercice corrig\u00e9</p> <p>Ecrire les fonctions <code>chiffre_vigenere(message:str, cle:str)</code> et <code>dechiffre_vigenere(message:str, cle:str)</code>  qui renvoient <code>message</code> chiffr\u00e9 ou d\u00e9chiffr\u00e9 en utilisant le chiffrement de Vigen\u00e8re avec la cl\u00e9 <code>cle</code>.</p> <p>Pour simplifier, on suppose que la cha\u00eene \u00e0 chiffrer et la cl\u00e9 ne contiennent que des lettres ASCII en majuscule, les espaces et autres caract\u00e8res ('!','?', etc.) ne sont pas chiffr\u00e9s.</p> <pre><code>Exemples :\n&gt;&gt;&gt; chiffre_vigenere('BONJOUR A TOUS. VIVE LA MATIERE NSI !', 'SECRET')\n'TSPASNJ C XHMW. ZBNI CE EEVZIKW PJM !'\n&gt;&gt;&gt; dechiffre_vigenere('TSPASNJ C XHMW. ZBNI CE EEVZIKW PJM !', 'SECRET')\n'BONJOUR A TOUS. VIVE LA MATIERE NSI !'\n</code></pre> R\u00e9ponse <pre><code>def chiffre_vigenere(message:str, cle:str) -&gt; str:\n    '''Renvoie le message chiffr\u00e9 par chiffrement de Vigen\u00e8re\n    pour la cl\u00e9 donn\u00e9e\n    '''\n    resultat = ''\n    for i in range(len(message)):\n        c = message[i]\n        decalage = position_alphabet(cle[i%len(cle)])\n        if 'A' &lt;= c and c &lt;= 'Z':\n            indice = (position_alphabet(c) + decalage) % 26\n            resultat = resultat + ALPHABET[indice]\n        else:\n            resultat = resultat + c\n    return resultat\n\n\ndef dechiffre_vigenere(message:str, cle:str) -&gt; str:\n        # remplacer par\n        indice = (position_alphabet(c) - decalage) % 26\n</code></pre> <p>Ces algorithmes historiques sont plut\u00f4t faciles \u00e0 \"casser\", en particulier en utilisant des analyses de fr\u00e9quence de caract\u00e8res. Des algorithmes de cryptographie sym\u00e9trique plus r\u00e9cents sont plus efficaces, par exemple : </p> <ul> <li> <p>RC4 est utilis\u00e9 par les algorithmes WEP et WPA permettant la s\u00e9curisation de r\u00e9seaux Wi-FI ainsi que par TLS permettant de s\u00e9curiser des \u00e9changes sur un r\u00e9seau. Il repose sur une cl\u00e9 obtenue par des m\u00e9langes d'octets puis un chiffrement XOR.</p> </li> <li> <p>DES (Data Encryption Standard)  utilisant des cl\u00e9s de 56 bits, il n'est plus assez s\u00e9curis\u00e9 et doit \u00eatre appliqu\u00e9 plusieurs fois (Triple DES ou 3DES) pour \u00eatre efficace. Il est assez lent et appel\u00e9 \u00e0 \u00eatre remplac\u00e9 par des algorithmes plus modernes.</p> </li> <li> <p>AES (Advanced Encryption Standard) est actuellement l'algorithme de cryptographie sym\u00e9trique le plus utilis\u00e9. Il est consid\u00e9r\u00e9 comme l'un des chiffrements les plus s\u00fbrs. Il est utilis\u00e9 par exemple les algorithmes WPA2 pour s\u00e9curiser le Wi-Fi, Windows Bitlocker pour chiffrer un disque dur, LastPass ou Dahslane pour les gestionnaires de mots de passe, etc. </p> <p>AES utilise une cl\u00e9 secr\u00e8te de taille 128, 192 ou 256 bits, ce qui d\u00e9termine la s\u00e9curit\u00e9 du chiffrement. Les donn\u00e9es sont divis\u00e9es en petits blocs de 128 bits, soit 16 octets, dispos\u00e9s dans un tableau 4x4. Les octets sont ensuite transform\u00e9s en plusieurs \u00e9tapes : un chiffrement XOR, une substitution des octets (SubBytes) selon un tableau pr\u00e9d\u00e9fini (S-box), un d\u00e9calage des lignes du tableau (ShiftRows), un m\u00e9lange des colonnes du tableau (MixColumns), et \u00e0 nouveau un chiffrement XOR avec une autre cl\u00e9. Ces \u00e9tapes sont r\u00e9p\u00e9t\u00e9es plusieurs fois pour renforcer la s\u00e9curit\u00e9 (10, 12 ou 14 fois selon la longueur de la cl\u00e9).</p> </li> </ul>"},{"location":"architectures-materielles-et-systemes-d-exploitation/3-securisation-des-communications/#cryptographie-asymetrique-ou-a-cle-publique","title":"Cryptographie asym\u00e9trique ou \u00ab \u00e0 cl\u00e9 publique \u00bb","text":"<p>La cryptographie sym\u00e9trique souffre d'un inconv\u00e9nient majeur : comment partager une cl\u00e9, en particulier lors d'une communication sur un r\u00e9seau publique ? Pour r\u00e9soudre ce probl\u00e8me, des techniques de cryptographie asym\u00e9trique ont \u00e9t\u00e9 invent\u00e9es dans les ann\u00e9es 1970.</p> <p>Cours</p> <p>La cryptographie asym\u00e9trique, \u00e9galement appel\u00e9e \u00ab \u00e0 cl\u00e9 publique \u00bb, permet de s\u00e9curiser le transfert des donn\u00e9es, et d'authentifier leur origine gr\u00e2ce \u00e0 l'utilisation de deux cl\u00e9s :</p> <ul> <li>une cl\u00e9 publique, mise \u00e0 la disposition de quiconque et permettant le chiffrement ;</li> <li>une cl\u00e9 priv\u00e9e, qui doit rester confidentielle et permettant le d\u00e9chiffrement.</li> </ul> <p>Ceci est une convention, le r\u00f4le des cl\u00e9s est interchangeable : un message chiffr\u00e9 avec une cl\u00e9 (publique ou priv\u00e9e) peut-\u00eatre d\u00e9chiffr\u00e9e avec l'autre (respectivement la cl\u00e9 priv\u00e9e ou publique).</p> <p>La cryptographie asym\u00e9trique a une double fonctionnalit\u00e9, elle permet de :</p> <ul> <li> <p>chiffrer un message \u00e0 envoyer\u202f: l'exp\u00e9diteur utilise la clef publique du destinataire pour chiffrer son message. Le destinataire utilise sa clef priv\u00e9e pour d\u00e9chiffrer le message de l'exp\u00e9diteur. Il est le seul \u00e0 conna\u00eetre sa cl\u00e9 priv\u00e9e, donc le seul \u00e0 pouvoir d\u00e9chiffrer le message,  garantissant la confidentialit\u00e9.</p> <p> </p> <p>Alice peut lire le message en provenance de Bob en le d\u00e9chiffrant avec sa cl\u00e9 priv\u00e9e. Elle est la seule \u00e0 pouvoir le faire, \u00c8ve<sup>3</sup> ne peut pas.</p> </li> <li> <p>s'assurer de l'authenticit\u00e9 de l'exp\u00e9diteur\u202f: l'exp\u00e9diteur utilise sa clef priv\u00e9e pour chiffrer un message que tout le monde peut d\u00e9chiffrer avec la clef publique de l'exp\u00e9diteur. L'exp\u00e9diteur est le seul qui a pu chiffrer ce message, garantissant que c'est bien lui qui en est \u00e0 l'origine, c'est un m\u00e9canisme de signature num\u00e9rique.</p> <p> </p> <p>Alice peut signer ses messages. Bob, et \u00c8ve, sont certains que les messages re\u00e7us proviennent d'Alice et de personne d'autre.</p> </li> </ul> <p>Le chiffrement asym\u00e9trique repose sur des probl\u00e8mes math\u00e9matiques tr\u00e8s difficiles \u00e0 r\u00e9soudre dans un sens et faciles \u00e0 r\u00e9soudre dans l'autre sens. Voyons quelques exemples.</p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/3-securisation-des-communications/#un-exemple-de-cryptographie-asymetrique-rsa","title":"Un exemple de cryptographie asym\u00e9trique : RSA","text":"<p>Le chiffrement RSA (d\u00e9crit en 1977 et nomm\u00e9 par les initiales de ses trois inventeurs, Rivest, Shamir et  Adleman) est un algorithme de cryptographie asym\u00e9trique, tr\u00e8s utilis\u00e9 dans le commerce \u00e9lectronique, et plus g\u00e9n\u00e9ralement pour \u00e9changer des donn\u00e9es confidentielles sur Internet. </p> <p>Le principe de RSA repose sur des calculs modulo un nombre entier n qui est le produit de deux nombres premiers. Le petit th\u00e9or\u00e8me de Fermat joue un r\u00f4le important dans la conception de ce chiffrement. Les op\u00e9rations de chiffrement et de d\u00e9chiffrement consistent \u00e0 \u00e9lever le message \u00e0 certaines puissances modulo ce nombre n.</p> <p>Sans d\u00e9crire les principes math\u00e9matiques derri\u00e8re la cr\u00e9ation des cl\u00e9s, prenons l'exemple suivant : n = 55, la cl\u00e9 publique d'Alice est le couple (55, 3) et sa cl\u00e9 priv\u00e9e est (55, 27). Bob veut transmettre le nombre 41 \u00e0 Alice. </p> <p> </p> <ol> <li> <p>Chiffrement de M = 41 par Bob avec la cl\u00e9 publique d'Alice, le couple (55, 3) : Bob calcule \\(M^3\\) mod \\(55\\), c'est-\u00e0-dire le reste de la division euclidienne de \\(M^3\\) par \\(55\\), qu'on peut \u00e9crire en Python <code>M**3 % 55</code>, ou encore <code>pow(M, 3, 55)</code> : </p> <p><pre><code>&gt;&gt;&gt; M = 41\n&gt;&gt;&gt; M**3\n68921\n&gt;&gt;&gt; 68921 % 55\n6\n</code></pre> Il obtient le nombre \\(6\\), c'est le chiffrement de M avec la cl\u00e9 publique d'Alice, qu'il transmet \u00e0 Alice.</p> <p>Note : En math\u00e9matique, on dit que \\(41^3\\) est congru \u00e0 \\(6\\) modulo \\(55\\) et on \u00e9crit \\(41^3 \u2261 6\\) mod \\(55\\).</p> </li> <li> <p>D\u00e9chiffrement de \\(C = 6\\) par Alice avec sa cl\u00e9 priv\u00e9e, le couple (55, 27) : Alice calcule \\(C^{27}\\) mod \\(55\\), c'est-\u00e0-dire le reste de la division euclidienne de \\(C^{27}\\) par \\(55\\), qu'on peut \u00e9crire en Python <code>C**27 % 55</code>, ou encore <code>pow(C, 27, 55)</code> :</p> <p><pre><code>&gt;&gt;&gt; C = 6\n&gt;&gt;&gt; C**27\n1023490369077469249536\n&gt;&gt;&gt; 1023490369077469249536 % 55\n41\n</code></pre> Alice retrouve bien le message initial de Bob \\(M = 41\\).</p> <p>Note : En math\u00e9matique, on dit que \\(6^{27}\\) est congru \u00e0 \\(41\\) modulo \\(55\\) et on \u00e9crit \\(6^{27} \u2261 41\\) mod \\(55\\).</p> </li> </ol> <p>On constate que pour chiffrer un message, il suffit de conna\u00eetre la cl\u00e9 publique d'Alice. En revanche, il semble impossible de le d\u00e9chiffrer sans conna\u00eetre sa cl\u00e9 priv\u00e9e.</p> <p>La s\u00e9curit\u00e9 de l'algorithme RSA contre les attaques par la force brute repose sur la difficult\u00e9 de factoriser le nombre n en un produit de deux nombres premiers. Tous les algorithmes connus actuellement sont en temps exponentiel, mais cela pourrait ne plus \u00eatre le cas dans le futur avec les d\u00e9veloppements de l'informatique quantique ! En pratique, il faut donc choisir de tr\u00e8s grands nombres premiers pour calculer les cl\u00e9 RSA, habituellement des nombres cod\u00e9s sur 1 024 \u00e0 2 048 bits[^3.4] . </p> <p>[^3.4] : Le calcul de \\(M**d%n\\) n'est alors plus possible de mani\u00e8re na\u00efve : il y a beaucoup trop de chiffres.  On utilise un algorithme d\u2019exponentiation modulaire : https://en.wikipedia.org/wiki/Modular_exponentiation</p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/3-securisation-des-communications/#un-autre-exemple-de-cryptographie-asymetrique-echange-de-cles-diffie-hellman","title":"Un autre exemple de cryptographie asym\u00e9trique : \u00c9change de cl\u00e9s Diffie-Hellman","text":"<p>L'algorithme de Diffie-Hellman est aussi bas\u00e9 sur des th\u00e9ories math\u00e9matiques avanc\u00e9es. Il est d\u00e9crit ici en prenant un exemple num\u00e9rique tout en faisant une analogie avec des couleurs inspir\u00e9e de Wikipedia. </p> <p>L'objectif est qu'Alice et Bob se mettent d'accord sur un nombre secret (ou une couleur secr\u00e8te par analogie), sans qu'\u00c8ve ne puisse le conna\u00eetre. Pour les couleurs, on suppose qu'on peut les m\u00e9langer, mais qu'il est impossible d'extraire les couleurs utilis\u00e9es pour r\u00e9aliser un m\u00e9lange donn\u00e9. Le principe est le suivant :</p> <p> </p> <ol> <li> <p>Alice et Bob choisissent au pr\u00e9alable deux nombres \\(p = 23\\) et \\(g = 5\\) (les th\u00e9ories math\u00e9matiques qui permettent de choisir ces nombres ne sont pas expliqu\u00e9es ici). Ces deux nombres sont connus de tous, y compris de l'intrus \u00c8ve. On fait l'analogie avec une peinture commune, ici le jaune.</p> <p>En Python, on peut \u00e9crire :  <pre><code>&gt;&gt;&gt; p, g = 23, 5\n</code></pre></p> </li> <li> <p>Alice choisit un nombre secret, \\(a = 4\\), assimil\u00e9 \u00e0 la couleur rouge. En utilisant \\(a\\), \\(p\\) et \\(g\\), elle calcule \\(A = g^a\\) mod \\(p\\) = \\(5^4\\) mod \\(23\\) = \\(4\\). En couleur, c'est comme si elle m\u00e9langeait la peinture commune jaune et sa couleur secr\u00e8te rouge et obtenait de l'orange. Alice envoie le nombre \\(A\\) (ou la couleur orange obtenue par ce m\u00e9lange) \u00e0 Bob. L'\u00e9change est public, \\(A\\) (ou la couleur orange) peut \u00eatre intercept\u00e9 et connu par \u00c8ve.     <pre><code>&gt;&gt;&gt; a = 4\n&gt;&gt;&gt; A = g**a % p\n</code></pre></p> </li> <li> <p>Bob fait de m\u00eame : il choisit un nombre secret, \\(b = 3\\), assimil\u00e9 \u00e0 la couleur bleue.  En utilisant \\(b\\), \\(p\\)  et \\(g\\), il calcule \\(B = g^b\\) mod \\(p\\) = \\(5^3\\) mod \\(23\\) = \\(10\\). En couleur, c'est comme s'il m\u00e9langeait la peinture commune jaune et sa couleur secr\u00e8te bleue et obtenait du vert. Bob envoie le nombre \\(B\\) (ou la couleur verte obtenue par ce m\u00e9lange) \u00e0 Alice. \\(B\\) (ou la couleur verte) peut aussi \u00eatre connu par \u00c8ve.     <pre><code>&gt;&gt;&gt; b = 3\n&gt;&gt;&gt; B = g**b % p\n</code></pre></p> </li> <li> <p>Alice calcule maintenant \\(B^a\\) mod \\(p\\) = \\(10^4\\) mod \\(23\\) et obtient un nouveau nombre secret \\(s= 18\\). En couleur, c'est comme si elle prenait la couleur verte re\u00e7ue de Bob et qu'elle la m\u00e9langeait avec sa couleur secr\u00e8te rouge, elle obtiendrait une couleur marron.     <pre><code>&gt;&gt;&gt; B**a % p\n18\n</code></pre></p> </li> <li> <p>De son c\u00f4t\u00e9, Bob calcule  \\(A^b\\) mod \\(p\\) = \\(4^3\\) mod \\(23\\) et obtient le m\u00eame nombre secret \\(s= 18\\). En couleur, c'est comme s'il prenait la couleur orange re\u00e7ue d'Alice et qu'il la m\u00e9langeait avec sa couleur secr\u00e8te bleue, il obtiendrait la m\u00eame couleur marron.     <pre><code>&gt;&gt;&gt; A**b % p\n18\n</code></pre></p> </li> </ol> <p>A la fin de l'algorithme, Alice et Bob partagent le m\u00eame nombre secret \\(s= 18\\), ou la m\u00eame couleur marron. \u00c8ve ne connaissant pas les nombres secrets qu'ils ont choisis chacun de leur cot\u00e9 (\\(a = 4\\) et \\(b = 3\\)), elle ne peut pas calculer \\(s\\). Avec les couleurs, en supposant qu'il est difficile pour \u00c8ve d'extraire les couleurs qui ont \u00e9t\u00e9 m\u00e9lang\u00e9es au jaune pour obtenir de l'orange et du vert, \u00c8ve ne pourra pas r\u00e9aliser un m\u00e9lange couleur marron identique \u00e0 celui partag\u00e9 par les deux autres.</p> <p>On peut aussi visionner L'Algorithme qui S\u00e9curise Internet (entre autres...) de  ScienceEtonnante.</p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/3-securisation-des-communications/#attaque-de-lhomme-du-milieu","title":"Attaque de l'homme du milieu","text":"<p>Cours</p> <p>L'attaque de l'homme du milieu ou man-in-the-middle (MITM) est une attaque qui a pour but d'intercepter les communications entre deux parties, sans que ni l'une ni l'autre ne puisse se douter que le canal de communication entre elles a \u00e9t\u00e9 compromis</p> <p>Alice et Bob veulent \u00e9changer des donn\u00e9es confidentielles mais \u00c8ve veut les intercepter. </p> <p>Comme on l'a vu auparavant, dans une situation normale Alice et Bob \u00e9changent leur cl\u00e9 publique, chacun chiffre ses messages avec la cl\u00e9 publique de l'autre et ils sont donc les seuls \u00e0 pouvoir les d\u00e9chiffrer avec leur cl\u00e9 priv\u00e9e respective. \u00c8ve ne conna\u00eet pas les cl\u00e9s priv\u00e9es d'Alice et Bob, elle est incapable de d\u00e9chiffrer les messages qu'ils s'\u00e9changent.</p> <p>Admettons maintenant que \u00c8ve soit en mesure d'intercepter les \u00e9changes entre Alice et Bob.</p> <ul> <li>Alice envoie sa cl\u00e9 publique \u00e0 Bob. \u00c8ve l'intercepte et renvoie \u00e0 Bob sa propre cl\u00e9 publique en se faisant passer pour Alice.</li> <li>Lorsque Bob veut envoyer un message \u00e0 Alice, il utilise donc, sans le savoir, la cl\u00e9 publique d'\u00c8ve. Bob chiffre le message avec la cl\u00e9 publique d'\u00c8ve et l'envoie \u00e0 celle qu'elle croit \u00eatre Alice.</li> <li>\u00c8ve intercepte le message, le d\u00e9chiffre avec sa cl\u00e9 priv\u00e9e et peut conc lire le message et m\u00eame le modifier.</li> <li>Puis elle chiffre \u00e0 nouveau le message avec la cl\u00e9 publique d'Alice.</li> <li>Alice d\u00e9chiffre son message avec sa cl\u00e9 priv\u00e9e, et ne se doute de rien puisque tout fonctionne. Ainsi, Alice et Bob sont chacun persuad\u00e9s d'utiliser la cl\u00e9 publique de l'autre, alors qu'ils utilisent en r\u00e9alit\u00e9 tous les deux la cl\u00e9 publique d'\u00c8ve.</li> </ul> <p> </p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/3-securisation-des-communications/#certificats-et-autorites-de-certification","title":"Certificats et Autorit\u00e9s de Certification","text":"<p>Afin de s\u00e9curiser enti\u00e8rement les communications entre deux participants, il ne suffit pas seulement de les chiffrer, mais il faut aussi que chaque participant puisse s'assurer de l'identit\u00e9 de son correspondant : c'est le r\u00f4le des certificats d'authentification.</p> <p>Cours</p> <p>Un certificat d'authentification (ou certificat SSL ou TLS) d\u00e9livr\u00e9 par une entit\u00e9 de confiance, une autorit\u00e9 de certification, permet d'\u00e9tablir avec certitude l'identit\u00e9 du d\u00e9tenteur de certificat (site Web, entreprise, individu) afin de s\u00e9curiser les communications avec cette entit\u00e9.</p> <p>Les autorit\u00e9s de certification sont des organismes enregistr\u00e9s et certifi\u00e9s par des \u00e9tats ou des autorit\u00e9s de contr\u00f4le de l'Internet. Il y a un peu plus d'une centaine : Amazon Trust Services, CertEurope, Cisco, DigiCert, Google Trust Services LLC, Gouvernement fran\u00e7ais (ANSSI, DCSSI), Microsoft, Symantec, Visa\u2026</p> <p>Ce certificat contient la cl\u00e9 publique de l'entit\u00e9  certifi\u00e9e et d'autres informations d'identification, par exemple l'URL d'un site web, le nom d'une soci\u00e9t\u00e9 ou d'une personne, sa localisation, son adresse \u00e9lectronique. Toutes ces informations sont chiffr\u00e9es par une autorit\u00e9 de certification, en utilisant sa cl\u00e9 priv\u00e9e, afin de garantir l'exactitude des informations. On dit alors que le certificat est sign\u00e9.</p> <p> </p> <p>Les navigateurs, les syst\u00e8mes d'exploitation et les appareils mobiles tiennent \u00e0 jour la liste de cl\u00e9s publiques d'un certain nombre d'autorit\u00e9s de certification. Ces cl\u00e9s sont appel\u00e9es cl\u00e9s publiques racines ou certificats racines. Un certificat racine doit \u00eatre pr\u00e9sent sur la machine de l'utilisateur pour \u00eatre consid\u00e9r\u00e9 fiable, sinon le navigateur affiche des messages d'alerte indiquant qu'il ne faut pas lui faire confiance.  On peut consulter les cl\u00e9s publiques racines stock\u00e9es sur un ordinateur : </p> <ul> <li>sous Windows avec la commande certmgr.msc ;</li> </ul> <p></p> <ul> <li>sous Linux avec ls /etc/ssl/certs ; </li> <li>avec Firefox : options \u2192 vie priv\u00e9e et s\u00e9curit\u00e9 \u2192 Afficher les certificats\u2026 ;</li> <li>avec Edge : param\u00e8tres \u2192 confidentialit\u00e9, recherche et services \u2192 G\u00e9rer les certificats.</li> </ul>"},{"location":"architectures-materielles-et-systemes-d-exploitation/3-securisation-des-communications/#https","title":"HTTPS","text":"<p>Cours</p> <p>HTTPS (HyperText Transfer Protocol Secure) est la combinaison du protocole de base du Web HTTP avec les protocoles de chiffrement SSL (Secure Socket Layer) ou de son successeur TLS (Transport Layer Security).</p> <p>Il permet :</p> <ul> <li> <p>A un visiteur de v\u00e9rifier l'identit\u00e9 du site web auquel il acc\u00e8de, gr\u00e2ce \u00e0 un certificat d'authentification \u00e9mis par une autorit\u00e9 de certification ;</p> </li> <li> <p>De garantir la confidentialit\u00e9 et l'int\u00e9grit\u00e9 des donn\u00e9es envoy\u00e9es par l'utilisateur (notamment des informations confidentielles ou sensibles) et re\u00e7ues du serveur.</p> </li> <li> <p>De valider l'identit\u00e9 du visiteur, si celui-ci utilise \u00e9galement un certificat d'authentification client.</p> </li> </ul> <p>Le principal inconv\u00e9nient des algorithmes \u00e0 cl\u00e9 publique est leur grande lenteur par rapport aux algorithmes \u00e0 cl\u00e9 secr\u00e8te. RSA est par exemple au moins 100 fois plus lent que AES. Pour s\u00e9curiser une communication, l'id\u00e9e de TLS est donc d'utiliser un algorithme \u00e0 cl\u00e9 publique pour \u00e9changer un nombre al\u00e9atoire qui sert ensuite de cl\u00e9 secr\u00e8te pour un algorithme de chiffrement sym\u00e9trique de la communication. </p> <p> </p> <ol> <li> <p>Le client \u2014 un navigateur Web\u202f\u2014 envoie un message initial (nomm\u00e9 \u00ab  hello \u00bb) \u00e0 un serveur \u2014\u202fpar exemple Wikip\u00e9dia\u202f\u2014 et demande une connexion s\u00e9curis\u00e9e, pr\u00e9cisant les m\u00e9thodes de chiffrement qu'il accepte : RSA ou Diffie-Hellman.</p> </li> <li> <p>Le serveur r\u00e9pond en communiquant : </p> <p>\u2212   une m\u00e9thode de chiffrement choisie parmi la liste re\u00e7ue,</p> <p>\u2212   un certificat sign\u00e9 par une autorit\u00e9 de certification (AC) contenant sa cl\u00e9 publique.</p> </li> <li> <p>Le client v\u00e9rifie que le certificat re\u00e7u a bien \u00e9t\u00e9 sign\u00e9 par une autorit\u00e9 de certification en laquelle il fait confiance en le d\u00e9chiffrant avec la cl\u00e9 publique de cette autorit\u00e9 de certification. Cette \u00e9tape garantit qu'il a bien re\u00e7u la cl\u00e9 du serveur en question et qu'il n'est pas victime d'une attaque de l'homme du milieu.</p> </li> <li> <p>Le client chiffre avec la cl\u00e9 publique publique du serveur, ou avec un secret partag\u00e9 Diffie-Hellman, une cl\u00e9 de chiffrement sym\u00e9trique pour la session qu'il envoie au serveur.</p> </li> <li> <p>A ce stade, le client et le serveur se sont reconnus, ont choisi une m\u00e9thode de chiffrement et se sont \u00e9chang\u00e9s une cl\u00e9 secr\u00e8te de chiffrement sym\u00e9trique : ils peuvent communiquer d'une mani\u00e8re s\u00e9curis\u00e9e garantissant la confidentialit\u00e9 et l'int\u00e9grit\u00e9 des communications ainsi que l'authenticit\u00e9 de leur correspondant.</p> </li> </ol> <p>Sur Firefox par exemple on peut voir les d\u00e9tails d'un certificat et le chiffrement utilis\u00e9 en cliquant sur le cadenas. </p> <p></p> <p>On peut obtenir des informations similaires avec les autres navigateurs.</p> <p>Le bouton \"View Certificate\" permet d'obtenir les d\u00e9tails sur l'Autorit\u00e9 de Certification et le certificat utilis\u00e9. </p> <ol> <li> <p>L'autorit\u00e9 de certification, ici Digicert, qui atteste, au moyen d'un certificat num\u00e9rique, que l'entit\u00e9 est bien qui elle pr\u00e9tend \u00eatre.</p> </li> <li> <p>Les dates de validit\u00e9 du certificat. </p> </li> <li> <p>La cl\u00e9 publique du site Web, c'est-\u00e0-dire celle qui sera utilis\u00e9e par le navigateur pour chiffrer la communication initiale ainsi que l'algorithme de chiffrement, ici Elliptic Curve.</p> </li> </ol> <p>Le certificat est sign\u00e9 (chiffr\u00e9) avec la cl\u00e9 priv\u00e9e de l'autorit\u00e9 de certification. Il suffira au navigateur de le d\u00e9chiffrer avec la cl\u00e9 publique racine dont il dispose pour v\u00e9rifier l'authenticit\u00e9 du site Web.  </p> <ol> <li> <p>coder d\u00e9signe la repr\u00e9sentation des donn\u00e9es dans un certain format, par exemple coder un entier en binaire, ou d\u00e9coder un code ASCII.\u00a0\u21a9</p> </li> <li> <p>Alice et Bob forment le couple le plus connu du monde de la cryptographie\u00a0\u21a9</p> </li> <li> <p>En cryptographie le nom de \u00c8ve, pour eavedropper (oreille indiscr\u00e8te), est souvent choisi pour d\u00e9signer l'homme du milieu.\u00a0\u21a9</p> </li> </ol>"},{"location":"architectures-materielles-et-systemes-d-exploitation/4-routage/","title":"Protocoles de routage","text":""},{"location":"architectures-materielles-et-systemes-d-exploitation/4-routage/#couche-internet-et-adresses-ip","title":"Couche Internet et adresses IP","text":""},{"location":"architectures-materielles-et-systemes-d-exploitation/4-routage/#modeles-osi-et-tcpip","title":"Mod\u00e8les OSI et TCP/IP","text":"<p>Communiquer consiste \u00e0 transmettre des informations, mais tant que les interlocuteurs ne lui ont pas attribu\u00e9 un sens, il ne s'agit que de donn\u00e9es et pas d'information. Les interlocuteurs doivent donc non seulement parler un langage commun mais aussi ma\u00eetriser des r\u00e8gles minimales d'\u00e9mission et de r\u00e9ception des donn\u00e9es. C'est le r\u00f4le d'un protocole.</p> <p>Cours</p> <p>L'ensemble des r\u00e8gles qui permettent \u00e0 deux machines de communiquer ensemble via un r\u00e9seau s'appelle un protocole.</p> <p>Afin de s'y retrouver au milieu des protocoles r\u00e9seaux, les mod\u00e8les OSI et TCP/IP permettent de les classer selon leurs niveaux d'abstractions, dans ce qu'on appelle des couches. </p> <p>Cours</p> <p>Une couche r\u00e9seau regroupe un ensemble de protocoles ayant un m\u00eame niveau d'abstraction ets des fonctionnalit\u00e9s similaires.</p> <p>Le mod\u00e8le OSI (Open Systems Interconnection) comporte sept couches. Le mod\u00e8le TCP/IP est plus simple, il ne comporte que quatre couches : Acc\u00e8s au R\u00e9seau, Internet, Transport et Application.</p> <p> </p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/4-routage/#couche-acces-au-reseau-les-adresses-mac","title":"Couche Acc\u00e8s au R\u00e9seau : les adresses MAC","text":"<p>Une carte d'interface r\u00e9seau -- ou carte r\u00e9seau ou NIC (pour Network Interface Controller) -- par exemple une carte Ethernet ou WiFi, poss\u00e8de une adresse unique, appel\u00e9e adresse MAC (Media Access Control) qui est donn\u00e9e par le constructeur de la carte et qui permet de l'identifier de fa\u00e7on unique.</p> <p></p> <p>L'adresse MAC est constitu\u00e9e de 6 octets \u00e9crits sous forme hexad\u00e9cimale, chacun s\u00e9par\u00e9 par \" : \" (par exemple : <code>00:13:A9:58:32:EB</code>). Les 3 premiers octets d\u00e9finissent le constructeur de la carte r\u00e9seau (ici Sony Corporation), les 3 derniers le num\u00e9ro de fabrication.</p> <p>Dans un r\u00e9seau, un commutateur (ou switch) conna\u00eet les adresses MAC des machines qui lui sont branch\u00e9es. </p> <p>Les paquets de donn\u00e9es envoy\u00e9s \u00e0 l'adresse MAC <code>FF:FF:FF:FF:FF:FF</code> (adresse broadcast) sont envoy\u00e9s \u00e0 toutes les machines connect\u00e9es au r\u00e9seau. Le protocole ARP (Address Resolution Protocol) permet de lier les adresses MAC aux adresses IP correspondantes.</p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/4-routage/#couche-internet-les-adresses-ip","title":"Couche Internet : les adresses IP","text":"<p>Cours</p> <p>L'adresse IP permet d'identifier une machine sur un r\u00e9seau. </p> <p>Une machine qui poss\u00e8de plusieurs cartes d'interface r\u00e9seau a plusieurs adresses IP, chaque adresse \u00e9tant associ\u00e9e \u00e0 une carte r\u00e9seau.</p> <p>Il existe actuellement deux versions du protocole IP: IPv4 et IPv6 :</p> <p> </p> <ul> <li> <p>La version IPv4 utilise des adresses 32 bits, g\u00e9n\u00e9ralement repr\u00e9sent\u00e9es en notation d\u00e9cimale par 4 octets (prenant les valeurs entre 0 et 255), s\u00e9par\u00e9s par des points.  </p> <p>Exemple d'adresse IPv4 :  <code>172.16.254.1</code>.</p> <p>Le nombre d'adresses IPv4 possibles est de \\(2^{32} = 256^4 = 4{\\space}294{\\space}967{\\space}296\\). Ces adresses sont en cours \u00ab d'\u00e9puisement \u00bb, c'est-\u00e0-dire qu'il n'y en a plus assez par rapport aux besoins du monde actuel.</p> </li> </ul> <p> </p> <ul> <li> <p>La version IPv6 utilise des adresses plus longues de 128 bits, repr\u00e9sent\u00e9es par 8 champs de 16 bits, d\u00e9limit\u00e9s par deux points (:). Chaque champ doit contenir un nombre hexad\u00e9cimal, ou laiss\u00e9 vide quand il est \u00e9gal \u00e0 z\u00e9ro.</p> <p>Exemple d'adress IPv6 : <code>3002:0bd6::::ee00:0033:6778</code></p> <p>Le nombre d'adresses IPv6 disponibles est de \\(2^{128}\\) c'est-\u00e0-dire \\(3,4 {\\times} 10^{38}\\)  adresses, ce protocole semble donc in\u00e9puisable. </p> </li> </ul> <p>Cours</p> <p>L'adresse IP est ins\u00e9parable de son masque de sous-r\u00e9seau.  Dans le masque, les bits \u00e0 1 repr\u00e9sentent la partie r\u00e9seau de l'adresse IP, les bits \u00e0 0 repr\u00e9sentent la partie machine. </p> <p>Comme le masque de sous-r\u00e9seau est cod\u00e9 sur 32 bits, voici un exemple possible de masque:</p> <code>__________R\u00e9seau__________|_Machine</code> IP <code>192.168.1.45</code> <code>11000000.10101000.00000001|00101101</code> Masque <code>255.255.255.0</code> <code>11111111.11111111.11111111|00000000</code> R\u00e9seau <code>192.168.1.0</code> <code>11000000.10101000.00000001|00000000</code> <p>Prenons l'exemple d'une machine d'adresse IP <code>192.168.1.45</code> avec le masque <code>255.255.255.0</code>. Les bits des trois premiers octets du masque sont \u00e0 <code>1</code>, ils donnent la partie \u00ab r\u00e9seau \u00bb, et les bits suivant \u00e0 <code>0</code> donnent la partie \u00ab machine \u00bb. </p> <p>L'adresse dont tous les bits de la partie machine sont \u00e0 <code>0</code> (<code>192.168.1.0</code>) est l'adresse du r\u00e9seau entier, celle dont tous les bits de la partie machine sont \u00e0 <code>1</code> (<code>192.168.1.255</code>) est l'adresse de diffusion qui permet d'envoyer un message sur tout le r\u00e9seau (appel\u00e9e \u00ab broadcast \u00bb). Ces deux adresses sont r\u00e9serv\u00e9es, elles ne peuvent pas \u00eatre utilis\u00e9es par une machine. Il reste donc  \\(2^8 - 2 = 254\\) adresses disponibles pour les machines sur le r\u00e9seau <code>192.168.1.0</code>, allant de <code>192.168.1.1</code> \u00e0 <code>192.168.1.254</code>. </p> <ul> <li> <p><code>192.168.1.0</code>    --&gt; r\u00e9serv\u00e9e pour l'adresse r\u00e9seau</p> </li> <li> <p><code>192.168.1.1</code> </p> </li> <li> <p>...</p> </li> <li> <p><code>192.168.1.254</code></p> </li> <li> <p><code>192.168.1.255</code> --&gt; r\u00e9serv\u00e9e pour l'adresse de diffusion (broadcast)</p> </li> </ul> <p>Pour des raisons de calcul binaire (les \u00ab <code>1</code> \u00bb du masque sont contigus), les masques de sous r\u00e9seau ne peuvent prendre que les valeurs suivantes : <code>0</code> ; <code>128</code> ; <code>192</code> ; <code>224</code> ; <code>240</code> ; <code>248</code> ; <code>252</code> ; <code>254</code> ; <code>255</code>.</p> <p>Une autre notation souvent utilis\u00e9e, la notation CIDR, consiste \u00e0 noter directement en d\u00e9cimal le nombre de bits <code>1</code> du masque \u00e0 la fin de l'adresse IP. Ainsi <code>192.168.25.0/255.255.255.0</code> peut aussi \u00e9crire <code>192.168.25.0/24</code>, car le masque r\u00e9seau est sur 24 bits. De m\u00eame <code>10.0.0.0/255.0.0.0</code> peut aussi s'\u00e9crire <code>10.0.0.0/8</code> et <code>192.168.1.192/255.255.255.240</code> peut s'\u00e9crire <code>192.168.1.192/28</code>.</p> <p>Il est facile d'identifier les parties r\u00e9seau et machine d'une adresse IPv4 quand le masque ne comporte que des 255 et des 0, ou un multiple de 8 en notation CIDR, mais ce n'est pas aussi simple pour les autres valeurs de masque -- <code>128</code> ; <code>192</code> ; <code>224</code> ; <code>240</code> ; <code>248</code> ; <code>252</code> ; <code>254</code> -- il faut alors \"d\u00e9couper\" un octet ! Prenons l'exemple de l'adresse <code>192.168.1.192/255.255.255.240</code> ou <code>192.168.1.192/28</code> en notation CIDR : </p> <p>Prenons l'exemple d'une machine dont l'adresse IP serait <code>192.168.1.205/255.255.255.240</code> ou <code>192.168.1.205/28</code>. A quel r\u00e9seau appartient-elle ?  Quelles sont les autres adresses IP disponibles sur le m\u00eame r\u00e9seau ?</p> <ul> <li> <p>L'adresse IP <code>192.168.1.205</code> s'\u00e9crit en binaire <code>11000000.10101000.00000001.11001101</code>. </p> </li> <li> <p>Le masque IP <code>255.255.255.240</code> s'\u00e9crit en binaire <code>11111111.11111111.11111111.11110000</code>. </p> </li> </ul> <p>Dans ce cas, la partie r\u00e9seau est d\u00e9termin\u00e9e par les 28 premiers bits de l'adresse (ceux qui sont \u00e0 <code>1</code>). Elle est obtenue par un <code>ET</code> logique entre l'adresse IP et son masque. Tous les bits de l'adresse qui correspondent \u00e0 un <code>1</code> du masque sont gard\u00e9s, les autres sont remplac\u00e9s par des <code>0</code> : </p> <code>___________R\u00e9seau_____________|Machine</code> IP <code>192.168.1.205</code> <code>11000000.10101000.00000001.1100|1101</code> Masque <code>255.255.255.240</code> <code>11111111.11111111.11111111.1111|0000</code> R\u00e9seau <code>192.168.1.192</code> <code>11000000.10101000.00000001.1100|0000</code> <p>La partie r\u00e9seau de l'adresse est donc <code>11000000.10101000.00000001.11000000</code> autrement dit <code>192.168.1.192</code>.  Les adresses disponibles sur ce r\u00e9seau sont donc :</p> <ul> <li> <p><code>11000000.10101000.00000001.1100|0000</code> c'est-\u00e0-dire <code>192.168.1.192</code>  --&gt; r\u00e9serv\u00e9e pour l'adresse r\u00e9seau</p> </li> <li> <p><code>11000000.10101000.00000001.1100|0001</code> c'est-\u00e0-dire <code>192.168.1.193</code></p> </li> <li> <p><code>11000000.10101000.00000001.1100|0010</code> c'est-\u00e0-dire <code>192.168.1.194</code></p> </li> <li> <p>...</p> </li> <li><code>11000000.10101000.00000001.1100|1101</code> c'est-\u00e0-dire <code>192.168.1.205</code>  --&gt; notre machine</li> <li><code>11000000.10101000.00000001.1100|1110</code> c'est-\u00e0-dire <code>192.168.1.206</code></li> <li><code>11000000.10101000.00000001.1100|1111</code> c'est-\u00e0-dire <code>192.168.1.207</code>  --&gt; r\u00e9serv\u00e9e pour l'adresse de diffusion (broadcast)</li> </ul> <p>La machine appartient donc au r\u00e9seau <code>192.168.1.192/28</code>. Les adresses diponbibles pour des machines sur ce r\u00e9seau vont de <code>192.168.1.193</code> \u00e0 <code>192.168.1.206</code>, il y en a donc \\(2^4 - 2 = 14\\).</p> <p>Exercice corrig\u00e9</p> <p>On donne l'adress IPv4 d'une machine <code>192.168.2.60/25</code>. D\u00e9terminer l'adresse de ce r\u00e9seau et les adresses possibles des autres machines sur ce r\u00e9seau.</p> R\u00e9ponse <p>Ecrivons l'adresse IP en binaire et s\u00e9parons la partie r\u00e9seau (les 25 premiers bits) de l apartie machine (les 7 bits suivants) : </p> <code>___________R\u00e9seau____________|Machine</code> IP <code>192.168.2.60</code> <code>11000000.10101000.00000010.0|0111100</code> Masque 25 bits <code>11111111.11111111.11111111.1|0000000</code> R\u00e9seau <code>192.168.1.192</code> <code>11000000.10101000.00000010.0|0000000</code> <p>Les adresses disponibles sur ce r\u00e9seau sont donc :</p> <ul> <li><code>11000000.10101000.00000010.0|0000000</code> c'est-\u00e0-dire <code>192.168.2.0</code> (adresse r\u00e9seau)</li> <li><code>11000000.10101000.00000010.0|0000001</code> c'est-\u00e0-dire <code>192.168.2.1</code></li> <li><code>11000000.10101000.00000010.0|0000010</code> c'est-\u00e0-dire <code>192.168.2.2</code><ul> <li>...</li> </ul> </li> <li><code>11000000.10101000.00000010.0|1111110</code> c'est-\u00e0-dire <code>192.168.2.126</code></li> <li><code>11000000.10101000.00000010.0|1111111</code> c'est-\u00e0-dire <code>192.168.2.127</code> (adresse de diffusion (broadcast)) </li> </ul> <p>L'adresse du r\u00e9seau est <code>192.168.2.0/25</code>.</p> <p>Il y a \\(2^7 - 2 = 126\\) adresses machine disponibles, allant de <code>192.168.2.1</code> \u00e0 <code>192.168.2.126</code>.</p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/4-routage/#routage","title":"Routage","text":"<p>Pour que deux machines (ordinateurs, imprimantes, etc.) puissent communiquer entre elles, il faut qu'elles soient sur le m\u00eame r\u00e9seau, c'est-\u00e0-dire :</p> <ul> <li>physiquement connect\u00e9es (reli\u00e9es pas un c\u00e2ble, sur le m\u00eame bus, reli\u00e9s au m\u00eame commutateur ou switch, etc.) ; et</li> <li>logiquement sur le m\u00eame r\u00e9seau (avec la  m\u00eame adresse de r\u00e9seau).</li> </ul> <p>Mais comment faire pour communiquer entre machines qui sont sur des r\u00e9seaux diff\u00e9rents ?</p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/4-routage/#routeurs","title":"Routeurs","text":"<p>Cours</p> <p>Des machines qui ne sont pas sur un m\u00eame r\u00e9seau peuvent communiquer par le biais d'un ou plusieurs routeurs qui relayent (ou \u00ab commutent \u00bb) les paquets de donn\u00e9es vers les adresses IP d'un r\u00e9seau \u00e0 l'autre<sup>1</sup> . </p> <p>Chaque routeur dispose de plusieurs interfaces de cartes r\u00e9seaux permettant de communiquer sur plusieurs r\u00e9seaux<sup>2</sup>. </p> <p>Voici un exemple de plusieurs routeurs relayant des paquets de donn\u00e9es depuis un poste client  vers un serveur dans deux r\u00e9seaux locaux s\u00e9par\u00e9s.</p> <p> </p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/4-routage/#tables-de-routage","title":"Tables de routage","text":"<p>Quand un routeur re\u00e7oit un paquet de donn\u00e9es venant du client et destin\u00e9 au serveur, comment sait-il \u00e0 quel autre routeur faire suivre le paquet ? </p> <p>Cours</p> <p>Les  tables de routage  permettent d'acheminer les paquets de donn\u00e9es \u00e0 travers un r\u00e9seau vers leur destination finale.</p> <p>La table de routage d'un routeur, ou de n'importe quelle machine pr\u00e9sente sur un r\u00e9seau<sup>3</sup>, d\u00e9crit o\u00f9 envoyer les paquets de donn\u00e9es afin de les rapprocher de leur destination finale. Elle contient plusieurs lignes avec les informations suivantes :</p> <ul> <li> <p>Destination : l'adresse IP d'un r\u00e9seau ou le nom d'un routeur auquel se rapportent les informations de routage. </p> <p>Les paquets dont la destination n'est pas connue par le routeur suivent un chemin \u00ab par d\u00e9faut \u00bb, identfi\u00e9 dans la table par la destination D\u00e9faut ou <code>0.0.0.0</code>. </p> <p> Extrait de la table de routage de R1 avec la destination par d\u00e9faut </p> </li> <li> <p>Passerelle (ou gateway) :  le routeur voisin vers lequel transmettre les paquets pour les rapprocher de leur destination.</p> <ul> <li> <p>Une passerelle appartiennent toujours \u00e0 l'un des r\u00e9seaux connect\u00e9s au routeur.</p> </li> <li> <p>Il n'y a pas de passerelle quand l'adresse de destination est celle d'un routeur voisin ou d'un r\u00e9seau directement connect\u00e9.</p> </li> </ul> <p> Extrait de la table de routage de R1 avec les passerelles </p> </li> <li> <p>Interface : la carte d'interface r\u00e9seau utilis\u00e9e pour transmettre les paquets vers leur destination. </p> <p>Elle est souvent identifi\u00e9e par un nom d'interface, par exemple <code>eth0</code>, <code>eth1</code>, <code>wlan0</code>, etc., pour d\u00e9signer s'il s'agit de la premi\u00e8re ou de la seconde carte Ethernet, de la carte Wi-Fi,etc. </p> <p> Extrait de la table de routage de R1 avec les noms des interfaces </p> <p>Dans certains cas, c'est l'adresse IP du routeur sur le r\u00e9seau qui sert d'identifiant \u00e0 l'interface.</p> <p> Extrait de la table de routage de R1 avec les adresses IP des interfaces </p> </li> <li> <p>M\u00e9trique :  mesure \u00ab l'\u00e9loignement \u00bb qui s\u00e9pare un routeur d'un r\u00e9seau de destination. Plus la valeur est faible, meilleure est le chemin. </p> <p>Les diff\u00e9rents protocoles de routages (RIP, OSPF, etc.) utilisent des m\u00e9triques diff\u00e9rentes que l'on \u00e9tudie dans la suite de ce chapitre.</p> </li> </ul> <p>Voici un exemple de la table de routage de R1 (en utilisant le protocole RIP) :</p> <p> </p> <p>Toutes les machines sur un r\u00e9seau ont une table de routage.  On peut  observer la table de routage de son ordinateur avec : </p> <ul> <li><code>route print</code> (windows et cygwin) </li> <li><code>ip route</code> (linux)</li> </ul>"},{"location":"architectures-materielles-et-systemes-d-exploitation/4-routage/#routage_1","title":"Routage","text":"<p>Cours</p> <p>Le routage est le m\u00e9canisme par lequel des chemins sont s\u00e9lectionn\u00e9s dans un r\u00e9seau pour acheminer les donn\u00e9es de routeurs en routeurs jusqu'\u00e0 leur destination finale.</p> <p>Observons le trajet d'un paquet allant de l'ordinateur client <code>192.168.1.15</code> au serveur <code>192.168.5.100</code> dans le r\u00e9seau pr\u00e9c\u00e9dent.</p> <p> </p> <p>Au d\u00e9part, le paquet est envoy\u00e9 par l'ordinateur client <code>198.168.1.15</code>, sa table de routage ne connait pas l'adresse du serveur <code>192.168.5.100</code>, le paquet suit donc le chemin par d\u00e9faut, il est envoy\u00e9 par l'interface <code>198.168.1.15</code> de l'ordinateur \u00e0 la passerelle <code>192.168.1.1</code>, c'est-\u00e0-dire \u00e0 R1.</p> <p> </p> <p>Le paquet arrive sur le routeur R1. L'adresse du serveur n'est toujours pas connue de la table de routage de R1, le paquet suit \u00e0 nouveau le chemin par d\u00e9faut, il est envoy\u00e9 par l'interface <code>10.1.3.1</code> de R1 \u00e0 la passerelle <code>10.1.3.2</code>, c'est-\u00e0-dire \u00e0 R3. </p> <p> </p> <p>Le paquet arrive sur le routeur R3. Cette fois, l'adresse du r\u00e9seau <code>192.168.5.0/24</code> auquel appartient serveur est connue de la table de routage de R3, le paquet suit le chemin indiqu\u00e9 dans la table de routage, il est envoy\u00e9 par l'interface <code>10.1.5.1</code> de R3 \u00e0 la passerelle <code>10.1.5.2</code>, c'est-\u00e0-dire \u00e0 R5. </p> <p> </p> <p>Le paquet arrive sur le routeur R5, l'adresse du serveur de destination  <code>192.168.5.100</code> est directement accessible depuis R5 par son interface <code>192.168.5.1</code>, le paquet est envoy\u00e9 au serveur, il a atteint sa destination finale.</p> <p> </p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/4-routage/#role-des-protocoles-de-routage","title":"R\u00f4le des protocoles de routage","text":"<p>Le nombre de routeurs dans un r\u00e9seau est g\u00e9n\u00e9ralement trop grand pour configurer les tables de routage \u00e0 la main<sup>4</sup> et chaque fois qu'un routeur tombe en panne ou qu'une modification arrive (ajout d'une nouvelle liaison ou d'un nouveau routeur), il faudrait recalculer toutes les chemins et de mettre \u00e0 jour les tables de routage de chaque routeur.</p> <p>Alors comment \u00eatre s\u00fbr que les tables de routages seront toujours \u00e0 jour pour donner le meilleur chemin (le plus court, le plus pertinent, etc...) entre routeurs et pour que le paquet arrive \u00e0 destination sans se perdre et \u00eatre d\u00e9truit<sup>5</sup> ? </p> <p>Cours</p> <p>Un  protocole de routage permet aux routeurs d'\u00e9changer les informations sur le r\u00e9seau afin de mettre \u00e0 jour automatiquement leur table de routage pour d\u00e9terminer les meilleurs chemins possibles.</p> <p>Un algorithme permet de comparer les diff\u00e9rents chemins en utilisant une m\u00e9trique. Plus sa valeur est faible, plus le chemin jusqu'\u00e0 la destination finale sera jug\u00e9 rapide.</p> <p>Diff\u00e9rents protocoles de routage existent :</p> <ul> <li> <p>des protocoles \u00e0 vecteur de distances, tels que RIP, IGRP, utilisent la distance en nombre de routeurs ;</p> </li> <li> <p>des protocoles \u00e0 \u00e9tat de liens, tels qu'OSPF et IS-IS, utilisent le d\u00e9bit des connexions entre routeurs au sein d'un syst\u00e8me autonome.</p> </li> </ul>"},{"location":"architectures-materielles-et-systemes-d-exploitation/4-routage/#rip-protocole-a-vecteurs-de-distance","title":"RIP : protocole \u00e0 vecteurs de distance","text":"<p>Cours</p> <p>Le protocole RIP (Routing Information Protocol) est un protocole \u00e0 vecteur de distance qui minimise le nombre de routeurs utilis\u00e9s pour atteindre une destination finale.</p> <ul> <li> <p>La m\u00e9trique utilis\u00e9e est la distance calcul\u00e9e en nombre de sauts entre routeurs (hops) ou en nombre de routeurs travers\u00e9s<sup>6</sup>.</p> </li> <li> <p>Le nombre de sauts est limit\u00e9 \u00e0 15, les distances sup\u00e9rieures sont ignor\u00e9es.</p> </li> <li> <p>La bande passante (ou d\u00e9bit) de la liaison entre routeurs n'est pas prise en compte.</p> </li> </ul> <p>Par exemple, consid\u00e9rons la table de routage de R1 dans l'exemple pr\u00e9c\u00e9dent. Il faut 2 sauts pour aller de R1 \u00e0 R4 en passant par R2, mais 3 sauts en passant par R3 et R5. </p> <p>La ligne correspondant \u00e0 la destination R4 dans la table de routage de R1 sera donc le chemin passant par R2, celui passant par R3 et R5 n'est pas utilis\u00e9 :</p> <p> </p> <p>En calculant le nombre de sauts minimum pour atteindre tous les routeurs du r\u00e9seau depuis R1, on obtient la table de routage de R1 suivante :</p> <p> </p> <p>Noter que R2 et R3 sont directement connect\u00e9s \u00e0 R1, ils n'ont pas de passerelle. </p> <p>Jusqu'ici, seuls les routeurs ont \u00e9t\u00e9 pris en compte dans le calcul des nombres de sauts. Lorsque la table de routage comprend non seulement des routeurs, mais aussi des r\u00e9seaux, le calcul de la distance est un peu diff\u00e9rent. </p> <p>Une fois qu'un paquet arrive sur un routeur qui est sur le m\u00eame r\u00e9seau que la destination, c'est la technologie de ce r\u00e9seau (Ethernet ou autre) qui achemine le paquet \u00e0 sa destination finale<sup>7</sup>, ce n'est pas compt\u00e9 comme un saut de routage. Les informations de routage pour toutes les machines d'un r\u00e9seau sont donc les m\u00eames, c'est-\u00e0-dire ce sont celles du routeur sur lequel ce r\u00e9seau est conn\u00e9ct\u00e9<sup>8</sup>. </p> <p>Pour simplifier les calculs de distances vers des adresses de sous-r\u00e9seaux (autres que des routeurs), la m\u00e9trique peut aussi \u00eatre mesur\u00e9e en nombre de de routeurs travers\u00e9s. </p> <p> </p> <p>\u00c0 noter :</p> <ul> <li> <p>La distance depuis R1 aux r\u00e9seaux qui lui sont directement connect\u00e9s, <code>192.168.1.0/24</code> et <code>10.1.3.0/30</code>, ainsi que toutes les machines sur ces r\u00e9seaux (sauf R3 m\u00eame s'il appartient \u00e0 ce dernier r\u00e9seau !) est de 0 ! Il n'y a aucun routeur \u00e0 traverser pour les atteindre. </p> </li> <li> <p>La distance depuis R1 au r\u00e9seau <code>192.168.5.0/24</code> qui est connect\u00e9 sur une carte d'interface de R5 est la m\u00eame que celle entre R1 et R5, c'est-\u00e0-dire 2. Il y a 2 routeurs \u00e0 traverser pour atteindre les machines sur ce r\u00e9seau.</p> </li> </ul> <p>La table de routage de R1 avec les sous-r\u00e9seaux de destination se pr\u00e9sente alors de la fa\u00e7on suivante :</p> <p> </p> <p>Attention \u00e0 la confusion, la distance des r\u00e9seaux (et machines sur ces r\u00e9seaux autres que des routeurs) directement connect\u00e9s \u00e0 R1 est 0, mais la distance d'un routeur voisin de R1 est 1, m\u00eame si ce routeur est sur un r\u00e9seau connect\u00e9 \u00e0 R1 !<sup>9</sup></p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/4-routage/#mise-en-place-des-tables-de-routages-rip","title":"Mise en place des tables de routages RIP","text":"<p>Cours</p> <p>Avec le protocole RIP, chaque routeur recoit r\u00e9guli\u00e8rement (toutes les 30 secondes) de ses voisins des informations de routage sous la forme de couples (destination, distance), appel\u00e9s vecteurs de distance.</p> <p>Chaque routeur met \u00e0 jour sa propre table routage avec les informations qu'il re\u00e7oit de ses voisins en ne gardant que les chemins les plus avantageux (les autres chemins, plus longs, sont ignor\u00e9s)<sup>10</sup>.</p> <p>Remarques :</p> <ul> <li>Lorsqu'un routeur re\u00e7oit un couple (destination, distance), il augmente la distance de 1.</li> <li> <p>La distance maximale est de 15, la table de routage indique une distance vide ou \u00e9gale \u00e0 16 pour les destinations inconnues ou plus lointaines.</p> </li> <li> <p>Si les informations concernant une destination ne sont plus re\u00e7ues par un routeur pendant trois minutes, la destination est supprim\u00e9e de sa  table de routage (panne ou modification du r\u00e9seau).</p> </li> </ul> <p>Pour illustrer le fonctionnement du protocole RIP, voyons comment \u00e9voluent les tables de routage des routeurs R1, R2, R3 et R5  sur l'exemple pr\u00e9c\u00e9dent (les interfaces et les destinations par d\u00e9faut sont ignor\u00e9es par soucis de simplicit\u00e9): </p> <ol> <li> <p>Initialisation : Au d\u00e9but du protocole, les tables des routeurs sont initialis\u00e9es avec les informations concernant leurs voisins imm\u00e9diats, \u00e0 savoir les routeurs auxquels ils sont directement connect\u00e9s.</p> <p> </p> <p>La colonne \"passerelle\" est vide, chaque routeur peut atteindre ses voisins imm\u00e9diats directement. Toutes les distances sont de 1 puisque les voisins sont atteints par 1 saut.</p> </li> <li> <p>Premi\u00e8re mise \u00e0 jour : Chaque routeur envoie les informations de routage dont il dispose \u00e0 ses voisins et met \u00e0 jour sa propre table de routage avec les informations qu'il re\u00e7oit en ne gardant que les chemins les plus avantageux :</p> <p> </p> <p>R1 met \u00e0 jour sa table de routage avec les informations re\u00e7ues de R2 et R3 :</p> <ul> <li>Il re\u00e7oit de R2 un nouveau chemin vers R4 qui n'\u00e9tait pas connu, il ajoute R4 \u00e0 sa table de routage avec une passerelle R2 et une distance qui augmente de 1 puisqu'il faut un saut suppl\u00e9mentaire pour atteindre R4 depuis R1.</li> <li>Il re\u00e7oit de R3 deux nouveaux chemins vers R5 et R6 qui n'\u00e9taient pas connus, il les ajoute \u00e0 sa table de routage avec une passerelle  R3 et des distances aussi augment\u00e9es de 1.</li> <li>Il recoit des informations sur R2 et R3 qui sont d\u00e9j\u00e0 connus, il les ignore.</li> </ul> <p>De la m\u00eame fa\u00e7on, R2 ajoute \u00e0 sa table de routage de nouveaux chemins vers R5 et R6 qu'il recoit de R3, en indiquant une passerelle par R3 et un distance augement\u00e9e de 1. R3 ajoute \u00e0 sa table de routage les chemins vers R4 qu'il recoit de R2 (il aurait pu aussi prendre le chemin passant par R5, quand un routeur a le choix entre plusieurs chemins qui ont la m\u00eame distance, il en choisit un au hasard) et vers R7 qu'il recoit de R5. R\u00e9ciproquement, R5 ajoute les chemins vers R1 et R2 qu'il re\u00e7oit de R5.</p> </li> <li> <p>Seconde mise \u00e0 jour :  30 secondes apr\u00e8s la premi\u00e8re mise \u00e0 jour, le m\u00eame processus se r\u00e9p\u00e8te, toutes les informations de routage sont echang\u00e9es entre tous les routeurs voisins.</p> <p> </p> <p>Seuls R1 et R2 d\u00e9couvrent un nouveau chemin vers R7 qu'ils ne connaissaient pas, ils mettent \u00e0 jour leur table de routage avec cette nouvelle desitation, une passerelle par R5 et un distance augment\u00e9e de 1, c'est-\u00e0-dire 3.</p> <p>A ce stade, tous les routeurs ont une \"vision\" compl\u00e8te de ce r\u00e9seau avec les meilleurs chemins \u00e0 suivre pour acheminer les paquets. Les \u00e9changes suivants (toutes les 30 secondes) ne modifient pas les tables de routage jusqu'\u00e0 ce qu'un changement intervienne dans le r\u00e9seau (routeur ou liaison en panne, nouveau r\u00e9seau connect\u00e9, etc.).</p> </li> <li> <p>panne entre R1 et R3 : Quand une panne appara\u00eet sur le r\u00e9seau, par exemple si la liaison entre R1 et R3 est coup\u00e9e, les deux routeurs ne recoivent plus aucune information de l'un et l'autre, ils suppriment les chemins correspondant au bout de 3 minutes.</p> <p>La destination R3 est supprim\u00e9e de la table de routage de R1, ainsi les destinations R5, R6 et R7 dont la passerelle \u00e9tait R3, elles ne sont plus accessibles en passant par R3. R\u00e9ciproquement la destination R1 est supprim\u00e9e de la table de routage de R3.</p> <p> </p> <p>\u00c0 la mise \u00e0 jour suivante, les tables de routage de R1 et R3 sont mises \u00e0 jour avec les informations re\u00e7ues de R2. Les destinations R3, R5, R6 et R7 appara\u00eessent \u00e0 nouveau dans la table de routage de R1, cette fois \u00e0 travers la passerelle R2, avec une distance augment\u00e9e de 1. Et R1 est \u00e0 nouveau dans la table de routage de R3, mais aussi en passant par la passerelle R2. Le traffic entre R1 et R3 est maintenant d\u00e9tourn\u00e9 par R2.</p> <p> </p> </li> </ol> <p>Si le protocole RIP est simple et efficace pour les petits r\u00e9seaux, il montre ses limites pour de plus grands r\u00e9seaux avec des temps de mise \u00e0 jour longs (15 x 30 = 450 secondes pour recevoir les informations des routeurs les plus \u00e9loign\u00e9s) et parce que les liaisons avec un d\u00e9bit beaucoup plus rapide que d'autres ne sont pas favoris\u00e9es. </p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/4-routage/#ospf-protocole-a-etat-de-liens","title":"OSPF: protocole \u00e0 \u00e9tat de liens","text":"<p>Cours</p> <p>Le protocole OSPF (Open Shortest Path First) est un protocole \u00e0 \u00e9tats de liens qui favorise les liaisons les plus rapides entre routeurs pour atteindre une destination. La m\u00e9trique est inversement proportionnelle \u00e0 la bande passante (ou d\u00e9bit)<sup>11</sup> d'une liaison, une bande passante plus \u00e9lev\u00e9e indique un co\u00fbt plus faible.</p> <ul> <li> <p>La m\u00e9trique correspond \u00e0 la somme des co\u00fbts :    \\(co\u00fbt = \\dfrac{10^8}{d}\\)     o\u00f9 \\(d\\) est la bande passante est exprim\u00e9e en \\(bit/s\\). Cela correspond \u00e0 un co\u00fbt de 1 pour une bande passante de 100 Mbits/s.</p> </li> <li> <p>Le num\u00e9rateur est parfois diff\u00e9rent pour prendre en compte des bandes passantes plus ou moins \u00e9l\u00e9v\u00e9es, par exemple pour des r\u00e9seaux \u00e0 bandes passantes \u00e9lev\u00e9es on trouvera \\(10^9\\) (c'est-\u00e0-dire un cout de 1 pour 1 Gbit/s).</p> </li> <li> <p>Le nombre de routeurs travers\u00e9s n'a pas d'importance.</p> </li> </ul> <p>bit par seconde</p> <p>\u00ab bit/s \u00bb s\u00e9crit aussi \u00ab b/s \u00bb ou \u00ab bps \u00bb.</p> <p>Principales unit\u00e9s de bandes passantes utilis\u00e9es :</p> Unit\u00e9 Notation Valeur 1 kilobit par seconde 1 kbit/s 1 000 bit/s = \\(10^3\\) bit/s 1 m\u00e9gabit par seconde 1 Mbit/s 1 000 000 bit/s = \\(10^6\\) bit/s 1 gigabit par seconde 1 Gbit/s 1 000 000 000 bit/s = \\(10^9\\) bit/s 1 terabit par seconde 1 Tbit/s 1 000 000 000 000 bit/s = \\(10^{12}\\) bit/s <p>Quelques exemples de calculs de co\u00fbts pour diff\u00e9rentes bandes passantes :</p> Technologie Bande passante Bande passante (bit/s) Co\u00fbt Ethernet 10 Mbit/s \\(10 \\times 10^6 = 10^7\\) \\(\\dfrac{10^8}{10^7}=10\\) Fast Ethernet 100 Mbit/s \\(100 \\times 10^6 = 10^8\\) \\(\\dfrac{10^8}{10^8}=1\\) Fibre optique (FFTH)) 1 Gbit/s \\(10^9\\) \\(\\dfrac{10^8}{10^9}=0,1\\) <p>Quand la bande passante n'est pas un multiple de 10, le calcul (sans calculatrice) est un peu plus compliqu\u00e9, par exemple pour une liaison satellite \u00e0 50 Mbits/s : \\(\\dfrac{10^8}{50 \\times 10^6}= \\dfrac{100 \\times 10^6}{50 \\times 10^6}= \\dfrac{100 }{50}=2\\)</p> <p> Le protocole OSPF arrondit en principe les co\u00fbts \u00e0 l'entier sup\u00e9rieur, par exemple ici le co\u00fbt de la fibre optique serait arrondi 1, mais ils ne sont pas toujours arrondis dans les exercices de baccalaur\u00e9at<sup>12</sup> !</p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/4-routage/#zones","title":"Zones","text":"<p>Les grands r\u00e9seaux, comme internet,  sont segment\u00e9s en plusieurs zones autonomes (ou areas), reli\u00e9es entre elles par une zone principale (appel\u00e9e backbone). Les routeurs sont de deux types: </p> <ul> <li> <p>Des routeurs internes \u00e0 une zone ou routeurs IR (Internal Routers) \u00e0 l'int\u00e9rieur d'une m\u00eame zone connaissent tous les m\u00eames informations sur l'\u00e9tat des liens de leur zone uniquement. </p> </li> <li> <p>Des routeurs de fronti\u00e8re de zone ou routeurs ABR (Area Border Router) connectent une zone \u00e0 la backbone. Ils connaissent les \u00e9tats de liens de toutes les zones diff\u00e9rentes qui leur sont connect\u00e9es. </p> </li> </ul> <p>Exemple : R3 et R6 sont des ABR</p> <p> </p> <p>La communication entre zones est limit\u00e9e \u00e0 des \u00e9changes d'information de routage pour connecter les zones entre elles uniquement, les calculs de chemins ne s'op\u00e8rent qu'au sein d'une m\u00eame zone. Les routeurs d'une zone ne sont pas affect\u00e9s par les changements intervenus dans une autre zone.</p>"},{"location":"architectures-materielles-et-systemes-d-exploitation/4-routage/#mise-en-place-des-tables-de-routages-ospf","title":"Mise en place des tables de routages OSPF","text":"<p>Cours</p> <p>Avec le protocole OSPF, tous les routeurs re\u00e7oivent les \u00e9tats de liens de toutes les liaisons de leur zone et calculent les meilleurs chemins (shortest path first) pour l'ensemble de la zone<sup>13</sup>.</p> <p>Les \u00e9changes entre routeurs et les calculs des meilleurs chemins ne sont fait que lors de l'initialisation ou en raison d'un changement des informations de routage.</p> <p> </p> <p>Pour mettre \u00e0 jour les tables de routage des routeurs IR \u00e0 l'int\u00e9rieur d'une zone, le protocole OSPF se d\u00e9compose en quatre \u00e9tapes. Prenons l'exemple de la zone 1 dans le r\u00e9seau pr\u00e9c\u00e9dent.</p> <ol> <li> <p>D\u00e9couverte des voisins : Lors de l'intialisation (ou suite \u00e0 un changement), chaque routeur produit un \u00e9tat des liens qui le relient \u00e0 ses voisins direct.</p> <p>Par exemple, les \u00e9tats de liens pour le routeur R2 avec ses voisins sont :</p> <p></p> </li> <li> <p>Inondation et mise \u00e0 jour : Tous les routeurs de la zone s'\u00e9changent leurs \u00e9tats de liens par inondation (flooding). A la fin de ces \u00e9changes, ils connaissent tous la topologie compl\u00e8te de la zone.</p> <p>Exemple : R2 met \u00e0 jour les \u00e9tats des liens avec les messages re\u00e7us des autres routeurs de sa zone.</p> <p></p> </li> <li> <p>Calcul des routes : Une fois les \u00e9tats de liens de tous les routeurs connus par tous, chaque routeur calcule les chemins les plus courts vers toutes les destinations de la zone et construit sa table de routage.</p> <p> </p> <p>Exemple : table de routage de R2</p> <p></p> <p>Il est plus rapide de passer par R1 que par R4 pour atteindre <code>10.1.4.0/30</code> et par R3 pour atteindre <code>10.1.5.0/30</code>.</p> </li> <li> <p>Maintenance des routes  : OSPF reste tr\u00e8s discret, il y a \u00e9change des nouveaux \u00e9tats de lien et calcul des chemins les plus courts seulement en cas de changement. </p> </li> </ol> <p>Une fois les tables de routage construites \u00e0 l'int\u00e9rieur d'une zone, les routeurs ABR communiquent les plus courts chemins entre zones pour les compl\u00e9ter. </p> <p>Exemple : table de routage de R2 apr\u00e8s les chemins re\u00e7us de R3</p> <p></p> <p>A noter : les routeurs ABR ne communiquent que les plus courts chemins, pas les \u00e9tats des liens, ils utilisent un protocole diff\u00e9rent (Border Gateway Protocol).</p> <p>OSPF pr\u00e9sente plusieurs avantages compar\u00e9 \u00e0 RIP: il est mieux adapt\u00e9 pour des r\u00e9seaux de plus grandes tailles, il favorise les liaisons les plus rapides pour acheminer les paquets le plus rapidement possible vers leur destination, les tables sont mises \u00e0 jour imm\u00e9diatement suite \u00e0 une panne, mais necessite des routeurs plus puissants capables de calculer les chemins les plus courts en utilisant l'algorithme de Dijkstra.</p> <ol> <li> <p>Contrairement aux  commutateurs (ou switch)) qui se basent sur les adresses MAC et  sont limit\u00e9s \u00e0 un r\u00e9seau local.\u00a0\u21a9</p> </li> <li> <p>Une box de Fournisseur d'Acc\u00e8s \u00e0 Internet (FAI) est un routeurs qui a souvent 3  interfaces : </p> <ul> <li>une interface connect\u00e9e au r\u00e9seau de l'op\u00e9rateur (FAI). </li> <li>une interface filaire (Ethernet) connect\u00e9e au r\u00e9seau local. </li> <li>une interface Wifi.</li> </ul> <p>\u21a9</p> </li> <li> <p>Toute machine connect\u00e9e \u00e0 un r\u00e9seau poss\u00e8de une table de routage, une imprimante, un t\u00e9l\u00e9phone, etc.\u00a0\u21a9</p> </li> <li> <p>Ce type de routage, dit \"routage statique\", qui consite \u00e0 configurer les tables de routage manuellement est encore utilis\u00e9 dans certains cas, par exemple dans de tr\u00e8s petits r\u00e9seaux.\u00a0\u21a9</p> </li> <li> <p>Le TTL (Time To Live)  indique le nombre de saut qu'il reste \u00e0 un paquet avant d'\u00eatre d\u00e9truit. A chaque fois qu'un router transmet un paquet, il r\u00e9duit son TTL jusqu'\u00e0 ce qu'il atteigne z\u00e9ro et soit d\u00e9truit\u00a0\u21a9</p> </li> <li> <p>\"it is common to use a metric that simply counts how many routers a message must go through\". Source https://www.rfc-editor.org/rfc/rfc2453.html.\u00a0\u21a9</p> </li> <li> <p>Once the message gets to a router that is on the same network as the destination, that network's own technology is used to get to the destination. Source https://www.rfc-editor.org/rfc/rfc2453.html.\u00a0\u21a9</p> </li> <li> <p>it is best to think of a routing entry for a network as an abbreviation for routing entries for all of the entities connected to that network.  This sort of abbreviation makes sense only because we think of networks as having no internal structure that is visible at the IP level.  Thus, we will generally assign the same distance to every entity in a given network. Source https://www.rfc-editor.org/rfc/rfc2453.html.\u00a0\u21a9</p> </li> <li> <p>La plupart des exercices de baccalaur\u00e9at utilisent des tables de routage avec des distances entre routeurs mesur\u00e9es en nombre de sauts (distances \u00e9gales \u00e0 1 ou plus), mais quelques-uns prennent en compte des distances de routeurs \u00e0 des r\u00e9seaux directement connect\u00e9s (\u00e9gales \u00e0 0) : 21-NSIJ2ME3, 22-NSIJ2NC1, 23-NSIJ1ME1, 24-sujet-0-a.\u00a0\u21a9</p> </li> <li> <p>Le chemin qui traverse le moins de routeurs est calcul\u00e9 par l'algorithme de Bellman-Ford.\u00a0\u21a9</p> </li> <li> <p>Les termes \"bande passante\" et \"d\u00e9bit\" sont diff\u00e9rents m\u00eame s'ils sont souvent confondus par abus de langage. La bande passante r\u00e9f\u00e8re \u00e0 la \u00ab capacit\u00e9 de transmission de donn\u00e9es, alors que le d\u00e9bit est la \u00ab quantit\u00e9 de donn\u00e9es effectivement transf\u00e9r\u00e9es. Pour illustrer la diff\u00e9rence dans un r\u00e9seau routier, la bande passante serait le nombre de voies d'une autoroute, alors que le d\u00e9bit serait la quantit\u00e9 de voitures qui y circulent.\u00a0\u21a9</p> </li> <li> <p>On trouve des co\u00fbts OSPF qui ne sont pas arrondis dans les exercices de baccalaur\u00e9at 23-NSIJ1LR1, 23-NSIJ2G11, 24-sujet_0-a et 24-NSIJ2PO1.\u00a0\u21a9</p> </li> <li> <p>Les chemins les plus courts sont calcul\u00e9s par l'algorithme de Dijkstra.\u00a0\u21a9</p> </li> </ol>"},{"location":"bases-de-donnees/","title":"Bases de donn\u00e9es","text":"<p>Comme vu en classe de premi\u00e8re, il est possible de stocker et manipuler des donn\u00e9es structur\u00e9es dans diff\u00e9rents formats : tableaux de tableaux, tableaux de dictionnaires, fichiers CSV ou JSON, etc. Ces formats sont vite limit\u00e9s quand on veut manipuler un grand nombre d'informations, en particulier lorsque celles-ci se trouvent r\u00e9parties dans plusieurs tables ou fichiers.</p> <p>Les premi\u00e8res bases de donn\u00e9es sont apparues dans les ann\u00e9es 1960 et se sont d\u00e9velopp\u00e9es en m\u00eame temps que l'informatique. Dans les ann\u00e9es 1980 est apparu le langage SQL sp\u00e9cialement con\u00e7u pour faire des requ\u00eates (s\u00e9lectionner, filtrer, mettre \u00e0 jour) sur les syst\u00e8mes de bases de donn\u00e9es.</p> <p>De nos jours les bases de donn\u00e9es sont omnipr\u00e9sentes : un smartphone utilise une base de donn\u00e9es pour stocker l\u2019information quand on passe d\u2019une app \u00e0 l\u2019autre, un site internet est souvent adoss\u00e9 \u00e0 une base de donn\u00e9es par exemple l\u2019e-commerce ou un blog.</p> <p>Cours</p> <p>Une base de donn\u00e9es repr\u00e9sente un ensemble ordonn\u00e9 de donn\u00e9es...</p> <p>... sur un sujet particulier, enregistr\u00e9 sur un syst\u00e8me informatique ou non, et repr\u00e9sentant une partie du monde.</p> <p>Quand une base de donn\u00e9es est stock\u00e9e dans un syst\u00e8me informatique, les donn\u00e9es ne sont en g\u00e9n\u00e9ral pas lisibles par un humain : il est n\u00e9cessaire d\u2019utiliser un syst\u00e8me de base de donn\u00e9es (SGBD) pour les exploiter.</p> <p>Dans une base de donn\u00e9es, les donn\u00e9es doivent \u00eatre organis\u00e9es de fa\u00e7on logique et utilisable pour les utilisateurs. C\u2019est la conception de la base de donn\u00e9es. Elle se fait en trois \u00e9tapes :</p> <ol> <li> <p>Mod\u00e9lisation conceptuelle : d\u00e9finition abstraite des donn\u00e9es et de comment elles s\u2019organisent.</p> </li> <li> <p>Conception logique : le mod\u00e8le relationnel (ou autres<sup>1</sup> ) mod\u00e9lise la structure selon laquelle les donn\u00e9es seront stock\u00e9es. </p> </li> <li> <p>Conception physique : l\u2019impl\u00e9mentation dans un logiciel informatique (un Syst\u00e8me de Gestion de Bases de Donn\u00e9es ou SGBD).</p> </li> </ol> <ol> <li> <p>Il exsite d'autres mod\u00e8le d'organisation de donn\u00e9es, par exemple sous forme d\u2019arbre (JSON, XML) ou de graphes.\u00a0\u21a9</p> </li> </ol>"},{"location":"bases-de-donnees/1-modelisation-conceptuelle/","title":"Mod\u00e9lisation conceptuelle","text":"<p>Prenons l\u2019exemple d\u2019une base de donn\u00e9es d\u2019auteurs et de livres.</p> <p>Cours</p> <p>Les donn\u00e9es ayant des caract\u00e9ristiques similaires sont regroup\u00e9es dans une entit\u00e9-type. </p> <p>Chaque occurrence d\u2019une entit\u00e9-types est appel\u00e9e une entit\u00e9<sup>1</sup>  (ou une instance ou encore un tuple).</p> <p>Par exemple, l'entit\u00e9-type <code>Auteur</code><sup>2</sup> ci-dessous regroupe tous les noms, pr\u00e9noms et dates de naissances des auteurs.  Victor Hugo et Emile Zola sont des entit\u00e9s, ce sont des occurrences de l\u2019entit\u00e9-type.</p> <p> </p> <p>Cours</p> <p>Les caract\u00e9ristiques d\u2019un entit\u00e9-type sont appel\u00e9es les attributs (ou propri\u00e9t\u00e9 type).</p> <p>On appelle domaine  d'un attribut l'ensemble des valeurs possibles d\u2019un attribut.</p> <p>L\u2019identifiant ou cl\u00e9 est un attribut (ou une combinaison de plusieurs attributs) qui permet d'identifier de mani\u00e8re unique une entit\u00e9.</p> <p> </p> <p>Ici,  le nom, le pr\u00e9nom et la date de naissance sont des attributs de l\u2019entit\u00e9\u2013type <code>Auteur</code>.  Le domaine de l'attribut <code>Date_naissance</code> d'un auteur est l'ensemble des dates comprises entre deux valeurs choisies. Plusieurs auteurs peuvent avoir le m\u00eame <code>Nom</code>, voire les m\u00eames <code>Nom</code> et <code>Pr\u00e9nom</code>, ici on choisit de leur donner un num\u00e9ro (par exemple leur num\u00e9ro de s\u00e9curit\u00e9 sociale) pour les identifier de fa\u00e7on unique. <code>Num_auteur</code> est une cl\u00e9 de l\u2019entit\u00e9-type <code>Auteur</code>. </p> <p>Cours</p> <p>Les entit\u00e9s-types sont li\u00e9es entre elles par des associations. </p> <p>Par exemple on peut associer un auteur avec l\u2019entit\u00e9 type <code>Pays</code> par l\u2019association <code>Originaire de</code> ou avec l\u2019entit\u00e9-type <code>Livre</code> par l\u2019association <code>Ecrit</code>. </p> <p>La mod\u00e9lisation conceptuelle aboutit \u00e0 une repr\u00e9sentation des donn\u00e9es sous la forme d\u2019un diagramme appel\u00e9 sch\u00e9ma conceptuel.</p> <p> </p> <p>Une association peut aussi avoir des attributs, par exemple ici <code>Ecrit</code> poss\u00e8de un attribut <code>NB_chapitre</code>.</p> <p>Pour finir le sch\u00e9ma conceptuel montre les cardinalit\u00e9s d\u2019une association pour indiquer le nombre d\u2019associations possibles entre les entit\u00e9s-types:</p> <p>Cours</p> <p>La cardinalit\u00e9 d\u2019une association entre deux entit\u00e9s-types indique le nombre d\u2019associations possibles entre ces entit\u00e9s-types. Elle peut prendre les valeurs:</p> <p>\u2022   <code>1, 1</code> lorsqu'une association ne permet \u00e0 une entit\u00e9 d'\u00eatre li\u00e9e qu'\u00e0 une, et une seule, entit\u00e9 d'une autre entit\u00e9-type, par exemple ici un auteur (une entit\u00e9 d\u2019<code>Auteur</code>) doit \u00eatre originaire d'un pays (une entit\u00e9 de <code>Pays</code>) et un seul.</p> <p>\u2022   <code>0, 1</code> lorsqu'une association  permet \u00e0 une entit\u00e9 d'\u00eatre li\u00e9e \u00e0 aucune, ou \u00e0 une mais pas plus entit\u00e9 d'une autre entit\u00e9-type.</p> <p>\u2022   <code>1, N</code> lorsqu'une association permet \u00e0 une entit\u00e9 d'\u00eatre li\u00e9e \u00e0 au moins une, ou \u00e0 plusieurs entit\u00e9s d'une autre entit\u00e9-type, par exemple un auteur peut avoir \u00e9crit un ou plusieurs livres (mais pas z\u00e9ro).</p> <p>\u2022   <code>0, N</code> lorsqu'une association permet \u00e0 une entit\u00e9 d'\u00eatre li\u00e9e \u00e0 aucune, \u00e0 une, ou \u00e0 plusieurs entit\u00e9s d'une autre entit\u00e9-type.</p> <ol> <li> <p>Par abus de langages on m\u00e9lange souvent les termes entit\u00e9s et entit\u00e9s-types.\u00a0\u21a9</p> </li> <li> <p>Par convention, les noms des entit\u00e9s-types sont au singulier.\u00a0\u21a9</p> </li> </ol>"},{"location":"bases-de-donnees/2-conception-logique-modele-relationnel/","title":"Conception logique : le mod\u00e8le relationnel","text":"<p>Le mod\u00e8le relationnel propos\u00e9 par Edgard Franck Codd en 1970 est la traduction d\u2019une mod\u00e9lisation conceptuelle en une conception logique. C\u2019est le mod\u00e8le de conception logique le plus utilis\u00e9 mais ce n\u2019est pas le seul, d\u2019autres existent.</p> <p>Cours</p> <p>Dans le mod\u00e8le relationnel, toutes les entit\u00e9s-types et les associations de la mod\u00e9lisation conceptuelle sont transform\u00e9es en tableaux \u00e0 deux dimensions, appel\u00e9s relations.</p> <p>Reprenons l'exemple pr\u00e9c\u00e9dent de l'entit\u00e9-type <code>Auteur</code>. Elle se traduit dans le mod\u00e8le relation par une relation <code>Auteur</code> dont les donn\u00e9es peuvent \u00eatre repr\u00e9sent\u00e9es sous la forme tableau, chaque ligne est appel\u00e9e un tuple et chaque colonne un attribut.</p> <p> </p> <p>Cours</p> <p>L\u2019ensemble des attributs d\u2019une relation forme le sch\u00e9ma de la relation.</p> <p>Le sch\u00e9ma d'une relation se repr\u00e9sente en pr\u00e9cisant les attributs et leur domaine :</p> <ul> <li> <p>sous forme textuelle :  <code>NomRelation(attribut1 : DOMAINE1, attribut2 : DOMAINE2\u2026.)</code>.</p> </li> <li> <p>sous forme graphique : </p> </li> </ul> <p> </p> <p>Le sch\u00e9ma de la relation d\u00e9crit une relation \u00ab vide \u00bb dans laquelle des donn\u00e9es peuvent ensuite \u00eatre stock\u00e9es (sous forme de tuples).</p> <p>Par exemple ici : <code>Auteur(Num_auteur : INT, Nom : TEXT, Prenom : TEXT, Date_naissance : DATE)</code>,</p> <p>ou encore de fa\u00e7on plus succincte en omettant le domaine des attributs :  <code>Auteur(Num_auteur, Nom, Prenom, Date_naissance)</code>.</p>"},{"location":"bases-de-donnees/2-conception-logique-modele-relationnel/#entite-type-representee-par-une-relation","title":"Entit\u00e9-type repr\u00e9sent\u00e9e par une relation","text":"<p>On transforme une entit\u00e9-type en relation avec les m\u00eames attributs. L\u2019identifiant devient la cl\u00e9 primaire. </p> <p>Cours</p> <p>Une cl\u00e9 primaire est un attribut (ou plusieurs) dont les valeurs permettent de distinguer les tuples les uns des autres de fa\u00e7on unique.</p> <p> </p> <p>La cl\u00e9 primaire est mise en \u00e9vidence souvent en \u00e9tant soulign\u00e9e, ou parfois avec le dessin d'une cl\u00e9, ou \u00e0 l'aide du symbole CP ou encore PK (pour primary key). </p> <p>Par exemple ici : <code>Pays(Nom_pays : TEXT, Population : INT, Superficie: INT)</code>. \u2003</p>"},{"location":"bases-de-donnees/2-conception-logique-modele-relationnel/#association-representee-par-une-relation","title":"Association repr\u00e9sent\u00e9e par une relation","text":""},{"location":"bases-de-donnees/2-conception-logique-modele-relationnel/#association-possedant-au-moins-une-cardinalite-01-ou-11","title":"Association poss\u00e9dant au moins une cardinalit\u00e9 0,1 ou 1,1","text":"<p>Dans ce cas, chaque tuple de la relation poss\u00e9dant une cardinalit\u00e9 <code>0,1</code> ou <code>1,1</code> est associ\u00e9 \u00e0 au plus un tuple de la seconde relation concern\u00e9e par l'association. Il suffit donc de ajouter un attribut dans la premi\u00e8re relation (celle poss\u00e9dant une cardinalit\u00e9 <code>0,1</code> ou <code>1,1</code>) pour identifier le tuple de la seconde relation. Cet attribut doit permettre d'identifier de fa\u00e7on unique le tuple de la seconde relation, il faut choisir une cl\u00e9 primaire de la seconde relation. Ce nouvel attribut devient une cl\u00e9 \u00e9trang\u00e8re de la premi\u00e8re relation.</p> <p>Dans notre exemple, un attribut <code>Nom_pays</code> peut-\u00eatre ajout\u00e9 dans la relation <code>Auteur</code>, cet attribut correspond \u00e0 la cl\u00e9 primaire de la relation <code>Pays</code>. <code>Nom_pays</code> est la cl\u00e9 primaire de la relation <code>Pays</code> et une cl\u00e9 \u00e9trang\u00e8re de la relation <code>Auteur</code>. </p> <p> </p> <p>A noter: Dans cet exemple, les  attributs <code>Nom_pays</code> ont le m\u00eame nom dans les deux relation <code>Auteur</code> et <code>Pays</code>, mais ils peuvent avoir des noms diff\u00e9rents.</p> <p>Cours</p> <p>Une cl\u00e9 \u00e9trang\u00e8re est un attribut qui est la cl\u00e9 primaire d'une autre relation. </p> <p>La cl\u00e9 \u00e9trang\u00e8re est mise en \u00e9vidence souvent avec le symbole #, ou en \u00e9tant soulign\u00e9e en pointill\u00e9, et parfois avec le symbole FK  (pour foreign key). </p> <p>Par exemple ici : <code>Auteur(Num_auteur : INT, #Nom_pays : TEXT,  Nom : TEXT, Prenom : TEXT, Date_naissance : DATE)</code>. </p>"},{"location":"bases-de-donnees/2-conception-logique-modele-relationnel/#association-sans-cardinalite-01-ou-11","title":"Association sans cardinalit\u00e9 0,1 ou 1,1","text":"<p>Dans ce cas, il faut transformer l\u2019association en une nouvelle relation avec deux attributs correspondant respectivement aux cl\u00e9s primaires de chacune des entit\u00e9s. </p> <p>Dans notre exemple, une nouvelle relation <code>Ecrit</code> est ajout\u00e9e possedant deux cl\u00e9s etrang\u00e8res <code>Num_ISBN</code> et <code>Num_auteur</code> correspondant aux deux cl\u00e9s primaires des relations <code>Livre</code> et <code>Auteur</code>. Le couple de ces deux cl\u00e9s \u00e9trang\u00e8res forment la cl\u00e9 primaire de la nouvelle relation <code>Ecrit</code>. </p> <p> </p> <p>Cours</p> <p>Une nouvelle relation est ajout\u00e9e, possedant deux cl\u00e9s \u00e9trang\u00e8res qui forment ensembles la cl\u00e9 primaire de cette relation.</p> <p>En notation textuelle, les deux cl\u00e9s \u00e9trang\u00e8res de la nouvelle relation sont indiqu\u00e9es par le caract\u00e8re # (ou soulign\u00e9es en pointill\u00e9) et elles sont toutes les deux soulign\u00e9es par un trait continu pour indiquer qu'elles forment ensembles la cl\u00e9 primaire.</p> <p>Dans notre exemple : <code>Ecrit(#Num_ISBN : INT, #Num_auteur : INT)</code>.</p>"},{"location":"bases-de-donnees/2-conception-logique-modele-relationnel/#schema-relationnel-dune-base-de-donnees","title":"Sch\u00e9ma relationnel d\u2019une base de donn\u00e9es","text":"<p>Cours</p> <p>Le sch\u00e9ma relationnel d\u2019une base de donn\u00e9es est compos\u00e9 de l\u2019ensemble des relations qui la composent avec leur sch\u00e9ma respectif, ainsi que les contraintes d\u2019int\u00e9grit\u00e9 associ\u00e9es \u00e0 ces relations.</p> <p>Ce qui donne dans notre exemple sous forme graphique :  </p> <p>et en notation textuelle : <code>Auteur(Num_auteur : INT, #Nom_pays : TEXT,  Nom : TEXT, Prenom : TEXT, Date_naissance : DATE)</code></p> <p><code>Pays(Nom_pays : TEXT, Population : INT, Superficie : INT)</code></p> <p><code>Livre(Num_ISBN : INT, Titre TEXT, Editeur TEXT, Annee DATE)</code></p> <p><code>Ecrit(#Num_ISBN : INT, #Num_auteur : INT)</code></p> <p>A noter :</p> <ul> <li>deux relations ne peuvent pas avoir le m\u00eame nom dans une base de donn\u00e9es (car une relation est identifi\u00e9e par son nom), et</li> <li>deux attributs ne peuvent pas avoir le m\u00eame nom dans une relation, mais</li> <li>deux attributs appartenant \u00e0 des relations diff\u00e9rentes peuvent avoir le m\u00eame nom sans \u00eatre li\u00e9s. Par exemple on aurait pu utiliser Nom au lieu de Nom_pays dans la relation Pays. \u2003</li> </ul>"},{"location":"bases-de-donnees/2-conception-logique-modele-relationnel/#les-contraintes-dintegrite","title":"Les contraintes d'int\u00e9grit\u00e9","text":"<p>Cours</p> <p>Il existe un certain nombre de r\u00e8gles \u00e0 respecter pour respecter l'int\u00e9grit\u00e9 d'une base de donn\u00e9es. Ces r\u00e8gles visent \u00e0 pr\u00e9server la coh\u00e9rence des donn\u00e9es et garantir une stabilit\u00e9 de notre base dans le temps.</p>"},{"location":"bases-de-donnees/2-conception-logique-modele-relationnel/#contraintes-dentite-ou-unicite-des-cles","title":"Contraintes d\u2019entit\u00e9 ou unicit\u00e9 des cl\u00e9s","text":"<p>Cours</p> <p>Il ne peut y avoir de doublons dans une relation. Toute relation doit poss\u00e9der un identifiant unique appel\u00e9 cl\u00e9 primaire.</p> <p>Le probl\u00e8me typique est l'utilisation de l'attribut Nom dans notre entit\u00e9 Auteur. Cet attribut ne peut d\u00e9finir de mani\u00e8re unique un auteur car plusieurs auteurs peuvent avoir le m\u00eame nom, ce ne peut pas \u00eatre une cl\u00e9 primaire. On utilise un attribut Num_auteur qui doit \u00eatre diff\u00e9rent pour chaque tuple afin que chaque auteur soit identifi\u00e9 par un num\u00e9ro unique. </p>"},{"location":"bases-de-donnees/2-conception-logique-modele-relationnel/#contraintes-referentielles","title":"Contraintes r\u00e9f\u00e9rentielles","text":"<p>Les cl\u00e9s primaires distinguent de mani\u00e8re unique chaque tuple mais peuvent \u00e9galement servir de r\u00e9f\u00e9rences dans d\u2019autres relations (cl\u00e9 \u00e9trang\u00e8res). Il faut veiller \u00e0 ce que les r\u00e9f\u00e9rences soient effectives. </p> <p>Cours</p> <p>Il n'est pas possible de d\u00e9finir une entit\u00e9 qui fait r\u00e9f\u00e9rence par une cl\u00e9 \u00e9trang\u00e8re \u00e0 une entit\u00e9 qui n'existe pas.</p> <p>Reprenons la relation <code>Ecrit(Num_ISBN, Num_auteur)</code> o\u00f9  <code>No_ISBN</code> et <code>Num_auteur</code> sont des cl\u00e9s \u00e9trang\u00e8res. Tous les livres doivent avoir un auteur connu. Pour ajouter un nouveau livre, il faut que l\u2019auteur soit existant et respectivement il doit \u00eatre impossible de supprimer un auteur si un de ses livres est encore pr\u00e9sent dans <code>Livre</code>.</p>"},{"location":"bases-de-donnees/2-conception-logique-modele-relationnel/#contraintes-de-domaine-et-contraintes-utilisateurs","title":"Contraintes de domaine et contraintes utilisateurs","text":"<p>Le domaine d'un attribut permet de pr\u00e9ciser le type de donn\u00e9es stock\u00e9es . </p> <p>Chaque SGBD offre ses propres types de donn\u00e9es qui regroupent en g\u00e9n\u00e9ral les types de donn\u00e9es habituels des langages de programmation (integer, bool\u00e9ens, float, string, etc.), et des types suppl\u00e9mentaires par exemple les dates ou des donn\u00e9es binaires comme des images ou vid\u00e9os (le type BLOB pour binary large object). </p> <p>Les noms des types de donn\u00e9es peuvent varier d'un SGBD \u00e0 l'autre, par exemple on trouve <code>CHAR</code>, <code>VARCHAR(x)</code> ou <code>TEXT</code> pour les cha\u00eene de caract\u00e8re. </p> <p>Cours</p> <p>En plus du type de donn\u00e9es, le domaine peut contenir des contraintes suppl\u00e9mentaires ou contraites utilisateurs sur les donn\u00e9es afin d'\u00e9viter les erreurs de saisies. </p> <p>Par exemple, le domaine :</p> <ul> <li> <p>une donn\u00e9e doit appartenir \u00e0 une liste (liste des communes de France par exemple) ; </p> </li> <li> <p>une donn\u00e9e num\u00e9rique doit \u00eatre born\u00e9e (\u00e2ge d'un personne) ; </p> </li> <li> <p>poss\u00e8de un nombre de caract\u00e8res d\u00e9fini \u00e0 l'avance (num\u00e9ro de s\u00e9curit\u00e9 sociale, code postal) ; </p> </li> <li> <p>etc.</p> </li> </ul>"},{"location":"bases-de-donnees/3-conception-physique-sgbd-relationnel/","title":"Conception physique : SGBD relationnel","text":"<p>L\u2019impl\u00e9mentation physique d'une base de donn\u00e9es se fait dans un logiciel informatique appel\u00e9 un Syst\u00e8me de Gestion de Bases de Donn\u00e9es (SGBD) ou Syst\u00e8me de Gestion de Bases de Donn\u00e9es Relationnelles (SGBDR) dans le cas d'un mod\u00e8le relationnel de base de donn\u00e9es.</p> <p>Cours</p> <p>Un  syst\u00e8me de gestion de base de donn\u00e9es ou  SGBD est le logiciel qui permet de g\u00e9rer une base de donn\u00e9es sur un support informatique.</p> <p>Exemples de SGBD parmi les plus connus : MySQL, PostegreSQL, SQLite, Oracle, sybase, Microsoft SQL Server, MS Access</p> <p> </p> <p>Un SGBD fait l'interface entre la base de donn\u00e9es et les utilisateurs. Il permet de g\u00e9rer la lecture, l'\u00e9criture ou la modification des donn\u00e9es contenues dans une base de donn\u00e9es, et garantit en particulier :</p> <ul> <li> <p>La persistance des donn\u00e9es : Un SGBD stocke les donn\u00e9es de mani\u00e8re permanente pour qu'elles soient toujous accessibles m\u00eame apr\u00e8s la fermeture du programme ou du syst\u00e8me ou en cas d'arr\u00eat inattendu du syst\u00e8me ou de perte d'alimentation.</p> </li> <li> <p>La gestion des acc\u00e8s concurrents : Un SGBD permet \u00e0 plusieurs utilisateurs de travailler sur la m\u00eame base de donn\u00e9es simultan\u00e9ment en g\u00e9rant les conflits qui peuvent survenir lorsque plusieurs utilisateurs tentent d'acc\u00e9der aux m\u00eames donn\u00e9es en m\u00eame temps. </p> </li> <li> <p>L'\u00e9fficacit\u00e9 de traitement des requ\u00eates : Un SGBD est capable de g\u00e9rer des volumes de donn\u00e9es importants, jusqu\u2019au p\u00e9taoctet (\\(10^{15}\\) octets), et de r\u00e9pondre rapidement aux requ\u00eates.</p> </li> <li> <p>La s\u00e9curisation des acc\u00e8s : Le SGBD offre des m\u00e9canismes de s\u00e9curit\u00e9 pour prot\u00e9ger les donn\u00e9es contre les acc\u00e8s non autoris\u00e9s en d\u00e9finissant des utilisateurs et des permissions d'acc\u00e8s \u00e0 la base de donn\u00e9es.</p> </li> </ul> <p>M\u00eame si historiquement beaucoup de SGBDR sont des entreprises commerciales utilisant chacune ses propres d\u00e9finitions, les termes suivants, qui sont un peu diff\u00e9rents de ceux d\u00e9finis dans le mod\u00e8le relationnel, sont commun\u00e9ment utilis\u00e9s :</p> <ul> <li>les relations sont impl\u00e9ment\u00e9es par des tables ;</li> <li>un tuple est appel\u00e9 une ligne de la table ;</li> <li>un attribut est (parfois) appel\u00e9 une colonne de la table.</li> </ul> <p>Il existe quelques diff\u00e9rences entre relations et tables, par exemple :</p> <ul> <li>L\u2019ordre des attributs dans une relation n\u2019a pas d\u2019importance alors que dans un SGBD les attributs d\u2019une table ont un ordre.</li> <li>Une table dans un SGBD peut ne pas avoir de cl\u00e9, alors qu\u2019une relation a forc\u00e9ment une cl\u00e9.</li> </ul> <p>Dans la suite de ce chapitre nous utilisons le SGBD SQLite avec l\u2019interface DB Browse. </p>"},{"location":"bases-de-donnees/4-langage-sql/","title":"Le langage SQL","text":"<p>Cours</p> <p>L\u2019interaction avec un SGBD se fait dans un language informatique d\u00e9di\u00e9 appel\u00e9 Structured Query Language ou SQL. </p> <p>SQL est un langage d\u00e9claratif, il n'est donc pas a proprement parl\u00e9 un langage de programmation, mais plut\u00f4t une interface standard pour acc\u00e9der aux bases de donn\u00e9es.</p> <p>Commen\u00e7ons par cr\u00e9er une nouvelle base de donn\u00e9es (menu \u00ab <code>New Database</code> \u00bb) enregistr\u00e9e sous le nom \u00ab <code>LivresAuteurs.db</code> \u00bb. La base de donn\u00e9es vide s\u2019ouvre :</p> <p></p>"},{"location":"bases-de-donnees/4-langage-sql/#creation-des-tables-mise-a-jour-et-suppression-des-tables","title":"Cr\u00e9ation des tables, mise \u00e0 jour et suppression des tables","text":"<p>Cr\u00e9ons une premi\u00e8re table qui repr\u00e9sente la relation: <code>Pays(Nom_pays, Population, Superficie)</code>.</p> <p>Cours</p> <p>La commande SQL pour cr\u00e9er une table est : </p> <pre><code>CREATE TABLE nom_table( \n    nom_colonne1    domaine1, \n    nom_colonne2    domaine2,\n    \u2026\n);\n</code></pre> <p></p> <p>Entrons la commande SQL suivante dans l\u2019onglet \u00ab <code>Execute SQL</code> \u00bb :</p> <pre><code>CREATE TABLE Pays (\n    Nom_pays    TEXT,\n    Population  INTEGER,\n    Superficie  INTEGER,\n    PRIMARY KEY(Nom_pays)\n);\n</code></pre> <p>\u00c0 noter : </p> <p>Le langage SQL n\u2019est pas sensible \u00e0 la casse, mais les requ\u00eates SQL sont \u00e9crites en majuscule par convention.   Les commandes SQL sont s\u00e9par\u00e9es par des point-virgules \u00ab <code>;</code> \u00bb</p> <p>Puis le bouton \u00ab<code>run</code>\u00bb  pour ex\u00e9cuter la commande :</p> <p></p> <p>La table cr\u00e9\u00e9e appara\u00eet dans l'onglet \u00ab <code>Database Structure</code> \u00bb avec ses colonnes. </p> <p>Noter l\u2019icone devant <code>Nom_pays</code> indiquant la cl\u00e9 primaire.</p> <p>SQLite permet de g\u00e9n\u00e9rer automatiquement les requ\u00eates pour cr\u00e9er les tables suivantes avec le menu \u00ab <code>Create Table</code> \u00bb.</p> <p>Maintenant que la table <code>Pays</code> a \u00e9t\u00e9 cr\u00e9\u00e9e, il est possible d'ajouter la table <code>Auteur(Num_auteur, #Nom_pays, Nom, Prenom, Date_naissance)</code>. Il n'\u00e9tait pas possible de cr\u00e9er la table <code>Auteur</code> avant <code>Pays</code> car elle contient une cl\u00e9 \u00e9trang\u00e8re (<code>Nom_ Pays</code>) qui fait r\u00e9f\u00e9rence \u00e0 <code>Pays</code> (contrainte d'int\u00e9grit\u00e9 r\u00e9f\u00e9rentielle).</p> <p>Cours</p> <p>Contrainte d'int\u00e9grit\u00e9 r\u00e9f\u00e9rentielle : Pour cr\u00e9er une nouvelle table contenant une cl\u00e9 \u00e9trang\u00e8re en r\u00e9f\u00e9rence \u00e0 une autre table, il faut que cette autre table soit cr\u00e9\u00e9e avant la nouvelle table.</p> <ul> <li> <p>Saisir le nom de la table (<code>Auteur</code>), les noms colonnes (<code>Num_auteur</code>, <code>Nom_pays</code>, <code>Nom</code>, <code>Prenom</code>, <code>Date_naissance</code>), leur domaine respectifs (<code>INTEGER</code>, <code>TEXT</code>, <code>TEXT</code>, <code>TEXT</code>, <code>NUMERIC</code>).</p> </li> <li> <p>Indiquer que la colonne <code>Nom</code> est une cl\u00e9 primaire en cliquant la case \u00ab <code>PK</code> \u00bb (pour Primary Key). Il est aussi possible de cliquer sur \u00ab <code>NN</code> \u00bb pour Not Null et \u00ab <code>U</code> \u00bb pour Unique. </p> </li> <li> <p>Indiquer que la colonne <code>Nom_pays</code> est une cl\u00e9 \u00e9trang\u00e8re dans  \u00ab <code>Foreign Key</code> \u00bb en indiquant la r\u00e9f\u00e9rence vers l'attribut <code>Nom_pays</code> de la table  <code>Pays</code>.</p> </li> </ul> <p>A noter :</p> <p>Les domaines propos\u00e9s par SQLite (d\u00e9pendent du SGBD) sont INTEGER pour les entiers, TEXT  pour les cha\u00eenes de caract\u00e8res, BLOB pour binary large object, REAL pour le flottants et enfin NUMERIC qui convertit en l\u2019un des types pr\u00e9c\u00e9dents en fonction de la valeur donn\u00e9e.</p> <p>La commande SQL est g\u00e9n\u00e9r\u00e9e automatiquement :</p> <pre><code>CREATE TABLE \"Auteur\" (\n    \"Num_auteur\"    INTEGER NOT NULL UNIQUE,\n    \"Nom_pays\"  TEXT,\n    \"Nom\"   TEXT,\n    \"Prenom\"    TEXT,\n    \"Date_naissance\"    NUMERIC,\n    FOREIGN KEY(\"Nom_pays\") REFERENCES \"Pays\"(\"Nom_pays\"),\n    PRIMARY KEY(\"Num_auteur\")\n); \n</code></pre> <p>De la m\u00eame fa\u00e7on, cr\u00e9ons la table <code>Livres(No_ISBN, Titre, Annee)</code>, par exemple en pr\u00e9cisant le domaine avec une contrainte utilisateur suppl\u00e9mentaire (menu \u00ab <code>Check</code> \u00bb ) afin que l\u2019ann\u00e9e soit un entier entre 1900 et 2100.</p> <pre><code>CREATE TABLE \"Livre\" (\n    \"Num_ISBN\"  TEXT,\n    \"Titre\" TEXT,\n    \"Editeur\"   TEXT,\n    \"Annee\" INTEGER NOT NULL CHECK(\"Annee\" BETWEEN 1900 AND 2100),\n    PRIMARY KEY(\"Num_ISBN\")\n);\n</code></pre> <p>Finalement ajoutons la table <code>Ecrit(#Num_ISBN, #Num_auteur)</code> :</p> <pre><code>CREATE TABLE \"Ecrit\" (\n    \"Num_ISBN\"  TEXT,\n    \"Num_auteur\"    INTEGER,\n    FOREIGN KEY(\"Num_auteur\") REFERENCES \"Auteur\"(\"Num_auteur\"),\n    FOREIGN KEY(\"Num_ISBN\") REFERENCES \"Livre\"(\"Num_ISBN\"),\n    PRIMARY KEY(\"Num_auteur\",\"Num_ISBN\")\n);\n</code></pre> <p>Cours</p> <p>La commande SQL <code>CREATE TABLE</code> permet de renseigner les cl\u00e9s primaires et \u00e9trang\u00e8res d'uen table :</p> <pre><code>CREATE TABLE nom_table( \n    nom_colonne1    domaine1, \n    nom_colonne2    domaine2,\n    \u2026\n    PRIMARY KEY(cle_primaire_1, cle_primaire_2, \u2026)    \n    FOREIGN KEY(cle_etrangere_1) REFERENCES nom_table(cle_etrangere_1),\n    \u2026\n);\n</code></pre> <p>Les commandes <code>ALTER TABLE</code> et <code>DROP TABLE</code> permettent de modifier ou supprimer une table. </p> <ul> <li>Admettons qu\u2019on veuille changer la base de donn\u00e9es pour ne plus enregistrer les pays : </li> </ul> <pre><code>DROP TABLE Pays;\n</code></pre> <ul> <li>Pour le chapitre suivant, on va supprimer la colonne Date_naissance :</li> </ul> <pre><code>ALTER TABLE Auteurs DROP COLUMN Date_naissance;\n</code></pre> <p>Le sch\u00e9ma de la base de donn\u00e9es complet a \u00e9t\u00e9 cr\u00e9\u00e9, il peut \u00eatre enregistr\u00e9 (menu  \u00ab <code>File/Save All</code> \u00bb).</p>"},{"location":"bases-de-donnees/4-langage-sql/#inserer-des-donnees-avec-insert","title":"Ins\u00e9rer des donn\u00e9es avec <code>INSERT</code>","text":"<p>Le sch\u00e9ma de notre base de donn\u00e9es a maintenant \u00e9t\u00e9 cr\u00e9\u00e9e dans le SGBD, mais \u00e0 ce stade elle est compl\u00e9tement \"vide\", elle ne contient aucune donn\u00e9es. Autrement dit les tables et les colonnes sont bien renseign\u00e9es mais il n'y a aucune ligne. C'est ce que l'on observe dans l\u2019onglet \u00ab <code>Browse Data</code> \u00bb.</p> <p></p> <p>La mise \u00e0 jour la base de donn\u00e9es se fait \u00e0 travers le SGBD par le biais de commandes SQL. Le SGBD garantit que les mises \u00e0 jour respectent le sch\u00e9ma et les contraintes d'int\u00e9grit\u00e9 de la base de donn\u00e9es.</p> <p>Cours</p> <p>La commande SQL pour ins\u00e9rer des donn\u00e9es est :</p> <pre><code>INSERT INTO nom_table \nVALUES (valeur_1,  valeur_2, \u2026);\n</code></pre> <p>\u00c0 noter : </p> <p>Les valeurs doivent \u00eatre dans l'ordre des attributs correspondant dans la table.</p> <p>Entrons la commande SQL dans l\u2019onglet \u00ab <code>Execute SQL</code> \u00bb :</p> <pre><code>INSERT INTO Pays VALUES (\"France\", 66, 643);\n</code></pre> <p>et observons le r\u00e9sultat dans \u00ab <code>Browse Data</code> \u00bb : </p> <p></p> <p>Il est aussi possible d'utiliser <code>INSERT INTO</code> pour ins\u00e9rer plusieurs lignes en m\u00eame temps : </p> <p><pre><code>INSERT INTO Pays\nVALUES \n(\"Allemagne\", 83, 357),\n(\"Espagne\", 46, 505);\n</code></pre> ou encore d'utiliser <code>INSERT INTO</code> en pr\u00e9cisant les colonnes, par exemple pour les renseigner dans un ordre diff\u00e9rent :</p> <p><pre><code>INSERT INTO Pays(Population, Superficie, Nom_pays)\nVALUES (330, 9834, \"Etats-Unis\"); \n</code></pre> ou de ne renseigner que certaines colonnes : <pre><code>INSERT INTO Pays(Nom_pays, Population)\nVALUES (\"Italie\", 60);\n</code></pre></p> <p></p> <p>Observons ce qui se passe si on essaie d\u2019ins\u00e9rer un doublon, c\u2019est-\u00e0-dire une ligne avec une cl\u00e9 primaire d\u00e9j\u00e0 existante, ici <code>Nom_pays(\"France\")</code> :</p> <pre><code>INSERT INTO Pays VALUES (\"France\", 67, 640);\n</code></pre> <p>Le SGBD g\u00e9n\u00e8re une erreur pour violation de la contrainte d\u2019entit\u00e9 :  <pre><code>Execution finished with errors.\nResult: UNIQUE constraint failed: Pays.Nom_pays\nAt line 1:\nINSERT INTO Pays VALUES (\"France\", 67, 640);\n</code></pre></p> <p>Cours</p> <p>Contrainte d\u2019entit\u00e9 : Il n'est pas possible d'ins\u00e9rer deux lignes avec la m\u00eame valeur de cl\u00e9 primaire (ou la m\u00eame combinaison de cl\u00e9s primaires) dans une table.</p> <p>Ins\u00e9rons maintenant un premier auteur :</p> <pre><code>INSERT INTO Auteur\nVALUES (0, \"Etats-Unis\", \"Twain\", \"Mark\");\n</code></pre> <p>et un livre :</p> <pre><code>INSERT INTO Livre VALUES (\"978-2228887359\",\"A la dure II\", \"Payot\", 1993);\nINSERT INTO Ecrit VALUES (\"978-2228887359\", 0);\n</code></pre> <p>Le SGBD teste toutes les contraintes d\u2019int\u00e9grit\u00e9. Par exemple si la valeur de la colonne <code>Annee</code> d\u2019un livre n\u2019est pas compris entre 1900 et 2100 :</p> <pre><code>INSERT INTO Livre VALUES (\"0000-00001\",\"Livre trop vieux\", \"\", 1890);\n</code></pre> <p>ou si une cl\u00e9 \u00e9trang\u00e8re n\u2019existe pas : </p> <pre><code>INSERT INTO Auteur VALUES (1, \"Russie\", \"Asimov\", \"Isaac\");\n</code></pre> <p>Cours</p> <p>Contrainte d\u2019int\u00e9grit\u00e9 r\u00e9f\u00e9rentielle : Il n'est pas possible d'ins\u00e9rer une ligne dans une table avec une valeur de cl\u00e9 \u00e9trang\u00e8re qui n\u2019existe pas dans la table \u00e0 laquelle elle fait r\u00e9f\u00e9rence.</p> <p>Pour la suite du chapitre, importons des donn\u00e9es plus compl\u00e8tes (25 lignes de Pays, 119 auteurs et 129 livres) dans la base de donn\u00e9es \u00e0 partir du fichier \u00ab <code>LivresAuteurs.sql</code> \u00bb.</p>"},{"location":"bases-de-donnees/4-langage-sql/#mettre-a-jour-des-donnees-avec-update","title":"Mettre \u00e0 jour des donn\u00e9es avec <code>UPDATE</code>","text":"<p>Admettons que la population de la ligne <code>France</code> a chang\u00e9e et qu'elle doit \u00eatre mise \u00e0 jour dans la base de donn\u00e9es : </p> <pre><code>UPDATE Pays \nSET Population = 67 \nWHERE Nom_Pays = \"France\";\n</code></pre> <p>Cours</p> <p>La commande SQL pour mettre \u00e0 jour des donn\u00e9es est :</p> <pre><code>UPDATE nom_table \nSET  nom_colonne1 = nouvelle_valeur\nWHERE nom_colonne2 =  identifiant;\n</code></pre> <p> Il ne faut pas oublier de pr\u00e9ciser la ligne ou les lignes \u00e0 modifier avec la clause <code>WHERE</code> au rique de modifier toutes les lignes de la table avec la <code>nouvelle_valeur</code>.</p> <p>Exercice corrig\u00e9</p> <p>Certains livres de la base de donn\u00e9es ont pour \u00e9diteur LGF/ Le Livre de Poche et d\u2019autres Le Livre de Poche. Quelle commande permet de tous les r\u00e9unir sous un m\u00eame nom d\u2019\u00e9diteur ?</p> R\u00e9ponse <p>UPDATE Livre SET Editeur = \"Le Livre de Poche\" WHERE Editeur = \"LGF/Le Livre de Poche\";</p>"},{"location":"bases-de-donnees/4-langage-sql/#supprimer-des-donnees-avec-delete","title":"Supprimer des donn\u00e9es avec <code>DELETE</code>","text":"<p>Cours</p> <p>La commande SQL pour supprimer des donn\u00e9es est :</p> <pre><code>DELETE FROM nom_table  \nWHERE nom_colonne =  identifiant;\n</code></pre> <p>Imaginons que l\u2019on veuille supprimer un livre ainsi que son auteur s\u2019il n\u2019a pas \u00e9crit d\u2019autres livres dans la base de donn\u00e9es. Par exemple le livre Akira dont l\u2019ISBN est 978-2723428262. </p> <p>Commen\u00e7ons par supprimer ce livre dans la table <code>Livre</code>: </p> <pre><code>DELETE FROM Livre WHERE Num_ISBN = '978-2723428262';\n</code></pre> <p>Cette commande renvoie une erreur : <pre><code>Result: FOREIGN KEY constraint failed\n</code></pre></p> <p>et c'est la m\u00eame chose si on essaye de supprimer cet auteur de la table <code>Auteur</code> :</p> <pre><code>DELETE FROM Auteur WHERE Num_auteur = 2;\n</code></pre> <p>en effet, ces deux commandes violent la contrainte d'int\u00e9grit\u00e9 r\u00e9f\u00e9rentielle sur la table <code>Ecrit</code>. Il faut proc\u00e9der dans l\u2019ordre et commencer par supprimer les lignes des autres tables qui font r\u00e9f\u00e9rence \u00e0 ce livre ou \u00e0 cet auteur, ici il y a une ligne dans la table <code>Ecrit</code> qui leur fait r\u00e9f\u00e9rence : </p> <pre><code>DELETE FROM Ecrit WHERE Num_ISBN = '978-2723428262';\nDELETE FROM Livre WHERE Num_ISBN = '978-2723428262';\nDELETE FROM Auteur WHERE Num_auteur = 2;\n</code></pre> <p>Cours</p> <p>Contrainte d\u2019int\u00e9grit\u00e9 r\u00e9f\u00e9rentielle : Il n'est pas possible de supprimer une ligne dans une table si elle est r\u00e9f\u00e9renc\u00e9e par la cl\u00e9 \u00e9trang\u00e8re d'une autre table. </p>"},{"location":"bases-de-donnees/4-langage-sql/#selectionner-des-donnees-avec-select","title":"S\u00e9lectionner des donn\u00e9es avec <code>SELECT</code>","text":"<p>Une fa\u00e7on simple de conna\u00eetre tous les livres de la base de donn\u00e9es est la commande (ou requ\u00eate) SQL suivante :</p> <pre><code>SELECT * FROM Livre;\n</code></pre> <p>Elle affiche toute la table. Pour voir seulement certaines colonnes, par exemple les titres et \u00e9diteurs des livres,  il faut \u00e9crire la requ\u00eate :</p> <pre><code>SELECT Titre, Editeur FROM Livre; \n</code></pre> <p>Cours</p> <p>La commande (ou requ\u00eate) SQL pour s\u00e9lectionner des donn\u00e9es est :</p> <pre><code>SELECT * FROM nom_table;\n</code></pre> <p>ou </p> <pre><code>SELECT nom_colonne_1, nom_colonne_1 \nFROM nom_table;\n</code></pre> <p>Il est aussi possible de changer l'affichage du nom des colonnes en leur donnant un alias avec <code>AS</code></p> <pre><code>SELECT Titre AS \"Titre du livre\", Editeur \nFROM Livre; \n</code></pre>"},{"location":"bases-de-donnees/4-langage-sql/#avec-where","title":"avec <code>WHERE</code>","text":"<p>Cours</p> <p>La clause WHERE suivi d\u2019une condition permet de restreindre le champ de recherche d'une requ\u00eate ::</p> <pre><code>SELECT * FROM nom_table\nWHERE nom_colonne1 = valeur;\n</code></pre> <p>Recherchons par exemple les livres publi\u00e9s chez l'\u00e9diteur \"J'ai Lu\" :</p> <pre><code>SELECT * FROM Livre \nWHERE Editeur=\"J'ai Lu\";\n</code></pre> <p>ou tous les livres publi\u00e9s apr\u00e8s 1990 : <pre><code>SELECT * FROM Livre \nWHERE Annee &gt; 1990;\n</code></pre></p> <p>il n'est pas possible de mettre plusieurs clauses <code>WHERE</code> dans une requ\u00eate, pour des requ\u00eates plus compliqu\u00e9es il faut uiliser les op\u00e9rateurs bool\u00e9ens  <code>AND</code> et <code>OR</code>, par exemple les livres publi\u00e9s entre 1990 et 2000, ou les livres publi\u00e9s en 1990 ou 2000 :</p> <pre><code>SELECT * FROM Livre WHERE Annee &gt;= 1990 AND Annee &lt;= 2000;    \nSELECT * FROM Livre WHERE Annee = 1990 OR Annee = 2000;    \n</code></pre> <p>De nombreuses autres possibilit\u00e9s existent pour affiner les requ\u00eates, par exemple utiliser des clauses \"floues\" avec <code>LIKE</code>, <code>NOT LIKE</code> et le symbole <code>%</code> ou encore <code>IN</code> (hors programme):</p> <pre><code>SELECT * FROM Livre WHERE Titre LIKE \"%Ast\u00e9rix%\";\nSELECT * FROM Livre WHERE Num_ISBN NOT LIKE '978%';\nSELECT * FROM Livre WHERE Editeur IN (\"J'ai Lu\", \"Flammarion\");\n</code></pre>"},{"location":"bases-de-donnees/4-langage-sql/#avec-distinct-et-order-by","title":"avec <code>DISTINCT</code> et  <code>ORDER BY</code>","text":"<p>Recherchons tous les \u00e9diteurs de la table <code>Livre</code> :</p> <p><pre><code>SELECT Editeur\nFROM Livre;\n</code></pre> Certains \u00e9diteurs appara\u00eessent plusieurs fois quand ils ont \u00e9dit\u00e9s plusieurs livres. Pour \u00e9viter ces r\u00e9p\u00e9titions il faut utiliser la clause <code>DISTINCT</code> :</p> <p><pre><code>SELECT DISTINCT Editeur\nFROM Livre;\n</code></pre> De la m\u00eame fa\u00e7on, <code>ORDER BY</code> permet de trier les r\u00e9sultats d'une requ\u00eate selon une colonne :</p> <p><pre><code>SELECT Nom_pays, Population\nFROM Pays \nORDER BY Population;\n</code></pre> Le tri se fait par d\u00e9faut en ordre croissant, mais il est possible de pr\u00e9ciser l'ordre voulu, <code>ASC</code> pour l'ordre croissant ou <code>DESC</code> pour l'ordre d\u00e9croissant : </p> <pre><code>SELECT Nom_pays, Population\nFROM Pays \nORDER BY Population DESC; \n</code></pre> <p>Cours</p> <p>La clause <code>DISTINCT</code> permet d'\u00e9viter le r\u00e9p\u00e9tition dans une requ\u00eate :</p> <pre><code>SELECT DISCTINCT nom_colonne\nFROM nom_table;\n</code></pre> <p>La clause <code>ORDER BY</code> permet de trier le resultat d'une requ\u00eate en ordre croissant (<code>ASC</code> par d\u00e9faut) ou decroissant (<code>DESC</code>) :</p> <pre><code>SELECT nom_colonne1, nom_colonne2\nFROM nom_table \nORDER BY nom_colonne;\n</code></pre>"},{"location":"bases-de-donnees/4-langage-sql/#avec-des-fonctions-daggregation-min-max-count-sum-et-avg","title":"avec des fonctions d'aggr\u00e9gation <code>MIN()</code>, <code>MAX()</code>, <code>COUNT()</code>, <code>SUM()</code> et <code>AVG()</code>","text":"<p>Cours</p> <p>Les fonctions d\u2019agr\u00e9gation <code>MIN()</code>, <code>MAX()</code>, <code>COUNT()</code>, <code>SUM()</code> et <code>AVG()</code> permettent d\u2019effectuer des op\u00e9rations statistiques dans une requ\u00eate : </p> <pre><code>SELECT MIN(nom_colonne)\nFROM Nom_table; \n</code></pre> <p>En voici quelques exemples :</p> <pre><code>SELECT COUNT(Titre) FROM Livre;\nSELECT COUNT(Editeur) FROM Livre; \nSELECT MIN(Population) AS Minimum FROM Pays;\nSELECT MIN(Population) AS Min, MAX(Population) as Max, AVG(Population) AS Moyenne FROM Pays;\n</code></pre> <p><code>GROUP BY</code> (hors programme) permet de regrouper certains r\u00e9sultats ensembles : <pre><code>SELECT Editeur, COUNT(Editeur) FROM Livre GROUP BY Editeur;\nSELECT Nom_pays, COUNT(Nom_pays) FROM Auteur GROUP BY Nom_pays;\n</code></pre></p>"},{"location":"bases-de-donnees/4-langage-sql/#requetes-imbriquees-ou-sous-requetes","title":"Requ\u00eates imbriqu\u00e9es (ou sous-requ\u00eates)","text":"<p>Une requ\u00eate du type<code>SELECT\u2026 FROM \u2026</code> renvoie une table comme r\u00e9sultat. Cette table peut tout \u00e0 fait \u00eatre utilis\u00e9e pour \u00e9crire de nouvelles requ\u00eates.</p> <p>Comment trouver le nom du pays qui a la plus petite population ? </p> <p>La plus petite population parmi la table <code>Pays</code> est  obtenue par :</p> <p><pre><code>SELECT MIN(Population) FROM Pays;\n</code></pre> Le resultat de cette requ\u00eate peut alors \u00eatre utilis\u00e9 comme une sous-requ\u00eate de : <pre><code>SELECT Nom_Pays, Population \nFROM Pays\nWHERE Population = (SELECT MIN(Population) FROM Pays);\n</code></pre></p> <p> SQLite est particuli\u00e8rment flexible avec les fonctions d'aggregation et permettait d\u2019\u00e9crire directement<sup>1</sup> :</p> <p><pre><code>SELECT Pays, MIN(Population) \nFROM Pays;\n</code></pre> Mais ce n\u2019est pas le cas de tous les SGBD. Il suffit de tester la requ\u00eate suivante pour comprendre que cette flexibilit\u00e9 est souvent \u00e0 \u00e9viter !</p> <pre><code>SELECT Pays, MIN(Population), MAX(Population) \nFROM Pays;\n</code></pre>"},{"location":"bases-de-donnees/4-langage-sql/#jointures","title":"Jointures","text":"<p>La requ\u00eate <code>SELECT * FROM Ecrit</code> nous renvoie la table des <code>Num_auteur</code> avec les <code>Num_ISBN</code> correspondant, mais comment afficher le nom et pr\u00e9nom de l\u2019auteur, plut\u00f4t que son num\u00e9ro ?</p> <p>Il faut croiser les informations provenant des tables <code>Ecrit</code> et <code>Auteur</code> ensembles. C\u2019est une jointure.</p> <p> </p> <p>Cours</p> <p>Pour s\u00e9lectionner des donn\u00e9es \u00e0 travers plusieurs tables, il faut r\u00e9aliser une jointure entre les tables avec <code>JOIN... ON...</code> <pre><code>SELECT nom_table1.nom_colonne1, nom_table2.nom_colonne2 \nFROM nom_table1\nJOIN nom_table2 \nON nom_table1.cle1 = nom_table2.cle_2;\n</code></pre></p> <p>Ce qui donne dans notre exemple<sup>2</sup> : <pre><code>SELECT Ecrit.Num_ISBN, Auteur.Nom, Auteur.Prenom \nFROM Ecrit\nJOIN Auteur\nON Ecrit.Num_auteur = Auteur.Num_auteur;\n</code></pre></p> <p>Quand il n\u2019y a pas d\u2019ambigu\u00eft\u00e9 sur les noms de colonne entre les deux tables, par exemple ici <code>Num_ISBN</code> n\u2019appara\u00eet que dans <code>Ecrit</code> et <code>Nom</code> et <code>Prenom</code> que dans <code>Auteur</code>, il est possible d\u2019\u00e9crire plus simplement : <pre><code>SELECT Num_ISBN, Nom, Prenom \nFROM Ecrit\nJOIN Auteur\nON Ecrit.Num_auteur = Auteur.Num_auteur;\n</code></pre></p> <p>Dans le cas o\u00f9 les noms de tables sont utilis\u00e9s, l\u2019utilisation des alias am\u00e9liore la lisibilit\u00e9 : <pre><code>SELECT E.Num_ISBN, A.Nom, A.Prenom \nFROM Ecrit AS E\nJOIN Auteur AS A \nON E.Num_auteur = A.Num_auteur;\n</code></pre></p> <p>Il est aussi possible d'ajouter des clauses habituelles, par exemple pour n'avoir que les auteurs fran\u00e7ais :  <pre><code>SELECT Ecrit.Num_ISBN, Auteur.Nom, Auteur.Prenom \nFROM Ecrit\nJOIN Auteur \nON Ecrit.Num_auteur = Auteur.Num_auteur\nWHERE Auteur.Nom_pays = \"France\";\n</code></pre></p> <p>Enfin, les noms des livres et de leurs auteurs de la table <code>Ecrit</code> s'obtiennent par une double jointure :</p> <pre><code>SELECT L.Titre, A.Nom, A.Prenom \nFROM Ecrit AS E\nJOIN Auteur AS A \nON E.Num_auteur = A.Num_auteur\nJOIN Livre AS L \nON E.Num_ISBN = L.Num_ISBN;\n</code></pre>"},{"location":"bases-de-donnees/4-langage-sql/#autres-types-de-jointures-hors-programme","title":"Autres types de jointures (hors programme)","text":"<p>La jointure avec <code>JOIN</code>, qui peut aussi s'\u00e9crire <code>INNER JOIN</code>, r\u00e9unit seulement les lignes qui apparaissent dans les deux tables :</p> <p> </p> <p>L\u2019ordre des tables n\u2019a donc pas d\u2019importance. Les deux requ\u00eates suivantes sont \u00e9quivalentes :</p> avec <code>...FROM Ecrit JOIN Auteur</code>avec <code>...FROM Auteur JOIN Ecrit</code> <pre><code>SELECT E.Num_ISBN, A.Nom, A.Prenom \nFROM Ecrit AS E\nJOIN Auteur AS A\nON E.Num_auteur = A.Num_auteur; \n</code></pre> <pre><code>SELECT E.Num_ISBN, A.Nom, A.Prenom \nFROM Auteur AS A\nJOIN Ecrit AS E\nON E.Num_auteur = A.Num_auteur;\n</code></pre> <p>Le r\u00e9sultat est le m\u00eame.</p> <p>Mais il existe aussi d\u2019autres types de jointures, <code>LEFT JOIN</code>, <code>RIGHT JOIN</code>, <code>FULL OUTER JOIN</code> (hors programme) qui permettent d\u2019obtenir des r\u00e9sultats diff\u00e9rents.</p> <p> </p> <p> </p> <p> </p>"},{"location":"bases-de-donnees/4-langage-sql/#resume-des-requetes-sql","title":"R\u00e9sum\u00e9 des requ\u00eates SQL","text":"<p>Les commandes SQL suivantes sont \u00e0 conna\u00eetre par c\u0153ur :</p> Action Commande SQL Ajouter des lignes dans une table <code>INSERT  INTO nom_table</code><code>VALUES (valeur1,  valeur2, \u2026);</code> Ajouter des lignes dans une table en pr\u00e9cisant les colonnes <code>INSERT  INTO nom_table(nom_colonne1,  nom_colonne2, ...)</code><code>VALUES (valeur1,  valeur2, \u2026);</code> Mettre \u00e0 jour une ligne <code>UPDATE  nom_table</code><code>SET  nom_colonne1 = valeur1,  nom_colonne2 = valeur2, \u2026</code><code>WHERE  certainesColonnes = certainesValeurs;</code> Supprimer une ligne <code>DELETE  FROM nom_table</code><code>WHERE   nom_colonne = valeur;</code> S\u00e9lectionner toutes les donn\u00e9es dans une table <code>SELECT  *  FROM  nom_table;</code> S\u00e9lectionner certaines colonnes <code>SELECT  nom_colonne1,  nom_colonne2,  ...</code><code>FROM  nom_table</code> S\u00e9lectionner certaines lignesavec <code>WHERE</code> <code>SELECT  ...</code><code>FROM  nom_table</code><code>WHERE nom_colonne = valeur</code> S\u00e9lectionner sans r\u00e9p\u00e9titionavec <code>DISTINCT</code> <code>SELECT  DISTINCT nom_colonne</code><code>FROM  nom_table</code> S\u00e9lectionner en triant les lignesavec <code>ORDER BY</code> <code>SELECT  ...</code><code>FROM  nom_table</code><code>ORDER BY nom_colonne [DESC]</code> S\u00e9lectionner avec les fonctions d'aggregat <code>MIN()</code>, <code>MAX()</code>, <code>COUNT()</code>, <code>SUM()</code>, <code>AVG()</code> <code>SELECT  MIN(nom_colonne)</code><code>FROM  nom_table</code> Afficher une jointure entre tables <code>SELECT  nom_table1.nom_col1, nom_table2.nom_col2,</code><code>FROM  nom_table1</code><code>JOIN  nom_table2</code><code>ON nom_table1.cle1 = nom_table2.cle2</code> <ol> <li> <p>Voir https://sqlite.org/lang_select.html#bare_columns_in_an_aggregate_query.\u00a0\u21a9</p> </li> <li> <p>Noter que <code>JOIN</code> a remplac\u00e9 l\u2019ancienne syntaxe pour les jointures avec <code>WHERE</code>  : <pre><code>SELECT nom_table1.nom_colonne1, nom_table2.nom_colonne2 \nFROM nom_table1, nom_table2\nWHERE nom_table1.cle1 = nom_table2.cle2;\n</code></pre></p> <p>Ce qui donnait dans notre exemple : <pre><code>SELECT Num_ISBN, Nom, Prenom \nFROM Ecrit, Auteur\nWHERE Ecrit.Num_auteur = Auteur.Num_auteur;\n</code></pre> \u21a9</p> </li> </ol>"},{"location":"bases-de-donnees/5-en-python/","title":"Utiliser une base de donn\u00e9es en Python","text":"<p>Dans certains cas, il est utile d'utiliser une base de donn\u00e9es dans une application programm\u00e9e en Python (ou autre). Par exemple si la quantit\u00e9 de donn\u00e9es \u00e0 manipuler est trop grande pour les structures de donn\u00e9es en m\u00e9moire comme les tableaux ou les dictionnaires. Ou encore si les donn\u00e9es doivent \u00eatre stock\u00e9es de fa\u00e7on permanente et ne pas dispara\u00eetre quand le programme se termine.</p> <p>Voyons comment exploiter notre base de donn\u00e9es SQLite LivresAuteurs.db et ex\u00e9cuter des requ\u00eates SQL depuis un programme Python.</p>"},{"location":"bases-de-donnees/5-en-python/#ouvrir-la-base-de-donnees","title":"Ouvrir la base de donn\u00e9es","text":"<p>Commen\u00e7ons par importer le module <code>sqlite3</code> dans un programme.</p> <p><pre><code>import sqlite3\n</code></pre> La premi\u00e8re chose \u00e0 faire ensuite est d'ouvrir le fichier de la base de donn\u00e9es (noter que si le fichier n'existe pas, une nouvelle base de donn\u00e9es sera cr\u00e9\u00e9e) :</p> <pre><code>bdd = sqlite3.connect(\"LivresAuteurs.db\")\n</code></pre> <p>puis de cr\u00e9er un curseur :</p> <p><pre><code>curseur = bdd.cursor()\n</code></pre> Ce curseur est un objet Python qui va nous permettre d'ex\u00e9cuter des requ\u00eates et de r\u00e9cup\u00e9rer les r\u00e9sultats de ces requ\u00eates.</p>"},{"location":"bases-de-donnees/5-en-python/#executer-des-requetes-de-selection","title":"Ex\u00e9cuter des requ\u00eates de s\u00e9lection","text":"<p>Ex\u00e9cutons maintenant notre premi\u00e8re requ\u00eate avec la m\u00e9thode <code>execute()</code> du curseur. La requ\u00eate SQL est une cha\u00eene de caract\u00e8res pass\u00e9e en param\u00e8tre \u00e0 <code>execute()</code>.</p> <pre><code>requete = \"SELECT * FROM Pays;\"\ncurseur.execute(requete)\n</code></pre> <p>La curseur permet ensuite de visualiser le r\u00e9sultat de cette requ\u00eate par l'une ou l'autre de ces m\u00e9thodes :</p> <ul> <li><code>fetchone()</code> pour r\u00e9cup\u00e9rer une ligne du r\u00e9sultat puis avancer le curseur d'un cran</li> <li><code>fetchall()</code> pour r\u00e9cup\u00e9rer d'un coup tous les lignes du r\u00e9sultat.</li> </ul> <p>Pour mieux comprendre comment fonctionne le curseur, ex\u00e9cutons plusieurs fois l'instruction suivante dans la console : </p> <pre><code>&gt;&gt;&gt; curseur.fetchone()\n</code></pre> <p>On constate que le curseur permet de se d\u00e9placer une ligne apr\u00e8s l'autre dans le r\u00e9sultat de la requ\u00eate. </p> <p>Essayons maintenant <code>fetchall()</code> pour r\u00e9cup\u00e8rer toutes les lignes du r\u00e9sultats dans un seul p-uplet.</p> <pre><code>&gt;&gt;&gt; curseur.fetchall()\n</code></pre> <p>On constate qu'il manque les premi\u00e8res lignes. En effet, elles ont d\u00e9j\u00e0 \u00e9t\u00e9 lues par les premiers <code>fetchone()</code> ex\u00e9cut\u00e9es, le curseur s'est d\u00e9plac\u00e9 apr\u00e8s. Et si on r\u00e9ex\u00e9cute une nouvelle fois la m\u00e9thode <code>fetchall()</code> du curseur, celle-ci ne renvoie plus rien, le premier <code>fetchall()</code> a positionn\u00e9 le curseur apr\u00e8s la derni\u00e8re ligne du r\u00e9sultat. Pour retrouver \u00e0 nouveau toutes les lignes du r\u00e9sultat, il faut r\u00e9ex\u00e9cuter la requ\u00eate. </p>"},{"location":"bases-de-donnees/5-en-python/#construire-des-requetes-a-partir-de-variables-python","title":"Construire des requ\u00eates \u00e0 partir de variables python","text":"<p>Construisons un programme qui affiche les informations d'un auteur dont on demande le nom. La requ\u00eate est une cha\u00eene de caract\u00e8re, on est tent\u00e9 de la construire par concat\u00e9nation de cha\u00eenes :</p> <pre><code>nom = imput(\"entrez un nom d'auteur\")\nrequete = \"SELECT Prenom FROM Auteur WHERE Nom =\" + nom\ncurseur.execute(requete)\nprint(curseur.fetchone())\n</code></pre> <p> Attention, c'est une tr\u00e8s mauvaise approche qui conduira \u00e0 de nombreux probl\u00e8mes, et en particulier des injections SQL ! Que se passerait-il si l'utilisateur entrait une requ\u00eate SQL pour nom d'auteur ?</p> <p></p> <p>La bonne approche consiste \u00e0 constuire la requ\u00eate avec des <code>?</code> pour d\u00e9signer des variables que l'on veut ins\u00e9rer dans la requ\u00eate et \u00e0 passer en second param\u00e8tre la liste des valeurs \u00e0 substituer dans la requ\u00eate :</p> <pre><code>nom = imput(\"entrez un nom d'auteur\")\nrequete = \"SELECT Prenom FROM Auteur WHERE Nom = ?\"\ncurseur.execute(requete, [nom])\nprint(curseur.fetchone())\n</code></pre>"},{"location":"donnees-en-tables/","title":"Traitement de donn\u00e9es en tables","text":"<p>Les donn\u00e9es organis\u00e9es en table correspondent \u00e0 une liste de p-uplets nomm\u00e9s qui partagent les m\u00eames descripteurs. La mobilisation de ce type de structure de donn\u00e9es est un premier aper\u00e7u de la notion de base de donn\u00e9es qui est \u00e9tudi\u00e9e en terminale. </p> <p>Dans ce chapitre, les p-uplets nomm\u00e9s sont repr\u00e9sent\u00e9s par des tableaux de tableaux, tableaux de p-uplets ou tableaux de dictionnaires. Le module Python <code>namedtuple</code> de la biblioth\u00e8que <code>collections</code> n'est pas utilis\u00e9.</p>"},{"location":"donnees-en-tables/1-lecture-ecriture-dans-un-fichier/","title":"Lecture et \u00e9criture dans un fichier","text":""},{"location":"donnees-en-tables/1-lecture-ecriture-dans-un-fichier/#les-chemins-de-fichiers","title":"Les chemins de fichiers","text":"<p>Il y a deux fa\u00e7ons de d\u00e9crire l'emplacement d'un fichier : son chemin absolu ou son chemin relatif :</p> <ul> <li> <p>Son chemin absolu d\u00e9crit l'int\u00e9gralit\u00e9 des dossiers (ou r\u00e9pertoires<sup>1</sup>) menant au fichier, peu importe l'endroit o\u00f9 on se trouven, depuis un r\u00e9pertoire dit \u00ab racine \u00bb.  Sous Windows, la racine  est le nom de volume (C:\\, D:\\\u2026), sous les syst\u00e8mes de la famille Unix, c'est \u00ab / \u00bb.</p> </li> <li> <p>Son chemin relatif d\u00e9crit la succession de r\u00e9pertoires \u00e0 parcourir en prenant comme point de d\u00e9part le r\u00e9pertoire courrant dans lequel on se trouve.</p> </li> </ul> <p>Exemple : Quel est le chemin du fichier <code>explorer.exe</code> dans l'arborescence suivante ?</p> <pre><code>graph TD\nA[C:] --&gt; B;\nA --&gt; C[Program Files];\nB[Windows] --&gt; D{{explorer.exe}};\nB --&gt; E{{notepad.exe}};\nA --&gt; F[\"Program Files(x86)\"];\nA --&gt; G[Users];</code></pre> <ul> <li> <p>Son chemin absolu est <code>C:\\Windows\\explorer.exe</code>.</p> </li> <li> <p>Son chemin relatif d\u00e9pend du r\u00e9pertoire courant<sup>2</sup> dans lequel on se trouve :</p> </li> </ul> R\u00e9pertoire courant Chemin relatif Windows <code>explorer.exe</code> C: <code>Windows\\explorer.exe</code> Program Files <code>..\\Windows\\explorer.exe</code><sup>3</sup> <p>Python reconnait indiff\u00e9remment les chemins indiqu\u00e9s avec backslash (norme Windows) \u00ab <code>\\</code> \u00bb qu'avec slash \u00ab <code>/</code> \u00bb (norme Unix et protocoles Internet).</p>"},{"location":"donnees-en-tables/1-lecture-ecriture-dans-un-fichier/#f-open-et-fclose","title":"f = open() et f.close()","text":"<p>Pour lire ou \u00e9crire dans un fichier depuis un programme Python, il faut d'abord ouvrir le fichier. On utilise la fonction <code>open()</code> qui prend pour param\u00e8tre le chemin (absolu ou relatif) du fichier et le mode d'ouverture :</p> <ul> <li><code>'r'</code> pour ouvrir un fichier existant en mode lecture (read-only) est l'option par d\u00e9faut.</li> <li><code>'w'</code> en mode \u00e9crite (write) pour \u00e9crire dans un nouveau fichier (ou \u00e9craser un fichier d\u00e9j\u00e0 existant).</li> <li><code>'a'</code> en mode ajout (append) pour \u00e9crire \u00e0 la fin d'un fichier d\u00e9j\u00e0 existant (ou le cr\u00e9er s'il n'existe pas).</li> </ul> <p>On peut compl\u00e9ter le mode d'ouverture avec <code>b</code> pour un fichier binaire (image ou son par exemple), on obtient <code>rb'</code>, <code>'wb'</code>, <code>'ab'</code>.</p> <p> On ne peut pas ouvrir en mode lecture un fichier, par exemple \u00ab\u00a0fichier.txt\u00a0\u00bb , qui n'existe pas.</p> <pre><code>f = open('fichier.txt', 'r')\n\n&gt;&gt;&gt; Traceback (most recent call last):\n  File \"&lt;interactive input&gt;\", line 1, in &lt;module&gt;\nFileNotFoundError: [Errno 2] No such file or directory: 'fichier.txt'\n</code></pre> <p>Par contre, en mode \u00e9criture <code>'w'</code> ou ajout <code>'a'</code>, si le fichier n'existe pas quand il est ouvert, alors il est cr\u00e9\u00e9.</p> <pre><code>f = open('fichier.txt', 'w')\n</code></pre> <p>Si fichier \u00ab\u00a0fichier.txt\u00a0\u00bb ne se trouve pas dans le r\u00e9pertoire du programme Python, il faut donner son chemin pour y acc\u00e9der avec <code>/</code> ou <code>\\\\</code>.</p> <pre><code>f = open('C:/\u2026/\u2026/\u2026/fichier.txt', 'r')\nf = open('C:\\\\\u2026\\\\\u2026\\\\\u2026\\\\fichier.txt', 'r')\n</code></pre> <p> Attention, il faut toujours fermer un fichier apr\u00e8s l'avoir ouvert<sup>4</sup>. La m\u00e9thode \u00e0 utiliser est <code>close()</code>.</p> <pre><code>&gt;&gt;&gt; f.close()\n</code></pre>"},{"location":"donnees-en-tables/1-lecture-ecriture-dans-un-fichier/#with-open-as-f","title":"with open() as f:","text":"<p>Une autre fa\u00e7on d'ouvrir un fichier \u00ab\u00a0fichier.txt\u00a0\u00bb  est d'utiliser la construction suivante :</p> <pre><code>with open('fichier.txt', 'w') as f:\n    # bloc d'instructions\n</code></pre> <p>Dans ce cas-l\u00e0, le fichier est automatiquement ferm\u00e9 \u00e0 la fin du bloc d'instructions (attention \u00e0 l'indentation), il n'y a pas besoin de le fermer, cela \u00e9vite beaucoup d'erreurs.</p>"},{"location":"donnees-en-tables/1-lecture-ecriture-dans-un-fichier/#ecrire-dans-un-fichier","title":"\u00c9crire dans un fichier","text":"<p>Pour \u00e9crire dans un fichier, on utilise la m\u00e9thode <code>.write()</code> en lui passant en param\u00e8tre une cha\u00eene de caract\u00e8res \u00e0 \u00e9crire<sup>5</sup>.  Pour \u00e9crire des nombres il faut les convertir en <code>str</code> avant.</p> <p>Cr\u00e9ons un fichier qui contient des noms de pays avec leur capitale :</p> f = open(...)with open(...) as f: <pre><code>f = open('capitales.txt, 'w')\nf.write('France;Paris\\n')\nf.close()   \n</code></pre> <pre><code>with open('capitales.txt', 'w') as f\n    f.write('France;Paris\\n')\n</code></pre> <p>Noter le caract\u00e8re \u00ab <code>\\n</code> \u00bb pour indiquer un retour \u00e0 la ligne. On peut ouvrir <code>capitales.txt</code> par exemple avec le blocnote et v\u00e9rifier que le texte a bien \u00e9t\u00e9 \u00e9crit.</p> <p>On peut ensuite \u00e9crire deux autres lignes \u00e0 la suite en mode <code>'a'</code>.</p> f = open(...)with open(...) as f: <pre><code>f = open('capitales.txt', 'a')\nf.write('Allemagne;Berlin\\n')\nf.write('Italie;Rome\\n')\n\nf.close()   \n</code></pre> <pre><code>with open('capitales.txt', 'a') as f\n    f.write('Allemagne;Berlin\\n')\n    f.write('Italie;Rome\\n')\n</code></pre> <p> Noter qu'en utilisant l'instruction <code>f = open('capitales.txt', 'a')</code>, rien n'est \u00e9crit dans le fichier si on oublie de fermer le fichier avec <code>f.close()</code> !</p> <p>Exercice corrig\u00e9</p> <p>Ecrire un programme qui cr\u00e9e un fichier 'parite.txt' contenant tous les nombres entre 0 et 100 suivis de pair ou impair : 0;pair 1;impair 2;pair etc.</p> R\u00e9ponse <pre><code>with open(\"parite.txt\", 'w') as f:\n    for i in range(101):\n        ligne = str(i) + \";\"\n        if i%2 == 0:\n            ligne = ligne + \"pair\\n\"\n        else:\n            ligne = ligne + \"impair\\n\"\n        f.write(ligne)\n</code></pre>"},{"location":"donnees-en-tables/1-lecture-ecriture-dans-un-fichier/#lire-un-fichier","title":"Lire un fichier","text":"<p>Il ewiste plusieurs approches pour lire les donn\u00e9es dans un fichier.</p>"},{"location":"donnees-en-tables/1-lecture-ecriture-dans-un-fichier/#la-methode-read","title":"La m\u00e9thode <code>.read()</code>","text":"<p>La m\u00e9thode <code>.read()</code>  renvoie l'int\u00e9gralit\u00e9 du fichier dans une chaine de caract\u00e8res :</p> f = open(...)with open(...) as f: <pre><code>f = open(\"capitales.txt\", \"r\")\ndata = f.read()\nf.close()\n</code></pre> <pre><code>with open(\"capitales.txt\", \"r\") as f\n    data = f.read()\n&gt;&gt;&gt; \n</code></pre> <p> \u00c0 noter, le fichier n'est lu qu'une seule fois avant d'\u00eatre referm\u00e9. Par exemple, suite au programme <pre><code>f = open(\"capitales.txt\", \"r\")\ndata = f.read()\ndata2 = f.read()\nf.close()\n</code></pre> la variable <code>data2</code> sera une cha\u00eene de caratc\u00e8res vide. Apr\u00e8s le premier <code>read()</code>, l'interpr\u00e9teur Python est arriv\u00e9 au bout du fichier. Il ne recommence pas \u00e0 le lire depuis le d\u00e9but et rien n'apparait apr\u00e8s le second <code>read()</code>. Pour recommencer au d\u00e9but du fichier, il faut le fermer et le rouvrir.</p>"},{"location":"donnees-en-tables/1-lecture-ecriture-dans-un-fichier/#la-methode-readline","title":"La m\u00e9thode <code>.readline()</code>","text":"<p>La m\u00e9thode <code>.readline()</code> permet de lire une seule ligne d'un fichier</p> f = open(...)with open(...) as f: <pre><code>f = open(\"capitales.txt\", \"r\") \nligne1= f.readline()\nf.close()\n</code></pre> <pre><code>&gt;&gt;&gt; with open(\"capitales.txt\", \"r\") as f\n    ligne1 = f.readline()\n&gt;&gt;&gt; \n</code></pre> <p> \u00c0 noter, une fois la premi\u00e8re ligne lue, l'instruction <code>.readline()</code> suivante lit la seconde ligne et ainsi de suite jusqu'\u00e0 la fin du fichier. Pour recommencer au d\u00e9but du fichier il faut fermer et rouvrir le fichier <pre><code>f = open(\"capitales.txt\", \"r\")\nligne1 = f.read()\nligne2 = f.read()\nf.close()\n</code></pre></p> <p> Attention donc \u00e0 ne pas confondre <code>readline()</code> qui renvoie une seule ligne dans une cha\u00eene de caract\u00e8res, avec <code>readlines()</code> qui renvoie un tableau de toutes les lignes.</p>"},{"location":"donnees-en-tables/1-lecture-ecriture-dans-un-fichier/#la-boucle-for-in","title":"La boucle <code>for\u2026 in \u2026</code>","text":"<p>Une boucle  <code>for\u2026 in \u2026</code> permet d'it\u00e9rer sur toutes les lignes d'un fichier.</p> f = open(...)with open(...) as f: <pre><code>f = open(\"capitales.txt\", \"r\") \nfor ligne in f:\n    print(ligne[:-1])     # supprime le caract\u00e8re \\n \u00e0 la fin de la ligne\nf.close()\n</code></pre> <pre><code>with open(\"capitales.txt\", \"r\") as f\n    for ligne in f:\n        print(ligne[:-1])     # supprime le caract\u00e8re \\n \u00e0 la fin de la ligne\n</code></pre> <p>Ici, la variable <code>ligne</code> est une chaine de caract\u00e8re qui prend la valeur de chaque ligne de <code>capitales.txt</code>.</p> <p>Exercice corrig\u00e9</p> <p>\u00ab Green Eggs and Ham is one of Seuss's \"Beginner Books\", written with very simple vocabulary for beginning readers. The vocabulary of the text consists of just 50 words and was the result of a bet between Seuss and Bennett Cerf, Dr. Seuss's publisher \u00bb Source : Wikipedia. </p> <p>Ecrire un programme pour v\u00e9rifier si Dr. Seuss a gagn\u00e9 son pari d'\u00e9crire un livre en utilisant moins de 50 mots dans son livre :  https://www.clear.rice.edu/comp200/resources/texts/Green%20Eggs%20and%20Ham.txt </p> <p>Aide : Utiliser les m\u00e9thodes <code>.lower()</code> pour convertir une cha\u00eene de caract\u00e8res en minuscule, <code>.replace()</code> pour rempalcer les les signes de ponctuation (. , - ! et ? ) par des espaces, et <code>.split()</code> pour s\u00e9parer les mots dans une cha\u00eene de caract\u00e8res. </p> R\u00e9ponse <pre><code>mots_utilises = {}  #dictionnaire des mots utilis\u00e9s et de leur nombre d'occurence\nwith open(\"green eggs and ham.txt\", \"r\") as f:\n    texte = f.read()\n    texte = texte.lower()   # met le texte en minuscule\n    # supprime la ponctuation\n    for c in \".,-!?\":\n        texte = texte.replace(c, ' ')\n    # s\u00e9pare les mots du texte dans un tableau de str\n    mots = texte.split()\n    # ajoute et compte les mots dans le dictionnaire mots_utilises\n    for m in mots:\n        if m not in mots_utilises:\n            mots_utilises[m] = 1\n        else:\n            mots_utilises[m] += 1\nprint(len(mots_utilises))\n</code></pre> <ol> <li> <p>Depuis Windows 7, le terme \u00ab dossier \u00bb remplace \u00ab r\u00e9pertoire \u00bb\u00a0\u21a9</p> </li> <li> <p>En Python, on peut d\u00e9terminer le r\u00e9pertoire courant avec l'instruction <code>getcwd()</code> du module <code>os</code> (noter le  double <code>\\\\</code> dans la cha\u00eene de caract\u00e8re pour \u2018\u00e9chapper' le caract\u00e8re <code>\\</code>)</p> <p><pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; os.getcwd()\n'C:\\\\Program Files\\\\PyScripter'\n</code></pre> \u21a9</p> </li> <li> <p>\u00ab <code>..</code> \u00bb d\u00e9signe le r\u00e9pertoire parent.\u00a0\u21a9</p> </li> <li> <p>On peut essayer de supprimer un fichier ouvert depuis Windows explorer pour s\u2019en convaincre.\u00a0\u21a9</p> </li> <li> <p><code>write()</code> renvoie le nombre de caract\u00e8res qui ont \u00e9t\u00e9 \u00e9crits dans le fichier, utile par exemple pour v\u00e9rifier que le fichier contient bien le texte qu'on y a \u00e9crit.\u00a0\u21a9</p> </li> </ol>"},{"location":"donnees-en-tables/2-table-de-donnees/","title":"Table de donn\u00e9es","text":"<p>La notion de table est apparue dans les ann\u00e9es 1970 chez IBM avec l'alg\u00e8bre relationnelle. Les tables de donn\u00e9es, stock\u00e9es dans des bases de donn\u00e9es relationnelles deviennent rapidement le moyen le plus rependu de stocker et traiter de l'information structur\u00e9e. </p> <p>Cours</p> <p>Une table de donn\u00e9es est un ensemble d'\u00e9l\u00e9ments organis\u00e9s sous forme d'une table :</p> <ul> <li>o\u00f9 chaque ligne correspond \u00e0 un \u00e9l\u00e9ment, appel\u00e9 aussi une entit\u00e9 ou une entr\u00e9e de la table,</li> <li>o\u00f9 chaque colonne correspond \u00e0 une cat\u00e9gorie d'information de m\u00eame type, appel\u00e9 un champs ou attribut. </li> </ul> <p>Exemple : une liste d'information sur les pays utilis\u00e9e au chapitre 'Types construits':</p> Pays Capitale Population (ml) France Paris 68 Allemagne Berlin 82 Italie Rome 60 <p>Cours</p> <p>Les noms des colonnes, ici Pays, Capitale et Population (ml), sont appel\u00e9s les descripteurs de la table.</p> <p>De nombreux formats de fichiers sont utilis\u00e9s pour stocker des donn\u00e9ess en table : txt, csv, json, excel, etc. </p>"},{"location":"donnees-en-tables/2-table-de-donnees/#le-format-csv","title":"Le format csv","text":"<p>Cours</p> <p>Le format csv, pour Comma-Separated Values, est un format texte repr\u00e9sentant des donn\u00e9es en table s\u00e9par\u00e9es par des virgules (comme son nom l'indique) ou d'autres s\u00e9parateurs, par exemple point-virgule (\u00ab <code>;</code> \u00bb), tabulation (\u00ab <code>\\t</code> \u00bb), etc. </p> <p>Chaque ligne du texte correspond \u00e0 une ligne du tableau et les virgules correspondent aux s\u00e9parations entre les colonnes. Un fichier csv est un fichier texte mais on utilise l'extension .csv pour indiquer la nature de ses donn\u00e9es.</p> <p>Exemple : Reprenons la table des pays, en fichier csv on \u00e9crit dans un fichier texte.</p> <pre><code>Pays,Capitale,Population (ml)\nFrance,Paris,68\nAllemagne,Berlin,82\nItalie,Rome,60\n</code></pre> <p>Le format csv est un format de fichier texte, ouvert qui peut \u00eatre cr\u00e9\u00e9, lu et modifi\u00e9 par tous les logiciels, en particulier des \u00e9diteurs de texte (bloc note), mais aussi des tableurs comme Microsoft Excel<sup>1</sup> ou OpenOffice Calc.</p> <p>Il existe d'autres formats de donn\u00e9es structur\u00e9es, par exemple JSON ou XML.</p>"},{"location":"donnees-en-tables/2-table-de-donnees/#ecrire-une-table-de-donnees-dans-un-fichier-csv","title":"Ecrire une table de donn\u00e9es dans un fichier csv","text":"<p>Un fichier csv est un simple fichier txt, on \u00e9crire la table des pays dans un fichier csv de la m\u00eame fa\u00e7on que dans un fichier texte en s\u00e9parant les donn\u00e9es par une virgule (par exemple) et les lignes par <code>\\n</code> :</p> <pre><code>f = open(\"pays.csv\", \"w\")              # si pays.csv n'existe pas, il est cr\u00e9\u00e9\nf.write('Pays,Capitale,Population (ml)\\n')\nf.write('France,Paris,68\\n')\nf.write('Allemagne,Berlin,82\\n')\nf.write('Italie,Rome,60\\n')\nf.close()\n</code></pre>"},{"location":"donnees-en-tables/2-table-de-donnees/#lire-une-table-de-donnees-depuis-un-fichier-csv","title":"Lire une table de donn\u00e9es depuis un fichier csv","text":"<p>On peut lire les donn\u00e9es depuis un fichier csv (ou un autre type de fichier tabul\u00e9) et enregistrer les donn\u00e9es dans un tableau de tableaux en le lisant ligne par ligne :</p> f = open()with open as f: <pre><code>f = open(\"pays.csv\", \"r\")\npays = []\nfor li in f:\n    pays.append(li.split(','))\nf.close()\n</code></pre> <p><code>py with open(\"pays.csv\", \"r\") as f:     pays = []     for li in f:         pays.append(li.split(','))</code></p> <p>ou m\u00eame par compr\u00e9hension :</p> f = open()with open as f: <pre><code>f = open(\"pays.csv\", \"r\")\npays = [li.split(',') for li in f]\nf.close()\n</code></pre> <p><code>py with open(\"pays.csv\", \"r\") as f:     pays = [li.split(',') for li in f]</code></p> <p>On obtient le tableau de tableaux suivant:</p> <pre><code>&gt;&gt;&gt; pays\n[['Pays', 'Capitale', 'Population (ml)\\n'],\n ['France', 'Paris', '68\\n'],\n ['Allemagne', 'Berlin', '82\\n'],\n ['Italie', 'Rome', '60\\n']]\n</code></pre> <p>On peut utiliser <code>li[ :-1]</code> pour supprimer les retours \u00e0 la ligne \u00ab <code>\\n</code> \u00bb<sup>2</sup>::</p> f = open()with open as f: <pre><code>f = open(\"pays.csv\", \"r\")\npays = [li[:-1].split(',') for li in f]\nf.close()\n</code></pre> <p><code>py with open(\"pays.csv\", \"r\") as f:     pays = [li[:-1].split(',') for li in f]</code></p> <p>On obtient alors le tableau suivant :</p> <pre><code>&gt;&gt;&gt; pays\n[['Pays', 'Capitale', 'Population (ml)'],\n ['France', 'Paris', '68'],\n ['Allemagne', 'Berlin', '82'],\n ['Italie', 'Rome', '60']]\n</code></pre> <p>Et si on veut supprimer la premi\u00e8re ligne si elle contient les titres de colonnes, il suffit d'ajouter <code>f.readline()</code> apr\u00e8s l'ouverture du fichier : </p> <pre><code>f = open(\"pays.csv\", \"r\")\nf.readline()\npays = [li[:-1].split(',') for li in f]\nf.close()   with open(\"pays.csv\", \"r\") as f:\n    f.readline()\n    pays = [li[:-1].split(',') for li in f]\n</code></pre> <p>Exercice corrig\u00e9</p> <p>Importer dans un tableau de tableaux les donn\u00e9es du fichier des codes postaux depuis https://www.data.gouv.fr/fr/datasets/base-officielle-des-codes-postaux/.</p> R\u00e9ponse <p>Une fois les donn\u00e9es sauvegard\u00e9es dans le ficher \"laposte_hexasmal.csv\" dans le r\u00e9pertoire \"documents\", on peut les visualiser par exemple dans le blocnote, dans Excel ou sur le site internet directement. On remarque que :</p> <ul> <li>la premi\u00e8re ligne du fichier contient les six descripteurs de donn\u00e9es (Code_commune_INSEE,  Nom_commune, \u2026)</li> <li>les s\u00e9parateurs sont des points-virgules</li> </ul> <pre><code>f = open(\"laposte_hexasmal.csv\", \"r)   # on ouvre le fichier en lecture \nf.readline()      # on lit la 1ere ligne de descripteur s\u00e9par\u00e9ment\ncodes = []\nfor li in f: \n    codes.append(li[:-1].split(';'))\n\n# ou alors par comprehension:\ncodes2 = [li[:-1].split(';') for li in f]   \n\nf.close()           # ne pas oublier de fermer le fichier\n&gt;&gt;&gt; codes\n[['90093',\n'SERMAMAGNY',\n'90300',\n'SERMAMAGNY',\n'',\n'47.687801557,6.8309146345\\n'],\n\u2026\n</code></pre> <p>De la m\u00eame fa\u00e7on qu'on a importer des donn\u00e9es en table dans un tableau de tableaux, on peut tr\u00e8s bien les importer dans un tableau de p-uplets (pour avoir des donn\u00e9es de types diff\u00e9rents)<sup>3</sup> ou un tableau de dictionnaires (pour utiliser les descripteurs)<sup>4</sup>.</p>"},{"location":"donnees-en-tables/2-table-de-donnees/#lire-et-ecrire-dans-un-fichier-csv-avec-le-module-csv","title":"Lire et \u00e9crire dans un fichier csv avec le module csv","text":"<p>Le module Python <code>csv</code> permet de lire et \u00e9crire facilement des donn\u00e9es en table dans un fichier csv.</p> <p>On commence par cr\u00e9er un objet permettant l'\u00e9criture dans le fichier avec la fonction <code>writer()</code> du module <code>csv</code>. <code>writerows()</code> <sup>5</sup>   permet ensuite d'\u00e9crire un tableau de tableaux directement dans un fichier csv :</p> <pre><code>import csv\n\npays= [ ['Pays', 'Capitale', 'Population (ml)'],\n        ['France', 'Paris', 68],\n        ['Allemagne', 'Berlin', 82],\n        ['Italie', 'Rome', 60]]\n\nwith open('pays.csv', 'w', newline='') as f:\n    ecriture = csv.writer(f, delimiter=';')\n    ecriture.writerows(pays)\n</code></pre> <p>Noter qu'\u00e0 l'ouverture du fichier avec <code>open()</code>, il faut indiquer le param\u00e8tre <code>newline=''</code> sinon des sauts de lignes suppl\u00e9mentaires seront ajout\u00e9s entre les lignes.</p> <p>De la m\u00eame fa\u00e7on en lecture, il faut cr\u00e9er un objet de lecture avec la fonction<code>reader()</code>.</p> <p><pre><code>import csv\n\nwith open('pays.csv', 'r', newline='') as f:\n    lecture = csv.reader(f, delimiter=';')\n</code></pre> <code>lecture</code> est un objet qui ne peut pas \u00eatre affich\u00e9 directement : </p> <pre><code>&gt;&gt;&gt; lecture\n&lt;_csv.reader object at 0x00000224603A0BE0&gt;\n</code></pre> <p>Mais on peut le parcourir, on dit que c'est un objet \u00ab it\u00e9rable \u00bb : </p> <p><pre><code>    for ligne in lecture:\n        print(ligne)\n</code></pre> ou le convertir en tableau avec <code>list()</code> :</p> <p><pre><code>import csv\n\nwith open('pays.csv', 'r', newline='') as f:\n    donnees = list(csv.reader(f, delimiter=';'))\n</code></pre> On obtient un tableau de tableaux :</p> <pre><code>&gt;&gt;&gt; donnees\n[['Pays', 'Capitale', 'Population (millions)'],\n ['France', 'Paris', '68'],\n ['Allemagne', 'Berlin', '82'],\n ['Italie', 'Rome', '60']]\n</code></pre> <p> \u00c0 noter que toutes les valeurs sont au format <code>str</code>, y compris les nombres, il faudra en tenir compte dans l'utilisation de ces donn\u00e9es par la suite programme.</p> <p>Le tableau de tableaux, n'est pas toujours id\u00e9al, en particulier la premi\u00e8re ligne de descripteurs n'est pas s\u00e9par\u00e9e du reste des donn\u00e9es.  La m\u00e9thode <code>DictReader</code> permet de garder les descripteurs en cr\u00e9ant un tableau de dictionnaires. </p> <pre><code>import csv\n\nwith open('pays.csv', 'r', newline='') as f:\n    donnees = list(csv.DictReader(f, delimiter=','))\n</code></pre> <p>On obtient ici un tableau de dictionnaires :</p> <pre><code>&gt;&gt;&gt; donnees\n[{'Pays': 'France', 'Capitale': 'Paris', 'Population (millions)': '68'}, {'Pays': 'Allemagne', 'Capitale': 'Berlin', 'Population (millions)': '82'}, {'Pays': 'Italie', 'Capitale': 'Rome', 'Population (millions)': '60'}]\n</code></pre> <p>On trouvera de nombreuses fonctionnalit\u00e9s dans le module <code>csv</code><sup>6</sup>:. </p> <p>Exercice corrig\u00e9</p> <p>Importer dans un tableau de dictionnaires les donn\u00e9es du fichier des 197 pays et capitales https://www.data.gouv.fr/fr/datasets/base-officielle-des-codes-postaux/.</p> R\u00e9ponse <pre><code>import csv\n\nwith open(\"laposte_hexasmal.csv\", 'r', newline='') as f:\n    codes = list(csv.DictReader(f, delimiter=';'))\n&gt;&gt;&gt; codes\n[{'Code_commune_INSEE': '90093',\n'Code_postal': '90300',\n'Libelle_acheminement': 'SERMAMAGNY',\n'Ligne_5': '',\n'Nom_commune': 'SERMAMAGNY',\n'coordonnees_gps': '47.687801557,6.8309146345'},\n{'Code_commune_INSEE': '91093',\n'Code_postal': '91470',\n'Libelle_acheminement': 'BOULLAY LES TROUX',\n\u2026\n</code></pre> <ol> <li> <p>Avec le menu Fichier/Ouvrir puis utiliser la fen\u00eatre \u00ab Assistant d'importation du texte \u00bb pour choisir le s\u00e9parateur utilis\u00e9 ou Donn\u00e9es/R\u00e9cup\u00e9rer des donn\u00e9es externes/fichier texte.\u00a0\u21a9</p> </li> <li> <p>Ou encore en utilisant la m\u00e9thode <code>splitlines()</code> on peut \u00e9crire <code>&gt;&gt;&gt; pays = [li.split(',') for li in f.read().splitlines()]</code>.\u00a0\u21a9</p> </li> <li> <p>Par exemple avec le code suivant : <pre><code>f = open(\"pays.csv\", \"r\")\ndescripteurs = f.readline().split( ',')         # ligne de descripteurs trait\u00e9e s\u00e9par\u00e9ment\n\npays = []\nfor li in f:\n    tab = li[:-1].split(',')\n    puplet = (tab[0], tab[1], int(tab[2]))     # la population est convertie en int\n    pays.append(puplet)\nf.close()\n</code></pre> \u21a9</p> </li> <li> <p>Par exemple avec le code suivant : <pre><code>f = open(\"/pays.csv\", \"r\")\ndescripteurs = f.readline()[:-1].split( ',')\n\npays = []\nfor li in f:\n    dico = {descripteurs[0] : li.split(',')[0] ,\n            descripteurs[1] : li.split(',')[1],\n            descripteurs[2] : int(li.split(',')[2][:-1])  \n        }\n    pays.append(dico)\nf.close()\n</code></pre> \u21a9</p> </li> <li> <p>Ne pas confondre avec <code>writerow()</code> qui permet d'\u00e9crire ligne par ligne.\u00a0\u21a9</p> </li> <li> <p>Voir : https://docs.python.org/fr/3/library/csv.html \u21a9</p> </li> </ol>"},{"location":"donnees-en-tables/3-rechercher-dans-une-table/","title":"Rechercher dans une table","text":""},{"location":"donnees-en-tables/3-rechercher-dans-une-table/#recherches-simples","title":"Recherches simples","text":""},{"location":"donnees-en-tables/3-rechercher-dans-une-table/#dans-un-tableau-de-de-tableaux-ou-tableau-de-p-uplets","title":"Dans un tableau de de tableaux ou tableau de p-uplets","text":"<p>Un tableau de tableau ou tableau de p-uplets est it\u00e9rable avec l'instruction <code>for \u2026 in \u2026</code> et on peut chercher un \u00e9l\u00e9ment avec le mot cl\u00e9 <code>in</code>. Une recherche est donc tr\u00e8s simple.</p> <p>Reprenons notre tableau de p-uplets de pays et cherchons dans quel pays se trouve 'Rome' :</p> <pre><code>pays = [('France', 'Paris', 68), \n        ('Allemagne', 'Berlin', 82),\n        ('Italie', 'Rome', 60)]\nfor ligne in pays:\n    if 'Rome' in ligne:\n        print('Rome est en ', ligne[0])\n</code></pre> <p>Pour comprendre ce qu'il se passe, ici <code>ligne</code> it\u00e8re sur chaque ligne de <code>pays</code> prenant tour \u00e0 tour les valeurs des p-uplets  :</p> <pre><code>('France', 'Paris', 68)\n('Allemagne', 'Berlin', 82)\n('Italie', 'Rome', 60)\n</code></pre> <p>Et pour chaque p-uplet, l'instruction conditionnelle <code>if 'Rome' in ligne</code> v\u00e9rifie si <code>'Rome'</code> est pr\u00e9sent ou pas. </p>"},{"location":"donnees-en-tables/3-rechercher-dans-une-table/#dans-un-tableau-de-dictionnaires","title":"Dans un tableau de dictionnaires","text":"<p>Un tableau de dictionnaires est aussi it\u00e9rable avec l'instruction <code>for \u2026 in \u2026</code> mais par d\u00e9faut le mot cl\u00e9 <code>in</code> v\u00e9rifie l'existence d'un \u00e9l\u00e9ment dans les cl\u00e9s du dictionnaire, pas dans les valeurs. Il faut donc pr\u00e9ciser que l'on recherche l'\u00e9l\u00e9ment recherch\u00e9 parmi les valeurs du dictionnaire avec la m\u00e9thode <code>.values()</code>. </p> <p>Cherchons dans quel pays se trouve 'Rome'.</p> <pre><code>pays = [{'Capitale': 'Paris', 'Pays': 'France', 'Population (ml)': 68},\n        {'Capitale': 'Berlin', 'Pays': 'Allemagne', 'Population (ml)': 82},\n        {'Capitale': 'Rome', 'Pays': 'Italie', 'Population (ml)': 60}]\nfor ligne in pays:\n    if 'Rome' in ligne.values():\n        print('Rome est en ', ligne['Pays'])\n</code></pre> <p>ou alors on peut pr\u00e9ciser la cl\u00e9 dans laquelle on veut faire la recherche, par exemple ici on peut chercher 'Rome' dans les valeurs associ\u00e9es \u00e0 la cl\u00e9 <code>'Capitale'</code> :</p> <pre><code>for ligne in pays:\n    if ligne['Capitale']  == 'Rome':\n        print('Rome est en ', ligne['Pays'])\n</code></pre> <p>Exercice corrig\u00e9</p> <p>En pratique: En utilisant le tableaux de dictionnaires des codes postaux pr\u00e9c\u00e9dent, \u00e9crire une fonction qui renvoie : 1. le code postal d'une ville  2. un tableau des villes ayant un code postal donn\u00e9</p> R\u00e9ponse <pre><code>def chercher_code(codes_postaux, ville ):\n    for ligne in codes_postaux: \n        if ligne['Nom_commune'] == ville:\n            return ligne['Code_postal'] \n\n\ndef chercher_villes(codes_postaux, code ): \n    villes = [] \n    for ligne in codes_postaux:\n        if ligne['Code_postal'] == code:\n            villes.append(ligne['Nom_commune'])\n    return villes \n</code></pre>"},{"location":"donnees-en-tables/3-rechercher-dans-une-table/#recherches-conditionnelles","title":"Recherches conditionnelles","text":"<p>Pour un tableau de tableaux,  de p-uplets ou de dictionnaires, le mot cl\u00e9 <code>in</code> ne suffit plus pour tester la pr\u00e9sence d'un \u00e9l\u00e9ment avec des conditions. Il faut tester les conditions sur chacun des tableaux, p-uplets ou dictionnaires.</p> <p>Reprenons notre tableau de p-uplets de pays et cherchons les pays qui ont plus de 65 millions d'habitants :</p> <pre><code>pays = [('France', 'Paris', 68),\n        ('Allemagne', 'Berlin', 82),\n        ('Italie', 'Rome', 60)]\nfor ligne in pays:\n    if ligne[2] &gt; 65: \n        print(ligne[0], 'a plus de 65 millions d'habitants')\n</code></pre> <p>Exercice corrig\u00e9</p> <p>En utilisant le tableaux de dictionnaires des codes postaux pr\u00e9c\u00e9dent , \u00e9crire une fonction qui renvoie :</p> <ol> <li>le tableau de toutes les villes d'un d\u00e9partement </li> <li>Toutes les villes qui commencent par \u2018MAN'</li> </ol> R\u00e9ponse <pre><code>def chercher_departement(table_code, dep ):\n    villes = []\n    for li in table_code:\n        if li['Code_postal'] &gt;= dep * 1000 and li['Code_postal'] &lt; (dep+1) * 1000:\n            villes.append( li['Nom_commune'] )\n    return villes\n&gt;&gt;&gt; chercher_departement(c,13)\n['MARTIGUES',\n\u2026.\n'ST ANDIOL',\n'SAUSSET LES PINS',\n'MARSEILLE 09']\n\ndef chercher_MAN(table_code):\nvilles = []\nfor li in table_code:\n    if li['Nom_commune'][0:3] == 'MAN':\n        villes.append( li['Nom_commune'] )\nreturn villes\n</code></pre>"},{"location":"donnees-en-tables/3-rechercher-dans-une-table/#tests-de-coherence-et-recherche-de-doublons","title":"Tests de coh\u00e9rence et recherche de doublons","text":"<p>Jusqu'ici on a fait l'hypoth\u00e8se que tous les champs du fichier sont remplis et corrects sans v\u00e9rifier leur coh\u00e9rence. Ce n'est pas toujours le cas et un fichier mal renseign\u00e9, ou avec des valeurs vides peut ensuite g\u00e9n\u00e9rer des probl\u00e8mes.  Pour l'\u00e9viter, on peut faire des tests de coh\u00e9rence, par exemple v\u00e9rifier que tous les noms de villes sont renseign\u00e9s et qu'aucun n'est laiss\u00e9 vide (comme les coordonn\u00e9es GPS)</p> <pre><code>def coherence_villes(table_code):\n    for li in table_code:\n        if li['Nom_commune'] == '':\n            return False\n    return True\n\n&gt;&gt;&gt; coherence_villes(importer())\nTrue\n</code></pre> <p>On peut aussi rechercher des doublons dans la table. Par exemple , on a fait l'hypoth\u00e8se au paragrpahe 3.1 qu'une ville n'apparait qu'une fois (et donc n'a qu'un code postal), mais on ne l'a pas test\u00e9. La table n'est pas tri\u00e9e, il faut donc tester toutes les possibilit\u00e9s de doublons :</p> <pre><code>def chercher_doublons(table_code):\n    for i in range(len(table_code)-1):\n        for j in range(i+1, len(table_code)) :\n            if table_code[j]['Nom_commune']  == table_code[i]['Nom_commune']:\n                print(table_code[i]['Nom_commune'], 'apparait \u00e0 la ligne', i, 'et', j)\n</code></pre> <p>On s'aper\u00e7oit qu'il y a \u00e9norm\u00e9ment de doublons dans cette table. Par exemple CHAMONIX MONT-BLANC apparait plusieurs fois (avec le m\u00eame code postal) ou CHALAIS apparait plusieurs fois dans des d\u00e9partement diff\u00e9rents.</p>"},{"location":"donnees-en-tables/4-trier-une-table/","title":"Trier une table","text":""},{"location":"donnees-en-tables/4-trier-une-table/#sorted-et-sort","title":"sorted() et .sort()","text":"<p>Pour trier en ordre croissant de fa\u00e7on simple et facile, il suffit d'appeler la fonction <code>sorted()</code>. Elle renvoie un nouveau tableau tri\u00e9 :</p> <pre><code>&gt;&gt;&gt; sorted([5, 2, 3, 1, 4])\n[1, 2, 3, 4, 5]\n</code></pre> <p>Ici on a tri\u00e9 un tableau de nombres entiers. On peut faire la m\u00eame chose avec un tableau de nombres decimaux (<code>float</code>)  ou de chaines de caract\u00e8res.  Les chaines de caract\u00e8res sont tri\u00e9es par ordre lexicographique<sup>1</sup>.</p> <pre><code>&gt;&gt;&gt; sorted(['pomme', 'banane', 'orange', 'fraise'])\n['banane', 'fraise', 'orange', 'pomme']\n</code></pre> <p>On peut aussi trier un p-uplet ou les cl\u00e9s d'un dictionnaire, la fonction renvoie toujours un tableau :</p> <pre><code>&gt;&gt;&gt; sorted((5,2,3,1,4))\n[1, 2, 3, 4, 5]\n&gt;&gt;&gt; sorted({'un':1, 'deux':2, 'trois':3 })\n['deux', 'trois', 'un']\n</code></pre> <p>On peut aussi utiliser la m\u00e9thode <code>.sort()</code> qui elle modifie le tableau (et renvoie <code>None</code> pour \u00e9viter les confusions).</p> <pre><code>&gt;&gt;&gt; a = [5, 2, 3, 1, 4]\n&gt;&gt;&gt; a.sort()\n&gt;&gt;&gt; a\n[1, 2, 3, 4, 5]\n</code></pre> <p>Une autre diff\u00e9rence est que la m\u00e9thode <code>.sort()</code> est seulement utilis\u00e9es pour les tableaux. Au contraire, la fonction <code>sorted()</code> accepte n'importe quel it\u00e9rable, par exemple les cl\u00e9 d'un dictionnaire.</p> <pre><code>&gt;&gt;&gt; sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})\n[1, 2, 3, 4, 5]\n&gt;&gt;&gt; {1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'}.sort()\nTraceback (most recent call last):\n  File \"&lt;interactive input&gt;\", line 1, in &lt;module&gt;\nAttributeError: 'dict' object has no attribute 'sort'\n</code></pre> <p>On peut trier sur des types construits, dans ce cas le tri est fait par ordre des \u00e9l\u00e9ments. Par exemple, on peut trier une liste de p-uplets contenant les pays.</p> <pre><code>&gt;&gt;&gt; pays = [('France', 'Paris', 68), ('Allemagne', 'Berlin', 82), ('Italie', 'Rome', 60)]\n&gt;&gt;&gt; sorted(pays)\n[('Allemagne', 'Berlin', 82), ('France', 'Paris', 68), ('Italie', 'Rome', 60)]\n</code></pre> <p>Dans ce cas, le tri est fait par <code>pays[0]</code> (type str) donc par ordre alphab\u00e9tique :  <code>'Allemagne' &lt; 'France'&lt; 'Italie'</code>.</p> <p>Par contre, on ne peut pas trier un tableau de dictionnaires :</p> <pre><code>&gt;&gt;&gt; pays = [{'Capitale': 'Paris', 'Pays': 'France', 'Population (ml)': 68}, \n    {'Capitale': 'Berlin', 'Pays': 'Allemagne', 'Population (ml)': 82}, \n    {'Capitale': 'Rome', 'Pays': 'Italie', 'Population (ml)': 60}]\n&gt;&gt;&gt; sorted(pays)\nTraceback (most recent call last):\n  File \"&lt;interactive input&gt;\", line 1, in &lt;module&gt;\nTypeError: '&lt;' not supported between instances of 'dict' and 'dict'\u2003\n</code></pre>"},{"location":"donnees-en-tables/4-trier-une-table/#parametre-key","title":"Param\u00e8tre key","text":"<p><code>.sort()</code> et <code>sorted()</code> acceptent un param\u00e8tre nomm\u00e9 <code>key</code> permettant de sp\u00e9cifier une fonction \u00e0 appeler sur chaque \u00e9l\u00e9ment du tableau afin d'effectuer des comparaisons.  Par exemple, on peut modifier l'ordre de tri d'un tableau de nombres au format <code>str</code> :</p> <pre><code>&gt;&gt;&gt; sorted(['5', '3', '1', '11', '21'])\n['1', '11', '21', '3', '5']\n</code></pre> <p>en pr\u00e9cisant que les donn\u00e9es doivent \u00eatre converties en entier par la fonction <code>int()</code> avant d'\u00eatre tri\u00e9es : </p> <pre><code>&gt;&gt;&gt; sorted(['5', '3', '1', '11', '21'], key=int)\n['1', '3', '5', '11', '21']\n</code></pre> <p>De la m\u00eame fa\u00e7on, le param\u00e8tre <code>key</code> permet de trier une table en pr\u00e9cisant les colonnes selon lesquelles on veut trier. Par exemple, si on veut trier le tableau de p-uplets des pays selon leur population :</p> <pre><code>&gt;&gt;&gt; pays = [('France', 'Paris', 68), ('Allemagne', 'Berlin', 82), ('Italie', 'Rome', 60)]\n</code></pre> <p>On peut utiliser une fonction <code>popul</code> qui renvoie la population :</p> <pre><code>def popul(x): \n    return x[2]\n</code></pre> <p>et qui sert de cl\u00e9 de <code>sorted()</code> :</p> <pre><code>&gt;&gt;&gt; sorted(pays, key=popul)\n[('Italie', 'Rome', 60), ('France', 'Paris', 68), ('Allemagne', 'Berlin', 82)]\n</code></pre> <p>Ou bien l'\u00e9crire directement dans une fonction lambda :</p> <pre><code>&gt;&gt;&gt; sorted(pays, key=lambda x:x[2])\n[('Italie', 'Rome', 60), ('France', 'Paris', 68), ('Allemagne', 'Berlin', 82)]\n</code></pre> <p>Pour trier selon plusieurs colonnes, il suffit que la fonction de tri renvoie un p-uplet, par exemple les pays par population et par capital on fera : </p> <pre><code>&gt;&gt;&gt; pays = [('France', 'Paris', 68), ('Allemagne', 'Berlin', 82), ('Italie', 'Rome', 60), ('Royaume-Uni', 'Londres', 68),]\n&gt;&gt;&gt; sorted(pays, key=lambda x:(x[2], x[1]))\n[('Italie', 'Rome', 60),\n ('Royaume-Uni', 'Londres', 68),\n ('France', 'Paris', 68),\n ('Allemagne', 'Berlin', 82)\n ```\n\nA noter que dans ce cas la fonction `lambda x:x[2]` renvoie un it\u00e9rable (tableau des populations) qui est tri\u00e9 par la fonction `sorted()`. De la m\u00eame fa\u00e7on, on peut ainsi trier un tableau de dictionnaires en ordre croissant de population (alors qu'on ne pouvait pas le faire sans le param\u00e8tre `key`) :  \n\n``` py\n&gt;&gt;&gt; pays = [{'Capitale': 'Paris', 'Pays': 'France', 'Population (ml)': 68}, \\\n            {'Capitale': 'Berlin', 'Pays': 'Allemagne', 'Population (ml)': 82}, \\\n            {'Capitale': 'Rome', 'Pays': 'Italie', 'Population (ml)': 60}]\n\n&gt;&gt;&gt; sorted(pays, key= lambda x:x['Population (ml)'])\n[{'Capitale': 'Rome', 'Pays': 'Italie', 'Population (ml)': 60},\n {'Capitale': 'Paris', 'Pays': 'France', 'Population (ml)': 68},\n {'Capitale': 'Berlin', 'Pays': 'Allemagne', 'Population (ml)': 82}]\n</code></pre>"},{"location":"donnees-en-tables/4-trier-une-table/#parametre-reverse","title":"Param\u00e8tre reverse","text":"<p><code>.sort()</code> et <code>sorted()</code> acceptent aussi un param\u00e8tre nomm\u00e9 <code>reverse</code> avec une valeur bool\u00e9enne. Par d\u00e9faut, <code>reverse</code> est <code>False</code>, c'est-\u00e0-dire qu'on tri en ordre croissant, mais on peut le changer pour indiquer un ordre d\u00e9croissant des tris.  Par exemple, pour avoir les pays dans par population d\u00e9croissante :</p> <pre><code>&gt;&gt;&gt; sorted(pays, key = lambda x:x[2], reverse = True)\n[('Allemagne', 'Berlin', 82), ('France', 'Paris', 68), ('Italie', 'Rome', 60)]\n</code></pre> <p>Exercice corrig\u00e9</p> <p>En utilisant le tableau de dictionnaires des codes postaux, \u00e9crire une fonction qui renvoie la commune qui a le plus petit code postal, le plus grand code postal, la plus grande longitude, la plus \u00e9loign\u00e9e de Manosque.  Note : La distance  en m\u00e8tres entre les points de coordonn\u00e9es (\\(Long_A\\);\\(Lat_A\\)) et (\\(Long_B\\); \\(Lat_B\\) ) est donn\u00e9e par la formule de Pythagore : </p> <ul> <li> <p>\\(x =({Long_B - Long_A )} \\times {cos\u2061{ {Lat_A + Lat_B} \\over 2}}\\)</p> </li> <li> <p>\\(y = Lat_B-Lat_A\\)</p> </li> <li> <p>\\(z = \\sqrt {x^2+y^2}\\)</p> </li> <li> <p>\\(d = 1852 \\times 60 \\times z\\)</p> </li> </ul> <p>Source : http://villemin.gerard.free.fr/aGeograp/Distance.htm</p> R\u00e9ponse <pre><code>from math import cos, sqrt\n\ncommunes = []\nwith open(\"laposte_hexasmal.csv\", \"r\",) as f:\n    cles = f.readline()[:-1].split( ';')    #note [:-1] to remove the \\n at the end of the line\n    for li in f  :\n        c = {cles[0] : li.split(';')[0],\n            cles[1] : li.split(';')[1],\n            cles[2] : int(li.split(';')[2]),        # code postal\n            cles[3] : li.split(';')[3],\n            cles[4] : li.split(';')[4],\n            }\n        gps = li.split(';')[5][:-1]  # coordonn\u00e9es GPS\n        if gps != '':\n            c['gps'] = (float(gps.split(',')[0]), float(gps.split(',')[1]))\n            communes.append(c)\n\nplus_petit_code_postal = sorted(communes, key = lambda x:x['Code_postal'])[0]\nprint(f'la commune qui a le plus petit code postal est {plus_petit_code_postal[\"Nom_commune\"]} \\\n    son code postal est {plus_petit_code_postal[\"Code_postal\"]}')\nplus_grand_code_postal = sorted(communes, key = lambda x:x['Code_postal'], reverse= True)[0]\nprint(f'la commune qui a le plus grand code postal est {plus_grand_code_postal[\"Nom_commune\"]} \\\n    son code postal est {plus_grand_code_postal[\"Code_postal\"]}')\nplus_grande_longitude = sorted(communes, key = lambda x:x['gps'][0], reverse= True)[0]\nprint(f'la commune qui a la plus grande longitude est {plus_grande_longitude[\"Nom_commune\"]} sa longitude est {plus_grande_longitude[\"gps\"][0]}')\n\nfor c in communes:\n    if c[\"Nom_commune\"] == \"MANOSQUE\": manosque = c\n\ndef distance(ville):\n    longA, latA = manosque[\"gps\"]\n    longB, latB = ville[\"gps\"]\n    x = (longB - longA) * cos((latA+latB)/2)\n    y = latB - latA\n    z = sqrt(x**2 + y**2)\n    d = 1852 * 60 * z\n    return d\nplus_loin_manosque = sorted(communes, key = lambda x:distance(x), reverse= True)[0]\nprint(f'la commune qui a la plus loin de Manosque est {plus_loin_manosque[\"Nom_commune\"]}, elle est \u00e0 {distance(plus_loin_manosque)/1000} km')\n</code></pre> <ol> <li> <p>On commence par comparer les  codes Unicode du premier caract\u00e8re de chaque cha\u00eene, puis en cas d'\u00e9galit\u00e9 le second caract\u00e8re, et ainsi de suite comme dans un dictionnaire. Attention aux majuscules et aux nombres, '11' est plus petit que '2' !\u00a0\u21a9</p> </li> </ol>"},{"location":"donnees-en-tables/5-fusionner-des-tables/","title":"Fusionner des tables","text":""},{"location":"donnees-en-tables/5-fusionner-des-tables/#reunion-ou-concatenation","title":"R\u00e9union (ou Concat\u00e9nation)","text":"<p>Reprenons notre table de pays, pour y ajouter 2 pays, l'Espagne et le Portugal.</p> <pre><code>&gt;&gt;&gt; pays = [('France', 'Paris', 68),\n... ('Allemagne', 'Berlin', 82),\n... ('Italie', 'Rome', 60)]\n</code></pre> <p>Et le tableau de nouveaux pays. </p> <pre><code>&gt;&gt;&gt; nouveau_pays = [('Espagne', 'Madrid', 47), ('Portugal', 'Lisbonne', None)]\n</code></pre> <p>Remarque : Pour un tableau de tableaux ou de p-uplets, il faut veiller \u00e0 ce que les colonnes soient les m\u00eames. S'il manque une information, on compl\u00e8te avec <code>None</code><sup>1</sup>. </p> <p>On peut simplement utiliser l'op\u00e9rateur <code>+</code> qui cr\u00e9\u00e9 un nouveau tableau :</p> <pre><code>&gt;&gt;&gt; pays + nouveau_pays\n[('France', 'Paris', 68), \n ('Allemagne', 'Berlin', 82), \n ('Italie', 'Rome', 60),\n ('Espagne', 'Madrid', 47), \n ('Portugal', 'Lisbonne', None)]\n ```\n\nOu encore la m\u00e9thode `.extend()` qui modifie la variable `pays` : \n\n``` py\n&gt;&gt;&gt; pays.extend(nouveau_pays)\n&gt;&gt;&gt; pays\n[('France', 'Paris', 68), ('Allemagne', 'Berlin', 82), ('Italie', 'Rome', 60),\n ('Espagne', 'Madrid', 47), ('Portugal', 'Lisbonne', None)]\n</code></pre> <p>Si on ne veut ajouter qu'un seul \u00e9l\u00e9ment (=un seul tableau pour un pays), on peut utiliser <code>.append()</code> : </p> <pre><code>&gt;&gt;&gt; pays.append(('Belgique', 'Bruxelles', 11)) \n</code></pre> <p> Attention, la concat\u00e9nation peut mener \u00e0 des doublons dans une table ou des incoh\u00e9rences :</p> <pre><code>&gt;&gt;&gt; pays.append(('Pays-Bas',17, 'Amsterdam'))\n&gt;&gt;&gt; pays\n[('France', 'Paris', 68),\n ('Allemagne', 'Berlin', 82),\n ('Italie', 'Rome', 60),\n ('Espagne', 'Madrid', 47),\n ('Portugal', 'Lisbonne', None),\n ('Belgique', 'Bruxelles', 10),\n ('Pays-Bas', '17', 'Amsterdam')]\n</code></pre> <p>Note: On peut supprimer la ligne avec <code>del(pays[6])</code> et pour \u00e9viter les doublons cr\u00e9\u00e9s par <code>pays + pays_sud</code> on pr\u00e9f\u00e8rera faire :</p> <pre><code>&gt;&gt;&gt; pays_sud = [('Espagne', 'Madrid', 47), ('Portugal', 'Lisbonne', None], ('Italie', 'Rome', 60), , ('Grece', 'Athenes', 10)]\n&gt;&gt;&gt; pays = pays + [p for p in pays_sud if p not in pays]\n</code></pre> <p>Et \u00e9viter des incoh\u00e9rences en v\u00e9rifiant les domaines de valeur , par exemple que la population est un nombre entier.</p> <pre><code>&gt;&gt;&gt; pays.extend([p for p in pays_sud if type(p[2]) == int])\u2003\n</code></pre>"},{"location":"donnees-en-tables/5-fusionner-des-tables/#fusion-ou-jointure","title":"Fusion (ou Jointure)","text":"<p>On peut aussi vouloir r\u00e9unir les informations concernant les m\u00eames pays \u00e0 travers plusieurs tables, par exemple :</p> <pre><code>pib = [['France', 2.5], ['Allemagne', 3.7]]\n</code></pre> <p>il faut alors rajouter le nouveau champs ligne par ligne (avec None pour les informations manquantes) : </p> <pre><code>pays = [['France', 'Paris', '68'],\n ['Allemagne', 'Berlin', '82'],\n ['Italie', 'Rome', '60']]\n\npib = [('France', '2.5'),\n ('Allemagne', '3.7')]\n\nfor ligne_pays in pays:                       # pour chaque ligne de pays\n    for ligne_pib in pib:                     # parcourir les lignes de pib\n        if ligne_pays[0] == ligne_pib[0]:     # si c'est le meme pays\n            ligne_pays.append( ligne_pib[1] ) # alors on ajoute le pib \u00e0 la fin\n            break                             # inutile de continuer \u00e0 parcourir pib\n    if len(ligne_pays) == 3 : ligne_pays.append(None)   # on n'a pas trouv\u00e9 de pib\n</code></pre> <p>A noter la derni\u00e8re ligne qui permet de conserver l'int\u00e9grit\u00e9 de la table en ajoutant un champ <code>None</code> si le PIB d'un pays n'est pas pr\u00e9sent.</p> <p>Pour un tableau de p-uplets, les p-uplets sont immuables et la m\u00e9thode <code>.append()</code> ne fonctionne pas, il faut cr\u00e9\u00e9r un nouveau p-uplet  pour chaque ligne, par exemple: </p> <pre><code>pays = [('France', 'Paris', '68'),\n ('Allemagne', 'Berlin', '82'),\n ('Italie', 'Rome', '60')]\n\npib = [('France', '2.5'),\n ('Allemagne', '3.7')]\n\nfor ligne_pays in range(len(pays)):           # pour chaque ligne de pays\n    for ligne_pib in pib:                     # parcourir les lignes de pib\n        if pays[ligne_pays][0] == ligne_pib[0]:     # si c'est le meme pays\n            pays[ligne_pays] = pays[ligne_pays] + (ligne_pib[1], ) # on ajoute le pib \u00e0 la fin\n            break                             # inutile de continuer \u00e0 parcourir pib\n    if len(pays[ligne_pays]) == 3 :    # on n'a pas trouv\u00e9 de pib\n        pays[ligne_pays] = pays[ligne_pays] + (None, ) # on complete le puplet avec None\n</code></pre> <p>Et pour un tableau de dictionnaire, on rajoute un couple de cl\u00e9-valeur \u00e0 chaque dictionnaire du tableau :</p> <pre><code>pays = [{'Capitale': 'Paris', 'Pays': 'France', 'Population (ml)': 68}, \\\n        {'Capitale': 'Berlin', 'Pays': 'Allemagne', 'Population (ml)': 82}, \\\n        {'Capitale': 'Rome', 'Pays': 'Italie', 'Population (ml)': 60}]\n\npib = [('France', '2.5'),\n ('Allemagne', '3.7')]\n\nfor ligne_pays in pays:                       # pour chaque ligne de pays\n    for ligne_pib in pib:                     # parcourir les lignes de pib\n        if ligne_pays['Pays'] == ligne_pib[0]:     # si c'est le meme pays\n            ligne_pays['PIB'] = ligne_pib[1] # alors on ajoute le pib \u00e0 lacl\u00e9 PIB\n            break                             # inutile de continuer \u00e0 parcourir pib\n    if len(ligne_pays) == 3 : ligne_pays['PIB'] = None   # on n'a pas trouv\u00e9 de pib\n</code></pre> <ol> <li> <p>Ce n'est pas necessaire pour un tableau de dictionnaires.\u00a0\u21a9</p> </li> </ol>"},{"location":"langages-et-programmation/","title":"Langages et programmation","text":"<p>Conna\u00eetre les fondements th\u00e9oriques de l'informatique permet \u00e0 la fois de r\u00e9soudre des probl\u00e8mes complexes et de comprendre les limites de ce que les ordinateurs peuvent accomplir.</p> <p>La calculabilit\u00e9 r\u00e9pond \u00e0 la question fondamentale de ce qui peut \u00eatre calcul\u00e9 et ce qui ne le peut pas, pilier sur lequel repose toute la th\u00e9orie de l'informatique. </p> <p>La r\u00e9cursivit\u00e9, quant \u00e0 elle, est une approche de r\u00e9solution de probl\u00e8mes o\u00f9 une fonction se d\u00e9finit en s'appelant elle-m\u00eame. Nous explorerons la puissance et la beaut\u00e9 de la r\u00e9cursivit\u00e9, tout en apprenant \u00e0 l'utiliser de mani\u00e8re efficace et \u00e9l\u00e9gante dans nos programmes.</p> <p>La modularit\u00e9 est un principe de conception essentiel en informatique. Nous d\u00e9couvrirons comment d\u00e9couper nos programmes en modules plus petits et ind\u00e9pendants, afin de les rendre plus faciles \u00e0 d\u00e9velopper, maintenir et r\u00e9utiliser. </p> <p>Les paradigmes de programmation sont des approches ou des styles diff\u00e9rents pour \u00e9crire des programmes informatiques. Chaque paradigme repr\u00e9sente une mani\u00e8re sp\u00e9cifique de structurer le code, de r\u00e9soudre des probl\u00e8mes et d'interagir avec les donn\u00e9es.</p> <p>Ecrire des programmes en limitant les erreurs qui peuvent survenir est une comp\u00e9tence cruciale pour tout d\u00e9veloppeur, la programmation est un processus it\u00e9ratif, et savoir corriger les bugs fait partie int\u00e9grante de cette d\u00e9marche.</p>"},{"location":"langages-et-programmation/1-programme-en-tant-que-donnee-calculabilite-probleme-arret/","title":"Programme en tant que donn\u00e9e, Calculabilit\u00e9, Probl\u00e8me de l'arr\u00eat","text":""},{"location":"langages-et-programmation/1-programme-en-tant-que-donnee-calculabilite-probleme-arret/#programme-en-tant-que-donnee","title":"Programme en tant que donn\u00e9e","text":"<p>On a vu en classe de premi\u00e8re avec l'architecture von Neumann que les donn\u00e9es et les programmes sont stock\u00e9s ensembles dans la m\u00e9moire de l'ordinateur. Rien n'emp\u00eache donc un programme d'utiliser le code d'un autre programme en m\u00e9moire pour le lire, l'\u00e9crire ou l'ex\u00e9cuter. </p> <p>Cours</p> <p>La dualit\u00e9 entre programme et donn\u00e9es est un concept fondamental en informatique : les programmes sont des donn\u00e9es comme les autres.</p> <p>Un programme peut donc lire un programme en entr\u00e9e, \u00e9crire un programme en sortie ou ex\u00e9cuter un autre programme.  </p> <p>C'est une situation qui est souvent rencontr\u00e9e en pratique :</p> <ul> <li>Les interpr\u00e9teurs sont des programmes qui prennent en entr\u00e9e la description d'un autre programme et qui simulent ce programme. On a vu que le bytecode d'un programme Python est interpr\u00e9t\u00e9. Lorsqu'on cherche \u00e0 lancer ce programme, l'interpr\u00e9teur lit et ex\u00e9cute ce programme bytecode.</li> <li>Les compilateurs sont aussi des bons exemples. Le langage C est un langage compil\u00e9 : une fois le code source termin\u00e9e, le compilateur (qui est un logiciel comme un autre) \"transforme\" ce code source en langage machine.</li> <li>Un syst\u00e8me d'exploitation peut \u00eatre vu comme un programme qui fait \"tourner\" d'autres programmes</li> <li>Les logiciels de t\u00e9l\u00e9chargement permettent de t\u00e9l\u00e9charger d'autres logiciels.</li> <li>Il existe des programmes de d\u00e9tection d'erreurs (ou preuve de correction)<sup>1</sup> capables de lire d'autres programmes afin de d\u00e9tecter certaines erreurs dans leur code source.  </li> </ul> <p>Dans le m\u00eame ordre d'id\u00e9e, une fonction Python peut lire et ex\u00e9cuter une autre fonction, par exemple la fonction <code>calcule</code> ci-dessous admet deux param\u00e8tres, une fonction <code>f</code> et une valeur <code>x</code>.</p> <pre><code>import math\n\ndef calcule(f, x):\n    print(f(x))\n\ncalcule(math.sqrt, 5)\n</code></pre>"},{"location":"langages-et-programmation/1-programme-en-tant-que-donnee-calculabilite-probleme-arret/#calculabilite-et-probleme-de-la-decision-entscheidungsproblem","title":"Calculabilit\u00e9 et probl\u00e8me de la d\u00e9cision (Entscheidungsproblem)","text":"David Hilbert  (1862-1943)  <p>Si nous avons l'intuition que l'on peut trouver un algorithme qui donne la solution pour la plupart des fonctions et des probl\u00e8mes math\u00e9matiques que nous connaissons (somme, diff\u00e9rence, produit, division, puissance, PGCD, etc\u2026), une question fondamentale de l'informatique th\u00e9orique est de d\u00e9terminer si un probl\u00e8me donn\u00e9 peut \u00eatre \"calcul\u00e9\"<sup>2</sup>  ou non par un algorithme que l'on peut programmer.  Est-il possible de tout programmer ? Suffit-il de donner la sp\u00e9cification exacte d'une fonction ou d'un probl\u00e8me pour que l'on puisse la r\u00e9aliser \u00e0 l'aide d'un algorithme ad\u00e9quat ? </p> <p>Autrement dit, est-ce que toute fonction est calculable ?  Et de la m\u00eame fa\u00e7on, est-ce que tout probl\u00e8me de d\u00e9cision (dont la r\u00e9ponse est vraie ou fausse) est d\u00e9cidable ? Ce probl\u00e8me est connu sous le nom du probl\u00e8me de la d\u00e9cision, ou sous son nom d'origine en allemand Entscheidungsproblem, en r\u00e9f\u00e9rence \u00e0 la question pos\u00e9e par David Hilbert en 1928. </p> <p>Cours</p> <p>On dit qu'une fonction est calculable ou qu'un probl\u00e8me de d\u00e9cision est d\u00e9cidable lorsqu'il existe un algorithme pour le r\u00e9soudre : c'est-\u00e0-dire qu'il prend en entr\u00e9e la donn\u00e9e du probl\u00e8me, effectue des calculs bien d\u00e9finis, et termine toujours en temps fini<sup>3</sup>  en r\u00e9pondant \u00e0 la question pos\u00e9e. </p> <p>Deux math\u00e9maticiens, Alonzo Church et Alan Turing vont chacun \u00e0 leur mani\u00e8re r\u00e9pondre \u00e0 cette question. </p>"},{"location":"langages-et-programmation/1-programme-en-tant-que-donnee-calculabilite-probleme-arret/#church-et-le-lambda-calcul","title":"Church et le lambda calcul","text":"Alonzo Church (1903-1995)  <p>Cours</p> <p>Entre 1932 et 1936, Alonzo Church a identifi\u00e9 une classe de fonctions arithm\u00e9tiques qui semblait poss\u00e9der les propri\u00e9t\u00e9s intuitives des fonctions calculables : le lambda-calcul (ou \u03bb-calcul).</p> <p>L'id\u00e9e de base du lambda-calcul est que tout est fonction. Il est possible de fabriquer des fonctions en disant que si \\(E\\) est une expression, on cr\u00e9e la fonction qui \u00e0 \\(x\\) fait correspondre l'expression \\(E\\) ; on \u00e9crit \\(\u03bbx.E\\) cette nouvelle fonction. </p> Notation classique \u03bb-calcul \\(f:N\u2192 N\\)\\(x \u27fcE\\) \\(\u03bbx.E\\) \\(g:N\u2192 N\\)\\(x \u27fc2x+1\\) \\(\u03bbx.2x + 1\\) \\(h:N\u2192 N\\)\\(x \u27fcx^2\\) \\(\u03bbx.x\u00d7x\\) <p>Une fonction est en particulier exprim\u00e9e par une expression qui peut contenir des fonctions qui ne sont pas encore d\u00e9finies : ces derni\u00e8res sont remplac\u00e9es par des variables. Par exemple il est possible de construire :</p> <ul> <li>la fonction constante \u00e9gale \u00e0 \\(x\\), \u00e0 savoir \\(\u03bby.x\\) , puis</li> <li>la fonction qui fabrique les fonctions constantes, o\u00f9 la constante \\(x\\) est un param\u00e8tre : \\(\u03bbx.(\u03bby.x)\\).</li> <li>etc.</li> </ul> <p>Le lambda-calcul fournit un langage pr\u00e9cis pour d\u00e9crire les fonctions et les simplifier. La fonction \\(\u03bbx.(\u03bby.x)\\) peut aussi s'\u00e9crire \\(\u03bbx.\u03bby.x\\), c'est-\u00e0-dire une fonction qui prend deux param\u00e8tres \\(x\\) et \\(y\\) et renvoie simplement la valeur \\(x\\).</p> <p>En Python la fonction \\(\u03bbx.x \u00d7 x\\) qui renvoie le carr\u00e9 d'un nombre peut de programmer rapidement :</p> <pre><code>&gt;&gt;&gt; f = lambda x: x*x  \n&gt;&gt;&gt; f(3)\n9\n</code></pre> <p>Les fonctions lambda sont principalement utilis\u00e9es pour \u00eatre utilis\u00e9es par d'autres fonctions qui prennent une fonction comme argument, par exemple : <pre><code>&gt;&gt;&gt; l = ['id01', 'id10', 'id02', 'id12', 'id03', 'id13']\n&gt;&gt;&gt; tri_l = sorted(l, key=lambda x: int(x[2:]))                           \n&gt;&gt;&gt; tri_l\n['id01', 'id02', 'id03', 'id10', 'id12', 'id13']\n</code></pre></p> <p>Le lambda-calcul est \u00e0 l'origine des fonctions lambda en Python (et dans d'autres langages comme Java, C#) et  des langages fonctionnels : CAML, Haskell, LISP, Scala\u2026 </p>"},{"location":"langages-et-programmation/1-programme-en-tant-que-donnee-calculabilite-probleme-arret/#la-machine-de-turing","title":"La machine de Turing","text":"Alan Turing (1912-1954)  <p>Alan Turing a publi\u00e9 en 1936 un article intitul\u00e9 : \u00ab On Computable Numbers, with an Application to the Entscheidungsproblem \u00bb<sup>4</sup> dans lequel il d\u00e9crit un dispositif que son ma\u00eetre de th\u00e8se Alonzo Church appellera une machine de Turing. </p> <p>Cours</p> <p>Quoique son nom de \u00ab machine \u00bb puisse conduire \u00e0 croire le contraire, une machine de Turing est un mod\u00e8le abstrait (invent\u00e9 avant l'apparition des ordinateurs) qui d\u00e9finit ce qu'est un calcul.</p> <p>La machine de Turing est \u00e0 l'origine des ordinateurs et des langages de programmation imp\u00e9ratifs et fait d'Alan Turing le \u00ab p\u00e8re \u00bb de la science informatique.</p> <p> </p> <p> </p> <p>Une machine de Turing comporte les \u00e9l\u00e9ments suivants :</p> <ul> <li> <p>Un ruban suppos\u00e9 infini contenant des caract\u00e8res (typiquement des  0 et 1 mais pas que) ou vide (blanc ou \u25cf).</p> </li> <li> <p>Une t\u00eate de lecture/\u00e9criture qui peut se d\u00e9placer vers la gauche ou vers la droite du ruban<sup>5</sup>. </p> </li> <li> <p>Une variable d'\u00e9tat qui m\u00e9morise l'\u00e9tat courant de la machine de Turing.</p> </li> <li> <p>Une table d'actions ou programme  qui indique quel symbole \u00e9crire, comment d\u00e9placer la t\u00eate de lecture, quel est le nouvel \u00e9tat, en fonction du symbole lu sur le ruban et de l'\u00e9tat courant de la machine. Si aucune action n'existe pour une combinaison donn\u00e9e d'un symbole lu et d'un \u00e9tat courant, la machine s'arr\u00eate.</p> </li> </ul> <p>On peut aussi repr\u00e9senter un programme sous la forme d'un graphe orient\u00e9 avec les changements d'\u00e9tats et en \u00e9crivant sur les branches le caract\u00e8re lu, le caract\u00e8re \u00e9crit et le d\u00e9placement (dans l'ordre)</p> <p> </p> <p>Prenons l'exemple d'une machine de Turing permettant d'\u00e9crire \\(1/3\\) en binaire<sup>6</sup>, c'est \u00e0 dire une suite de 0 et de 1 cons\u00e9cutifs, 010101010101..., sur un ruban vide. Elle peut se repr\u00e9senter sous la forme d'une table d'action ou d'un graphe :</p> <p></p> <p> </p> <p>L'ex\u00e9cution de cette machine serait (la position de la t\u00eate de lecture/\u00e9criture sur le ruban est inscrite en caract\u00e8res surlign\u00e9s) :</p> \u00c9tape \u00c9tat Ruban 1 e1 0 2 e2 01 3 e1 010 4 e2 0101 5 e1 01010 6 e2 010101 ... e1 010101... <p>Le comportement de cette machine peut \u00eatre d\u00e9crit comme une boucle infinie :</p> <ul> <li>Elle d\u00e9marre son ex\u00e9cution dans l'\u00e9tat e1, ajoute un 0 et se d\u00e9place \u00e0 droite.</li> <li>Puis elle passe \u00e0 l'\u00e9tat e2, ajoute un 1 et se d\u00e9place \u00e0 droite.</li> <li>Elle revient dans l'\u00e9tat e1 et r\u00e9it\u00e8re la premi\u00e8re \u00e9tape.</li> </ul> <p>Exercice corrig\u00e9</p> <p>Construire une machine de Turing qui ajoute 1 \u00e0 un nombre binaire.</p> Aide <p>Si le nombre binaire se termine par 0, par exemple : 1001010 + 1 = 1001011, dans ce cas il suffit de remplacer le dernier 0 par un 1. On parcourt le nombre de gauche \u00e0 droite jusqu'\u00e0 la fin, si on trouve un 0, on le remplace par un 1 et on passe \u00e0 l'\u00e9tat final.</p> <p>Si le nombre binaire se termine par 1, par exemple : 1001011 + 1 = 1001100, dans ce cas apr\u00e8s avoir parcouru le nombre de gauche \u00e0 droite, on revient de droite \u00e0 gauche, tant qu'on trouve un 1, on le remplace par un 0, lorsqu'on trouve la premi\u00e8re occurrence de 0, on la remplace par 1 puis on passe \u00e0 l'\u00e9tat final.</p> <p>Cas particulier de nombre se terminant par 1, un nombre peut \u00eatre form\u00e9 seulement par des 1, par exemple : 1111111 + 1 = 10000000 dans ce cas, on remplace tous les 1 par 0 et on ins\u00e8re un 1 dans la premi\u00e8re case vide \u00e0 gauche.</p> R\u00e9ponse <p>La machine de Turing se comporte de la fa\u00e7on suivante:</p> <ul> <li>Au d\u00e9but elle est dans l'\u00e9tat e1 et parcourt le ruban vide, de la gauche vers la droite sans modifier le ruban, jusqu'\u00e0 trouver un nombre en binaire. Elle passe alors dans l'\u00e9tat e2.</li> <li>Dans l'\u00e9tat e2, elle parcourt le nombre en binaire, de la gauche vers la droite sans modifier les chiffres du ruban, jusqu'\u00e0 trouber le dernier bit. Elle passe alors dans l'\u00e9tat e3.</li> <li> <p>Dans l'\u00e9tat e3, elle parcourt les chiffres du nombre en binaire de la droite vers la gauche cette fois ci : </p> <ul> <li>si elle lit un 1, elle \u00e9crit 0, se d\u00e9place \u00e0 gauche et reste \u00e0 l'\u00e9tat e3.</li> <li>si elle lit un 0, elle \u00e9crit 1, se d\u00e9place \u00e0 gauche et passe \u00e0 l'\u00e9tat final.</li> <li>si elle trouve une case vide, c'est qu'elle a parcouru tout le nombre sans trouver de 0, elle \u00e9crit donc un 1, se d\u00e9place \u00e0 gauche et passe \u00e0 l'\u00e9tat final.</li> </ul> </li> </ul> <p></p>"},{"location":"langages-et-programmation/1-programme-en-tant-que-donnee-calculabilite-probleme-arret/#these-de-church-ou-turing-church","title":"Th\u00e8se de Church ou Turing-Church","text":"<p>Turing montra, en 1937, que la classe des fonctions calculables, au sens de Church, \u00e9tait \u00e9quivalente \u00e0 la classe des fonctions programmables sur les machines imaginaires qu'il avait con\u00e7ues ce qui a conduit \u00e0 la  \u00ab Th\u00e8se de Church ou Turing-Church\u00bb : pour certaines fonctions il n'existe pas d'algorithme capable de calculer l'image d'un nombre, ces fonctions sont dites non-calculables. R\u00e9ciproquement, s'il existe un algorithme capable de calculer l'image d'un nombre par une fonction, alors cette fonction  est dite calculable.</p> <p>Cours</p> <p>Ils \u00e9noncent le principe selon lequel tout ce qui est calculable peut \u00eatre calcul\u00e9 indiff\u00e9remment sur l'un de ces deux mod\u00e8les et donc la notion de calculabilit\u00e9 ne d\u00e9pend pas du langage de programmation utilis\u00e9.</p> <p>Aujourd'hui, la th\u00e8se de Turing-Church est remise en cause par les circuits quantiques<sup>7</sup>.</p>"},{"location":"langages-et-programmation/1-programme-en-tant-que-donnee-calculabilite-probleme-arret/#le-probleme-de-larret","title":"Le probl\u00e8me de l'arr\u00eat","text":"<p>Un programme qui permettrait de tester si un autre programme va finir par s'arr\u00eater, quel que soit le cas trait\u00e9, serait d'une grande aide pour tous les d\u00e9veloppeurs du monde !  Grace aux travaux d'Alonzo Church et d'Alan Turing, on sait qu'un tel programme ne peut pas exister. </p> <p>Cours</p> <p>Le probl\u00e8me de l'arr\u00eat est ind\u00e9cidable.</p> <p>Partons du principe que ce programme \"Arr\u00eat?\" existe (raisonnement par l'absurde). \"Arr\u00eat?\" prend en entr\u00e9e un programme P et r\u00e9pond True si le programme P s'arr\u00eate, et False s'il ne s'arr\u00eate jamais.</p> <p> </p> <p>Construisons maintenant un autre programme \"Paradoxe\"<sup>8</sup> qui  prend en entr\u00e9e un programme P et lui applique le programme Arr\u00eat: \u2022   Si \"Arr\u00eat?\" renvoie True, \"Paradoxe\" entre dans une boucle infinie (il ne s'arr\u00eate jamais) \u2022   Si \"Arr\u00eat?\" renvoie False,  \"Paradoxe\" s'arr\u00eate.</p> <p> </p> <p>\"Paradoxe\" est un programme comme les autres, on peut donc l'utiliser en entr\u00e9e de lui-m\u00eame. </p> <p> </p> <p>Analysons ce qui se passe :</p> <ul> <li>Si le programme \"Paradoxe\" en entr\u00e9e est un programme qui s'arr\u00eate, alors \"Arr\u00eat?\" r\u00e9pond \"True\", donc  \"Paradoxe\" tombe dans une boucle infinie, donc \"Paradoxe\"  ne s'arr\u00eate pas. C'est une contradiction !</li> <li>Si \"Paradoxe\" en entr\u00e9e est un programme qui ne s'arr\u00eate pas, alors \"Arr\u00eat?\" r\u00e9pond \"False\", donc \"Paradoxe\"  s'arr\u00eate. C'est aussi une contradiction !</li> </ul> <p>Dans les deux cas, nous avons une contradiction, nous pouvons donc en conclure que le programme \"Paradoxe\"  ne peut pas exister. Et si le programme \"Paradoxe\" ne peut pas exister, cela signifie que le programme \"Arr\u00eat?\" ne peut pas exister non plus (puisque \u00ab Paradoxe \u00bb se base sur \"Arr\u00eat?\").</p> <p>Nous venons donc bien de d\u00e9montrer que le programme \"Arr\u00eat?\" ne peut pas exister. Le probl\u00e8me de l'arr\u00eat est donc ind\u00e9cidable.</p> <p>Cette id\u00e9e d'avoir un probl\u00e8me ind\u00e9cidable, autrement dit qui ne peut pas \u00eatre r\u00e9solu par un algorithme, peut \u00eatre g\u00e9n\u00e9ralis\u00e9e : il existe en effet de nombreux probl\u00e8mes ind\u00e9cidables, par exemple montrer que l'image de deux fonctions est la m\u00eame pour tous les nombres, que la suite de Syracuse se termine toujours par les valeurs 4, 2, 1, le probl\u00e8me de correspondance de Post, etc.</p> <p>Une vid\u00e9o pour en savoir plus sur l'Entscheidungsproblem :</p> <ol> <li> <p>Le d\u00e9veloppement de programmes de \"d\u00e9tection d'erreurs\" a connu une forte croissance en France, notamment depuis l'accident du vol 501 d'Ariane 5 du 4 juin 1996 ou encore de la mise au point du m\u00e9tro automatique Meteor (ligne 14 \u00e0 Paris).\u00a0\u21a9</p> </li> <li> <p>Le mot \u00ab calcul \u00bb vient de calculus qui signifie caillou en latin. Pour se convaincre de la pertinence de cette origine, il suffit d'\u00e9voquer le d\u00e9compte des nombres \u00e0 l'aide de petits cailloux\u00a0\u21a9</p> </li> <li> <p>La notion de probl\u00e8me d\u00e9cidable ne fait aucune hypoth\u00e8se sur le temps pass\u00e9 \u00e0 r\u00e9soudre la question \u2014 \u00e0 part qu'il soit toujours fini. Ainsi, \u00e0 l'int\u00e9rieur des probl\u00e8mes d\u00e9cidables, il y a tout ce qui concerne la complexit\u00e9, entre les probl\u00e8mes solubles dans un temps polynomial (P), et non polynomial (NP). Par exemple le probl\u00e8me du remplissage d'un sac \u00e0 dos, ne pouvant supporter plus d'un certain poids, avec tout ou partie d'un ensemble donn\u00e9 d'objets ayant chacun un poids et une valeur. Les objets mis dans le sac \u00e0 dos doivent maximiser la valeur totale, sans d\u00e9passer le poids maximum. Ce probl\u00e8me est difficile du point de vue de la complexit\u00e9 et l'on ne conna\u00eet pas de m\u00e9thode g\u00e9n\u00e9rale pour construire une solution optimale, mais il est certainement d\u00e9cidable, il suffit par exemple d'\u00e9num\u00e9rer toutes les solutions envisageables.\u00a0\u21a9</p> </li> <li> <p>Sur les nombres calculables avec une application au probl\u00e8me de la d\u00e9cision :https://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf.\u00a0\u21a9</p> </li> <li> <p>Attention, dans certains cas c'est le ruban qui se d\u00e9place au lieu de la t\u00eate de lecture, les d\u00e9placements sont alors invers\u00e9s.\u00a0\u21a9</p> </li> <li> <p>Source: https://fr.wikipedia.org/wiki/Machine_de_Turing.\u00a0\u21a9</p> </li> <li> <p>https://interstices.info/algorithmes-quantiques-quand-la-physique-quantique-defie-la-these-de-church-turing \u21a9</p> </li> <li> <p>Un paradoxe est une proposition qui contient une contradiction logique, ou un raisonnement qui aboutit \u00e0 une absurdit\u00e9. Le paradoxe du menteur en est un exemple c\u00e9l\u00e8bre.\u00a0\u21a9</p> </li> </ol>"},{"location":"langages-et-programmation/2-recursivite/","title":"R\u00e9cursivit\u00e9","text":""},{"location":"langages-et-programmation/2-recursivite/#recursivite-simple","title":"R\u00e9cursivit\u00e9 simple","text":"<p>Une fonction peut \u00eatre appel\u00e9e n'importe o\u00f9 dans un programme (apr\u00e8s sa d\u00e9finition), y compris par elle-m\u00eame.</p> <p>Cours</p> <p>Une fonction r\u00e9cursive est une fonction qui s'appelle elle-m\u00eame<sup>1</sup>.</p> <p>Prenons pour exemple une fonction qui renvoie le produit de tous les nombres entiers entre 1 et \\(n\\). Ce produit est appel\u00e9 factorielle de \\(n\\) et not\u00e9 \\(n!\\).</p> <p>\\(n!  =  1  \\times 2  \\times 3  \\times 4  \\times ...  \\times (n-1)  \\times n\\) </p> <p>Un programme it\u00e9ratif<sup>2</sup>: peut s'\u00e9crire simplement avec un boucle <code>for</code> qui multiplie tous les entiers allant de <code>1</code> \u00e0 <code>n</code> entre eux :</p> <pre><code>def fact(n):\n    f = 1\n    for i in range(1, n + 1):\n        f = f * i\n    return f\n</code></pre> <p>Mais il est aussi possible de remarquer que \\(n!  =  (n-1)!  \\times n\\) et que \\(1!  =  1\\), ce qui permet d'\u00e9crire un programme r\u00e9cursif suivant : </p> <pre><code>def fact(n):\n    if n == 1:\n        return 1\n    return  fact(n-1) * n\n</code></pre> <p>On peut toujours transformer une fonction r\u00e9cursive en it\u00e9rative et vice versa.</p>"},{"location":"langages-et-programmation/2-recursivite/#importance-de-la-clause-darret","title":"Importance de la clause d'arr\u00eat","text":"<p>Cours</p> <p>Une fonction r\u00e9cursive doit toujours comporter une clause d'arr\u00eat, pour ne pas \u00ab boucler \u00bb. </p> <p>La fonction suivante :</p> <p><pre><code>def fact(n):\n    return fact(n-1) * n\n</code></pre> ne s'arr\u00eatera jamais car il manque une clause d'arr\u00eat <code>if n == 1 : \u2026</code> !</p> <p>: warning: Il faut toujours prendre soin de bien d\u00e9finir la clause d'arr\u00eat.  Ici que se passe-t-il si on appelle  <code>fact(5.1)</code> ou <code>fact(-1)</code>  ? On pr\u00e9f\u00e8rera peut-\u00eatre  <code>if n &lt;= 1: \u2026</code> ou utiliser des assertions pour \u00e9viter ces cas.</p> <p>En pratique un appel r\u00e9cursif doit obligatoirement comporter une instruction conditionnelle et une variable de contr\u00f4le : par exemple un entier naturel qui d\u00e9cro\u00eet strictement \u00e0 chaque appel r\u00e9cursif jusqu'\u00e0 atteindre la valeur d'un cas de base.</p>"},{"location":"langages-et-programmation/2-recursivite/#recursivite-croisee-multiple","title":"R\u00e9cursivit\u00e9 crois\u00e9e, multiple","text":"<p>Cours</p> <p>Dans certains cas, une fonction appelle une autre fonction qui elle-m\u00eame appelle la premi\u00e8re. C'est une r\u00e9cursivit\u00e9 crois\u00e9e.</p> <p>Par exemple pour tester si un nombre est pair ou impair (sans utiliser l'op\u00e9rateur <code>%2</code>)</p> <pre><code>def pair(n):\n    if n == 0: return True\n    else: return impair(n-1)\ndef impair(n):\n    if n == 0: return False\n    else: return pair(n-1)\n</code></pre> <p>Cours</p> <p>Il arrive aussi qu'une fonction s'appelle plusieurs fois, c'est une r\u00e9cursivit\u00e9 multiple.</p> <p>Par exemple la suite de Fibonacci est d\u00e9finie par \\(u_0 = 0\\), \\(u_1 = 1\\) et pour \\(n &gt; 1 : u_n = u_{n-1} + u_{n-2}\\).</p> <pre><code>def fib(n):\n    if n &lt; 2:\n        return n\n    return fib(n\u20131) + fib(n-2)\n</code></pre> <p>Si la r\u00e9cursivit\u00e9 est plus \u00e9l\u00e9gante et facile \u00e0 lire qu'un programme it\u00e9ratif, on atteint tr\u00e8s vite ses limites en complexit\u00e9s<sup>3</sup> spatiale et temporelle<sup>4</sup>.</p>"},{"location":"langages-et-programmation/2-recursivite/#complexite-spatiale-et-pile-dexecution","title":"Complexit\u00e9 spatiale et pile d'ex\u00e9cution","text":"<p>Analysons ce qu'il se passe si on appelle la fonction r\u00e9cursive <code>fact(n)</code> quand <code>n</code> devient relativement grand.</p> <pre><code>&gt;&gt;&gt; fact(1000)\nTraceback (most recent call last):\n\u2026\nRecursionError: maximum recursion depth exceeded in comparison\n</code></pre> <p>Une erreur est lev\u00e9e , alors que le programme it\u00e9ratif fonctionne parfaitement !</p> <p>Pour g\u00e9rer des fonctions qui appellent d'autres fonctions, le syst\u00e8me utilise une \"pile d'ex\u00e9cution\". Une pile d'ex\u00e9cution permet d'enregistrer des informations sur les fonctions en cours d'ex\u00e9cution dans un programme. C'est une pile, car les ex\u00e9cutions en attente \"s'empilent\" successivement les unes sur les autres.</p> <p>La pile pour calculer <code>fact(4)</code> est la suivante :</p> <ul> <li>1er appel de la fonction <code>fact</code> avec n = 4 : n n'est pas \u00e9gal \u00e0 1, la fonction \"empile\" <code>fact(4)</code> et appelle <code>fact(3)</code>.</li> <li>2\u00e8me appel de la fonction <code>fact</code> avec n = 3 : n n'est pas \u00e9gal \u00e0 1, la fonction \"empile\" <code>fact(3)</code> et appelle <code>fact(2)</code>.</li> <li>3\u00e8me appel de la fonction <code>fact</code> avec n = 2 : n n'est pas \u00e9gal \u00e0 1, la fonction \"empile\" <code>fact(2)</code> et appelle <code>fact(1)</code>.</li> <li>4\u00e8me appel de la fonction <code>fact</code> avec n = 1 : n est \u00e9gal \u00e0 1, la fonction renvoie <code>1</code>.</li> <li><code>fact(2)</code> est \"d\u00e9pil\u00e9\", il renvoie 2 x 1 = 2.</li> <li><code>fact(3)</code> est \"d\u00e9pil\u00e9\", il renvoie 3 x 2 = 6.</li> <li><code>fact(4)</code> est \"d\u00e9pil\u00e9\" et peut enfin \u00eatre calcul\u00e9, il renvoie 4 x 6 = 26.</li> </ul> <p> </p> <p>Cours</p> <p>Complexit\u00e9 spatiale : La r\u00e9cursivit\u00e9 utilise une pile d'appels qui est un espace m\u00e9moire particuli\u00e8rement limit\u00e9, cela g\u00e9n\u00e8re rapidement des d\u00e9bordements de capacit\u00e9, c'est le fameux stack overflow !</p>"},{"location":"langages-et-programmation/2-recursivite/#complexite-temporelle","title":"Complexit\u00e9 temporelle","text":"<p>La suite de Fibonacci est d\u00e9finie par  \\(u_0=0\\) , \\(u_1=1\\) et pour \\(n &gt; 1\\) : \\(u_n=u_{n-1}+ u_{n-2}\\).</p> <p>Ce qui se traduit en une programmation it\u00e9rative par :</p> <pre><code>def fib(n):\n    if n &lt; 2:\n        return n\n    else:\n        fn, fn_1 = 1, 0\n        for i in range(2, n+1):\n            fn, fn_1 = fn + fn_1, f_n\n    return b\n</code></pre> <p>Une programmation r\u00e9cursive est une simple traduction mot \u00e0 mot de la d\u00e9finition :</p> <pre><code>def fib(n):\n    if n &lt; 2:\n        return n\n    return fib(n\u20131) + fib(n-2)\n</code></pre> <p>Plus facile \u00e0 concevoir et \u00e0 lire, la programmation r\u00e9cursive devient vite tr\u00e8s lente \u00e0 l'ex\u00e9cution. Comparons les temps d'ex\u00e9cution de ces deux programmes avec le module <code>time</code>.</p> <pre><code>from time import time\n\ndebut = time()\nfib(30)\nduree = time() - debut\nprint(duree, \"secondes\") \n</code></pre> <p>Les r\u00e9sultats obtenus sont les suivants (qui d\u00e9pendent de la machine utilis\u00e9e).</p> n fib(n) it\u00e9ratif fib(n) r\u00e9cursif 10 0.0 secondes 0.0 secondes 20 0.0 secondes 0.005 secondes 30 0.0 secondes 0.61 secondes 40 0.0 secondes 78.21 secondes 100 0.0 secondes \u2026 <p>Alors que la fonction it\u00e9rative est quasi instantan\u00e9e pour toutes les valeurs de <code>n</code> test\u00e9es, la fonction r\u00e9cursive devient tr\u00e8s rapidement extr\u00eamement lente, m\u00eame pour des valeurs de <code>n</code> raisonnables, <code>fib(40)</code> demande plus d'une minute ! Ce n'est pas un probl\u00e8me de complexit\u00e9 spatiale, puisque <code>fib(40)</code> empile au plus 40 appels dans la pile d'appels, on est loin de la limite !</p> <p>Regardons ce qui se passe pour calculer <code>fib(5)</code>. La fonction <code>fib</code> s'appelle 15 fois juste pour calculer <code>fib(5)</code> !</p> <p>et on peut tout de suite imaginer que ce nombre de calculs augmente tr\u00e8s rapidement pour <code>fib(30)</code> ou <code>fib(40)</code>. Ce n'est donc pas un probl\u00e8me de complexit\u00e9 spatiale mais plut\u00f4t un probl\u00e8me de nombre d'op\u00e9rations effectu\u00e9es pendant le calcul :  c'est la complexit\u00e9 temporelle.</p> <p>Cours</p> <p>Complexit\u00e9 temporelle : Dans certains cas, la r\u00e9cursivit\u00e9 augmente le nombre d'op\u00e9rations.</p> <p>Essayons d'en savoir plus sur la complexit\u00e9 de cette fonction en affichant le nombre d'appels de la fonction avec un compteur qui s'incr\u00e9mente \u00e0 chaque appel.</p> <pre><code>def fib(n):\n    global cpt\n    cpt += 1\n    if n &lt; 2:\n        return n\n    return fib(n-1) + fib(n-2)\n\ncpt = 0\nfib(30)\nprint(cpt)\n</code></pre> n cpt 5 15 10 177 20 21 891 30 2 692 537 40 331 160 271 <p>Il y a eu presque 3 millions d'appels alors que <code>fib(30)</code> ne n\u00e9cessite, en th\u00e9orie, que la connaissance de quelques dizaines de valeur ! Et <code>fib(40)</code> n\u00e9cessite plus de 300 millions d'appels !</p> <p>C'est une complexit\u00e9 qui semble de type exponentielle, en \\(O(2^n)\\) <sup>5</sup>, c'est-\u00e0-dire qui ne peut pas \u00eatre ex\u00e9cut\u00e9e en temps acceptable pour n grand<sup>6</sup> !  </p> <p>Rappel</p> <p>Principales complexit\u00e9s temporelles : </p> D\u00e9signation Notation Exemples constante \\(O(1)\\) Acc\u00e8s \u00e0 un \u00e9l\u00e9ment d'un tableau logarithmique \\(O(log(n))\\) Recherche dichotomique (tableau tri\u00e9) lin\u00e9aire \\(O(n)\\) Recherche dans un tableau quasi lin\u00e9aire \\(O(n\\times log(n))\\) Tri fusion quadratique \\(O(n^2)\\) Tri \u00e0 bulle, parcours de matrice exponentielle \\(O(a^n)\\) Sac \u00e0 dos factorielle \\(O(n!)\\) Voyageur de commerce"},{"location":"langages-et-programmation/2-recursivite/#memoisation","title":"M\u00e9mo\u00efsation","text":"<p>Nous avons vu qu'il y a eu presque 3 millions d'appels alors que <code>fib(30)</code> ne n\u00e9cessite, en th\u00e9orie, que la connaissance de quelques dizaines de valeur ! La fonction recalcule de nombreuses fois des valeurs qu'elle a d\u00e9j\u00e0 calcul\u00e9es mais qu'elle n'a pas gard\u00e9 en m\u00e9moire. Par exemple <code>fib(5)</code> calcule 3 fois la valeur de <code>fib(2)</code>. L'algorithme it\u00e9ratif n'a pas ce probl\u00e8me, il retient progresse en calculant les valeurs de la suite dans l'ordre les unes apr\u00e8s les autres.</p> <p>Une solution pour limiter le nombre de calcul consiste \u00e0 ne calculer les termes de la suite qu'une seule fois et de les garder en m\u00e9moire. C'est la memo\u00efzation.</p> <p>Cours</p> <p>La memo\u00efsation consiste \u00e0 garder en m\u00e9moire les valeurs d\u00e9j\u00e0 calcul\u00e9es.</p> <p>Par exemple avec un dictionnaire d\u00e9clar\u00e9 en variable globale<sup>7</sup> : <pre><code>memoise = {} \ndef fib(n):\n    if n in memoise:\n        return memoise[n]\n    if n &lt; 2:\n        memoise[n] = n\n    else :\n        memoise [n] = fib(n-1) + fib(n-2)\n    return memoise[n]\n</code></pre> Ou plus court en renseignant les premi\u00e8res valeurs dans le dictionnaire:</p> <p><pre><code>memoise = {0: 0, 1: 1 } # fib(0) et fib(1)\ndef fib(n):\n    if n not in memoise: \n        memoise[n] = fib(n-1) + fib(n-2)\n    return memoise[n]\n</code></pre> <sup>8</sup></p> <p>Exercice corrig\u00e9</p> <p>En math\u00e9matiques, les coefficients binomiaux, d\u00e9finis pour tout entier naturel \\(n\\) et tout entier naturel \\(k\\) inf\u00e9rieur ou \u00e9gal \u00e0 \\(n\\), donnent le nombre de parties \u00e0 \\(k\\) \u00e9l\u00e9ments d'un ensemble \u00e0 \\(n\\) \u00e9l\u00e9ments. On les note  \\(C_{n}^{k}\\) ou \\(\\begin{pmatrix}n\\\\k\\end{pmatrix}\\). Les coefficients binomiaux interviennent dans de nombreux domaines des math\u00e9matiques : d\u00e9veloppement du bin\u00f4me en alg\u00e8bre, d\u00e9nombrements, d\u00e9veloppement en s\u00e9rie, lois de probabilit\u00e9s, etc.</p> <p>1 ) \u00c9crire une fonction r\u00e9cursive <code>C(n, k)</code>  qui renvoie la valeur des coefficients binomiaux en utilisant la formule du triangle de Pascal :  \\(C_{n}^{k} = C_{n-1}^{k-1} + C_{n-1}^{k}\\)</p> <p> </p> <p>2) Ajouter la m\u00e9moisation \u00e0 la fonction <code>C(n, k)</code>.</p> R\u00e9ponse <p>1) <pre><code>def C(n, k):\n    if k == 0 or k == n: return 1\n    else: return C(n-1, k-1) + C(n-1, k)\n\nfor i in range (11):\n    for j in range(i+1):\n        print (C(i, j), end=\"\\t\")\n    print ('')\n</code></pre></p> <p>2 )</p> <pre><code>def C(n, k):\n    if (n, k) in memoire:\n        return memoire[(n, k)]\n    if k == 0 or k == n:\n        coef =  1\n    else: \n        coef =  C(n-1, k-1) + C(n-1, k)\n    memoire[(n, k)] = coef\n    return coef\n\nmemoire={(0, 0) : 1}\nfor i in range (11):\n    for j in range(i+1):\n        print (C(i, j), end=\"\\t\")\n    print ('')\n</code></pre> <p>Note : La m\u00e9moisation est un exemple classique d'utilisation des d\u00e9corateurs Python (hors programme)<sup>9</sup>. On pourra aussi explorer le d\u00e9corateur @functools.lru_cache(). </p>"},{"location":"langages-et-programmation/2-recursivite/#complexite-temporelle-des-fonctions-recursives","title":"Complexit\u00e9 temporelle des fonctions r\u00e9cursives","text":"<p>Prenons l'exemple de la fonction r\u00e9cursive <code>fact</code>.</p> <p>Si le calcul de <code>fact(n-1)</code> s'effectue en un nombre d'op\u00e9rations connu, not\u00e9 \\(T_{n-1}\\), alors le calcul de <code>fact(n)</code> s'effectue en effectuant cinq op\u00e9rations \u00e9l\u00e9mentaires suppl\u00e9mentaires : </p> <ul> <li>une instruction conditionnelle (<code>if</code>),</li> <li>une comparaison (<code>n == 1</code>),</li> <li>un appel de fonction (<code>fact(n-1)</code>) ,</li> <li>une multiplication (<code>n * fact(n-1)</code> ) et</li> <li>un <code>return</code>.</li> </ul> <p>donc \\(T_n = T_{n-1} + 5\\). </p> <p>Ce qui peut s'\u00e9crire en ordre de grandeur : \\(T_n = T_{n-1} + O(1)\\). La complexit\u00e9 temporelle de la fonction r\u00e9cursive <code>fact</code> est en \\(O(n)\\).</p> <p>Cours</p> <p>La complexit\u00e9 temporelle d'une fonction r\u00e9cursive se calcule en trouvant une relation entre le nombre d'op\u00e9rations \\(T_n\\) d'un probl\u00e8me de taille \\(n\\) et \\(T_{n-1}\\). Cette relation (de r\u00e9currence) permet de d\u00e9duire \\(O(n)\\).</p> Relation entre Tn et Tn-1 Complexit\u00e9 D\u00e9signation \\(T_n  = T_{n-1}  + O(1)\\) \\(O(n)\\) Lin\u00e9aire \\(T_n  = T_{n-1}  + O(n)\\) \\(O(n^2)\\) Quadratique \\(T_n  = 2 \\times T_{n-1} + O(1)\\) \\(O(2^n)\\) Exponentielle <p>Comparons les complexit\u00e9s temporelles de la suite de Fibonacci avec nos trois programmes :</p> Programme it\u00e9ratifProgramme r\u00e9cursifProgramme r\u00e9cursif avec m\u00e9mo\u00efsation <p><pre><code>def fib(n):\n    if n &lt; 2:                       # 1 condition + 1 comparaison\n        return n\n    else:\n        a, b = 0, 1                 # 2 affectations\n        for i in range(2, n+1):     # n-1 affectations\n            a, b = b, a + b         # n-1 affectations x 2 \n    return b                        # 1 return\n</code></pre> Au total, il y a \\(3(n-1) + 5\\) op\u00e9rations \u00e9l\u00e9mentaires. La complexit\u00e9 temporelle est lin\u00e9aire en \\(O(n)\\).</p> <p><pre><code>def fib(n):\n    if n &lt; 2:\n        return n               # 1 condition + 1 comparaison\n    return fib(n-1) + fib(n-2)  # 1 addition + Tn-1 + Tn-2\n</code></pre> En faisant l'hypoth\u00e8se que \\(T_{n-1}  \\approx T_{n-2}\\), nous obtenons \\(T_n  \\approx 2 \\times T_{n-1} + 2\\), donc la complexit\u00e9 temporelle est exponentielle en \\(O(2^n)\\)</p> <pre><code>memoise = {} \ndef fib(n):\n    if n in memoise:        # 1 condition + 1 recherche de cl\u00e9 dans un dictionnaire  \n        return memoise[n]   # 1 acc\u00e8s au dictionnaire \n    if n &lt; 2:               # 1 condition + 1 comparaison\n        memoise[n] = n\n    else :\n        memoise[n] = fib(n-1) + fib(n-2)     # 2 appels et 1 addition r\u00e9p\u00e9t\u00e9s\n    return memoise[n]                   # 1 return + 1 un acc\u00e8s au dictionnaire\n</code></pre> <p>Rappelons d'abord que l'acc\u00e8s \u00e0 une valeur dans un dictionnairesa une complexit\u00e9 en \\(O(1)\\) (ainsi que l'ajout ou la modification d'une valeur associ\u00e9e \u00e0 une cl\u00e9 qui sont aussi en \\(O(1)\\). Seule la recherche d'une valeur, qui consiste \u00e0 parcourir toutes les cl\u00e9s les unes apr\u00e8s les autres, a un co\u00fbt en \\(O(n)\\), mais ce n'est pas le cas ici). </p> <p>Grace \u00e0 la m\u00e9mo\u00efsation, chaque valeur de <code>fib</code> n'est calcul\u00e9e qu'une seule fois. Si la valeur est d\u00e9j\u00e0 dans le dictionnaire, les deux premi\u00e8res lignes, <code>if n in memoise:...</code> r\u00e9alisent 3 op\u00e9rations qui s'effectuent en temps constant, donc ont une compl\u00e9xit\u00e9 en \\(O(1)\\). Si la valeur n'est pas encore dans le dictionnaire, alors on effectue l'instruction qui suit le <code>else</code>, <code>memoise[n] = fib(n-1) + fib(n-2)</code>, ce sont 3 op\u00e9rations donc avec une compl\u00e9xit\u00e9 en \\(O(1)\\). Toutes ces op\u00e9rations sont r\u00e9p\u00e9t\u00e9es pour toutes les valeurs entre 3 et \\(n\\). Ainsi, le nombre total d'op\u00e9rations est proportionnel \u00e0 \\(n\\), ce qui donne une complexit\u00e9 lin\u00e9aire en \\(O(n)\\).</p> <ol> <li> <p>Le mot \"r\u00e9cursivit\u00e9\" en informatique a la m\u00eame racine que \"r\u00e9currence\" utilis\u00e9e pour les suites math\u00e9matiques.\u00a0\u21a9</p> </li> <li> <p>Une structure de contr\u00f4le est dite \"it\u00e9rative\" qaund elle ex\u00e9cute plusieurs fois une s\u00e9quence d'instructions (boucles <code>for</code>, <code>while</code>).\u00a0\u21a9</p> </li> <li> <p>Les mots \"complexit\u00e9\" ou \"co\u00fbt\" sont employ\u00e9s indiff\u00e9remment.\u00a0\u21a9</p> </li> <li> <p>Attention \u00e0 ne pas confondre les deux complexit\u00e9s : la complexit\u00e9 temporelle (ou en temps) mesure l'ordre de grandeur du nombre d'op\u00e9rations \u00e9l\u00e9mentaires, la complexit\u00e9 spatiale (ou en espace) mesure l'espace m\u00e9moire requis par un programme.\u00a0\u21a9</p> </li> <li> <p>Plus exactement en \\(O(r^n)\\) ou \\(r=(1+\u221a5)/2\u22481.6\\).\u00a0\u21a9</p> </li> <li> <p>De mani\u00e8re g\u00e9n\u00e9rale, les algorithmes qui ont une complexit\u00e9 temporelle du type \\(O(q^n)\\) avec \\(q &gt; 1\\), dits de type NP, ne peuvent pas \u00eatre ex\u00e9cut\u00e9s en temps acceptable pour \\(n\\) grand, contrairement \u00e0 ceux en \\(O(n^p)\\) dits de type P qui peuvent l'\u00eatre.\u00a0\u21a9</p> </li> <li> <p>Ici on peut modifier la variable globale <code>memoise</code> dans la fonction sans utiliser <code>global memoise</code> car elle est de type muable.\u00a0\u21a9</p> </li> <li> <p>Une technique pour ne pas garder de variable globale dans le reste programme consiste \u00e0 transformer <code>fib(n)</code> en une fonction locale de <code>fibo(n)</code> :  <pre><code>def fibo(n):\n    memoise = {} \n    def fib(n):\n        if n in memoise:\n            return memoise[n] \u2026\n        if n &lt; 2:\n            memo_fib[n] = n\n        else:\n            memo_fib[n] = fib(n-1) + fib(n-2)        \n        return memo_fib[n]\n    return fib(n)\n</code></pre> \u21a9</p> </li> <li> <p><pre><code>def memoised(fonction):\n    memoise = {}\n    def fonction_memo(*args):\n        if args not in memoise:\n            memoise[args] = fonction(*args)\n        return memoise[args]\n    return fonction_memo\n\n@memoised\ndef fib(n):\n    if n &lt; 2:\n        return n\n    return fib(n-1) + fib(n-2)\n</code></pre> \u21a9</p> </li> </ol>"},{"location":"langages-et-programmation/3-modularite/","title":"Modularit\u00e9","text":"<p>Cours</p> <p>La modularit\u00e9 consiste \u00e0 d\u00e9couper un projet en plus petit programmes afin de :</p> <ul> <li>Faciliter la r\u00e9utilisation de bouts de codes sans avoir \u00e0 les r\u00e9\u00e9crire  ou dupliquer.</li> <li>Faciliter la r\u00e9alisation d\u2019un gros projet en sous projets plus simples.</li> <li>Donner une structure pour faciliter la compr\u00e9hension du code et sa maintenance.</li> </ul>"},{"location":"langages-et-programmation/3-modularite/#modules-et-bibliotheques-rappels-de-1ere","title":"Modules et biblioth\u00e8ques (rappels de 1\u00e8re)","text":"<p>Cours</p> <p>Un module est un programme Python regroupant des fonctions et des constantes (des variables dont la valeur ne change pas<sup>1</sup>) ayant un rapport entre elles.  </p> <p>Un module doit \u00eatre import\u00e9 dans un programme avant de pouvoir utiliser ses fonctions et ses constantes.</p> <p>Une biblioth\u00e8que (ou package en anglais) regroupe des fonctions, des constantes et des modules.</p>"},{"location":"langages-et-programmation/3-modularite/#import","title":"<code>import</code>","text":"<p>Pour importer un module dans un programme, il faut utiliser l'instruction <code>import</code> en d\u00e9but de programme :</p> <pre><code>import mesfonctions\n</code></pre> <p>Pour appeler une fonction ou utiliser une constante d'un module il faut \u00e9crire le nom du module suivi d'un point \u00ab . \u00bb puis du nom de la fonction ou de la constante.  </p> <pre><code>import mesfonctions\n\nn = int(input('Entrez un nombre '))\nprint(mesfonctions.est_premier(n)) \n</code></pre> <p> Prendre soin d\u2019enregistrer ce programme dans le m\u00eame r\u00e9pertoire que le fichier \u00ab mesfonctions.py \u00bb.</p> <p>Il est aussi possible donner un alias \u00e0 un module pour le renommer avec un nom plus simple \u00e0 \u00e9crire, par exemple pour utiliser <code>mf</code> au lieu de <code>mesfonctions</code> :</p> <pre><code>import  mesfonctions  as mf\n\nn = int(input('Entrez un nombre '))\nprint(mf.est_premier(n)) \n</code></pre> <p>Cours</p> Sans aliasAvec alias <p>Pour importer un module <code>nom_module</code>, il faut \u00e9crire en d\u00e9but de programme l\u2019instruction : </p> <p><code>import nom_module</code> </p> <p>puis pour utiliser une fonction <code>nom_fonction()</code> de ce module  :</p> <p><code>nom_module.nom_fonction()</code></p> <p>Pour importer un module <code>nom_module</code> en lui donnant un alias <code>nom_alias</code>, il faut \u00e9crire en d\u00e9but de programme l\u2019instruction :</p> <p><code>import nom_module as nom_alias</code> </p> <p>puis pour utiliser une fonction <code>nom_fonction()</code> de ce module  :</p> <p><code>nom_alias_module.nom_fonction()</code></p> <p>La fonction <code>help()</code> permet de savoir ce que contient un module :</p> <pre><code>&gt;&gt;&gt; help(mesfonctions)\nHelp on module mesfonctions:\n\u2026\n</code></pre>"},{"location":"langages-et-programmation/3-modularite/#from-import","title":"<code>from \u2026 import \u2026</code>","text":"<p>Il existe une autre m\u00e9thode pour importer des fonctions ou constantes depuis un module. Admettons que le module <code>mesfonctions</code> contienne des dizaines de fonctions, mais que nous ayons uniquement besoin dans notre programme de la fonction <code>est_premier</code>, dans ce cas il est pr\u00e9f\u00e8rable d'importer uniquement cette fonction plut\u00f4t que tout le module en utilisant l'instruction <code>`from mesfonctions import est_premier</code>. </p> <pre><code>from  mesfonctions import est_premier\n\nn = int(input('Entrez un nombre '))\nprint(est_premier(n))\n</code></pre> <p>\u00c0 noter : </p> <p>Ici on ne met pas le pr\u00e9fixe \u00ab <code>mesfonctions.</code> \u00bb  devant le nom de la fonction <code>est_premier</code>. </p> <p>On peut aussi donner un alias \u00e0 une fonction : <code>from mesfonctions import est_premier as estprems</code> et utiliser ensuite la fonction <code>estprems()</code>.</p> <p>Cours</p> Sans aliasAvec alias <p>Pour importer une fonction <code>nom_fonction()</code> depuis le module <code>nom_module</code>, il faut \u00e9crire en d\u00e9but de programme l\u2019instruction :</p> <p><code>from nom_module import nom_fonction</code> </p> <p>puis pour utiliser cette fonction :</p> <p><code>nom_fonction()</code></p> <p>Pour importer une fonction <code>nom_fonction()</code> en lui donnant un alias <code>nom_alias</code> depuis le module <code>nom_module</code>, il faut \u00e9crire en d\u00e9but de programme l\u2019instruction :</p> <p><code>from nom_module import nom_fonction as nom_alias</code> </p> <p>puis pour utiliser cette fonction :</p> <p><code>nom_alias()</code></p> <p>Il est aussi possible d'importer plusieurs fonctions d\u2019un m\u00eame module s\u00e9par\u00e9es par des virgules :</p> <p><pre><code>from mesfonctions import est_premier, une_autre_fonction\n</code></pre> voire m\u00eame toutes les fonctions d'un module en tapant \u00ab <code>*</code> \u00bb \u00e0 la place du nom de la fonction \u00e0 importer.</p> <pre><code>from mesfonctions import *\n</code></pre> <p>Mais cette derni\u00e8re utilisation est vivement d\u00e9conseill\u00e9e, hormis dans des cas tr\u00e8s particuliers par exemple des programmes tr\u00e8s courts, car il peut y avoir des conflits entre des fonctions qui ont le m\u00eame nom. Pour s\u2019en convaincre, imaginons un programme \u00e9crit en utilisant l'instruction <code>pow(1, 2, 3)</code> qui fonctionnerait parfaitement jusqu'\u00e0 ce qu'une modification necessitant le module <code>math</code> ajoute l'instruction <code>from math import *</code> en d\u00e9but de programme et g\u00e9n\u00e8re une erreur inattendue <sup>2</sup> l\u00e0 o\u00f9 il n'y en avait pas.</p> <p>Python offre des centaines de modules avec des milliers de fonctions d\u00e9j\u00e0 programm\u00e9es. Il y a diff\u00e9rents types de modules :</p> <ul> <li>ceux que l\u2019on peut faire soi-m\u00eame (comme <code>mesfonctions</code>).</li> <li>ceux qui sont inclus dans la biblioth\u00e8que standard de Python comme <code>random</code> ou <code>math</code>,</li> <li>ceux que l\u2019on peut rajouter en les installant s\u00e9paremment comme <code>numpy</code> ou <code>matplotlib</code>.</li> </ul>"},{"location":"langages-et-programmation/3-modularite/#de-lutilite-de-la-fonction-main","title":"De l'utilit\u00e9 de la fonction 'main()'","text":"<p>On a vu auparavant la d\u00e9finition de la fonction <code>main()</code> contenant le programme principal, suivi du bout de code suivant :</p> <pre><code>if __name__ == '__main__':\n    main()\n</code></pre> <p>Cette instruction conditionnelle v\u00e9rifie si une variable appel\u00e9e <code>__name__</code> est \u00e9gale \u00e0 <code>'__main__'</code> et dans ce cas ex\u00e9cute la fonction <code>main()</code>. </p> <p>L\u2019interpr\u00e9teur Python d\u00e9finit la variable <code>__name__</code> selon la mani\u00e8re dont le code est ex\u00e9cut\u00e9 :</p> <ul> <li> <p>directement en tant que script, dans ce cas Python affecte <code>'__main__'</code> \u00e0  <code>__name__</code>, l'instruction conditionnelle est v\u00e9rifi\u00e9e et la fonction <code>main()</code> est appel\u00e9e ; ou alors </p> </li> <li> <p>en important le code dans un autre script et dans ce cas la fonction <code>main()</code> n\u2019est pas appel\u00e9e.</p> </li> </ul> <p>En bref, la variable <code>__name__</code> d\u00e9termine si le fichier est ex\u00e9cut\u00e9 directement ou s'il a \u00e9t\u00e9 import\u00e9.<sup>3</sup> </p>"},{"location":"langages-et-programmation/3-modularite/#modules-python","title":"Modules Python","text":"<p>Python offre des centaines de modules avec des milliers de fonctions d\u00e9j\u00e0 programm\u00e9es. Il y a diff\u00e9rents types de modules : -   ceux que l\u2019on peut faire soi-m\u00eame (comme <code>mesfonctions</code>). -   ceux qui sont inclus dans la biblioth\u00e8que standard de Python comme <code>random</code> ou <code>math</code>, -   ceux que l\u2019on peut rajouter en les installant comme <code>numpy</code> ou <code>matplotlib</code>,</p> module Description <code>math</code> Fonctions math\u00e9matiques. <code>random</code> Fonctions al\u00e9atoires. <code>matplolib.pyplot</code> Trac\u00e9s de courbes et grpahiques. <code>numpy</code> Permet de faire du calcul scientifique. <code>numpy</code> Permet de faire du calcul scientifique. <code>time</code> Fonctions permettant de travailler avec le temps. <code>turtle</code> Fonctions de dessin. <code>doctest</code> Execute des tests ecrits dans la docstring d\u2019une fonction. <p>La fonction <code>dir</code> permet d\u2019explorer le contenu d\u2019un module :</p> <pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; dir(math)\n['__doc__',\n '__loader__',\n '__name__',\n '__package__',\n '__spec__',\n 'acos',\n 'acosh',\n 'asin',\n\u2026\n</code></pre> <p>En plus de la documentation en ligne, la fonction <code>help</code> donne les sp\u00e9cifications d\u2019une fonction.</p> <pre><code>&gt;&gt;&gt; help(math.cos)\nHelp on built-in function cos in module math:\n\ncos(...)\n    cos(x)\n\n    Return the cosine of x (measured in radians).\n</code></pre>"},{"location":"langages-et-programmation/3-modularite/#api","title":"API","text":"<p>Cours</p> <p>Une API (Application Programming Interface) est un ensemble de r\u00e8gles et de protocoles qui permettent \u00e0 diff\u00e9rents logiciels de communiquer entre eux. Elle d\u00e9finit les m\u00e9thodes et les formats d'\u00e9change de donn\u00e9es que les programmes peuvent utiliser pour interagir.</p> <p> </p> <p>Il existe de nombreux types d'API mais le principe de base est toujours le m\u00eame : deux applications informatiques peuvent int\u00e9ragir sans que l'une ne conna\u00eesse le fonctionnement interne de l'autre. Il suffit que la documentation d\u00e9crive pr\u00e9cis\u00e9ment les r\u00e8gles d'utilisation de l'API.Par exemple, en Python, pour utiliser une fonction d'un module externe, il suffit de conna\u00eetre sa sp\u00e9cification (son nom, les param\u00e8tres et ce qu'elle retourne), il est inutile de savoir comment elle fonctionne.</p> <p>Une API peut prendre diff\u00e9rentes formes, telles que:</p> <ol> <li> <p>API Web: Une API Web permet aux applications de communiquer via Internet en utilisant les protocoles HTTP et HTTPS. </p> </li> <li> <p>API de syst\u00e8me d'exploitation: Les syst\u00e8mes d'exploitation, tels que Windows, macOS et Linux, fournissent des API qui permettent aux d\u00e9veloppeurs de cr\u00e9er des applications pour interagir avec le syst\u00e8me et les p\u00e9riph\u00e9riques.</p> </li> <li> <p>API de biblioth\u00e8que: Les biblioth\u00e8ques logicielles fournissent des API qui permettent aux d\u00e9veloppeurs d'utiliser certaines fonctionnalit\u00e9s ou fonctionnalit\u00e9s sp\u00e9cifiques sans avoir \u00e0 comprendre les d\u00e9tails internes de leur mise en \u0153uvre.</p> </li> <li> <p>API de mat\u00e9riel: Certains mat\u00e9riels, comme les imprimantes, offrent \u00e9galement des API qui permettent aux logiciels d'interagir avec eux de mani\u00e8re standardis\u00e9e.</p> </li> </ol> <p>Les API jouent un r\u00f4le essentiel dans le d\u00e9veloppement de logiciels car elles facilitent l'int\u00e9gration de diff\u00e9rentes parties d'une application ou de diff\u00e9rents services pour cr\u00e9er des syst\u00e8mes plus complexes et puissants.</p> <p></p> <p>Prenons pour exemple l'utilisation de l'API Web fournie par le Studio Ghibli pour r\u00e9cup\u00e9rer des donn\u00e9es sur ses films : https://ghibliapi.vercel.app/ . </p> <p>Observons la documentation : La section FILMS fournit l'URL du point d\u2019acc\u00e8s \u00e0 l\u2019API, https://ghibliapi.vercel.app/films et trois exemples de requ\u00eates faites en curl, Ruby et Python.</p> <p>Juste en dessous (ou en  cliquant sur le lien donn\u00e9),  on peut observer les donn\u00e9es qui vont \u00eatre envoy\u00e9es par l\u2019API. Elles sont au format JSON.</p> <p>Rappel</p> <p>JSON (JavaScript Object Notation) est un format de donn\u00e9es textuelles d\u00e9riv\u00e9 de la notation des objets en JavaScript.  Comme XML, JSON permet de repr\u00e9senter de l\u2019information structur\u00e9e. Un fichier JSON se pr\u00e9sente sous forme de listes et de dictionnaires (cl\u00e9/valeur).</p> <p>Commen\u00e7ons par importer ces donn\u00e9es dans un fichier (noter que la fonction <code>urllib.request.urlopen()</code> remplace l\u2019ancienne fonction <code>urllib2.urlopen()</code> donn\u00e9e dans l\u2019exemple de requ\u00eate<sup>4</sup>).</p> <pre><code>&gt;&gt;&gt; import urllib.request\n&gt;&gt;&gt; url = 'https://ghibliapi.vercel.app/films'\n&gt;&gt;&gt; request = urllib.request.urlopen(url).read()\n</code></pre> <p>Les donn\u00e9es sont import\u00e9es dans un fichier binaire (en python un fichier binaire se pr\u00e9sente sous la forme <code>b'\u2026.'</code>). </p> <pre><code>&gt;&gt;&gt; type(request)\n&lt;class 'bytes'&gt;\n&gt;&gt;&gt; print(request)\nb'[\\n  {\\n    \"id\": \"2baf70d1-42bb-4437-b551-e5fed5a87abe\",\\n    \"title\": \"Castle in the Sky\",\\n    \"description\": \"The orphan Sheeta inherited a mysterious crystal that links her to the mythical ...\n</code></pre> <p>On peut maintenant utiliser le module json pour manipuler ces donn\u00e9es dans un format plus adapt\u00e9 :</p> <pre><code>import urllib.request\nimport json\n\nurl = 'https://ghibliapi.vercel.app/films'\nrequest = urllib.request.urlopen(url).read()\ndata = json.loads(request.decode())\nprint(data)\nCette fois on a obtenu un tableau de dictionnaire. On peut facilement l\u2019exploiter, par exemple :\nfor movie in data:\n    print(movie['title'])\n</code></pre> <p>Prenons un autre exemple d'appel d'une API Windows en utilisant la biblioth\u00e8que <code>ctypes</code>. </p> <pre><code>import ctypes\n\n# Pour utiliser l'API Windows User32.dll pour les fonctions de gestion de fen\u00eatres\nuser32 = ctypes.windll.user32\n\n# D\u00e9finir les types de donn\u00e9es pour la fonction MessageBox\nuser32.MessageBoxW.argtypes = (ctypes.c_void_p, ctypes.c_wchar_p, ctypes.c_wchar_p, ctypes.c_uint)\nuser32.MessageBoxW.restype = ctypes.c_int\n\n# Afficher une bo\u00eete de dialogue MessageBox de l'API\nresult = user32.MessageBoxW(0, \"Bonjour depuis Python!\", \"Titre de la bo\u00eete de dialogue\", 1)\n</code></pre> <ol> <li> <p>Par exemple la valeur de \\(\\pi\\) dans le module <code>math</code>.\u00a0\u21a9</p> </li> <li> <p>La fonction standard Python <code>pow()</code> prend trois param\u00e8tres alors que la fonction <code>pow()</code> du module <code>math</code> n'en a que deux ! L'import de <code>from math import *</code> a import\u00e9 la seconde fonction probablement \u00e0 l'insu du programmeur.\u00a0\u21a9</p> </li> <li> <p>On peut facilement se convaincre de l\u2019utilit\u00e9 de la fonction <code>main()</code> en \u00e9crivant le programme qui affiche la d\u00e9composition d\u2019un nombre en facteurs premiers sans <code>main()</code> dans le fichier \u00ab mesfonctions.py \u00bb : <pre><code>def est_premier(nombre):\n    for div in range(2, nombre):\n        if nombre % div == 0:\n            return False\n    return True\n\nnombre = int(input('Entrez un nombre '))\npremier = 2 # on commence par le plus petit nombre premier : 2\nwhile nombre &gt; 1:\n        if nombre % premier == 0:      # si premier divise nombre\n            print(premier, end=\" \")                 # alors on l'affiche\n            nombre = nombre // premier     # et on recommence apr\u00e8s avoir divis\u00e9 nombre par premier\n        else:                          # sinon, premier n'est pas un diviseur\n            premier += 1                 # on cherche le nombre premier suivant\n            while not(est_premier(premier)):\n                premier += 1\n</code></pre> Lorsque pour utiliser la fonction <code>est_premier</code> le module est import\u00e9 dans un autre programme avec <code>import  mesfonctions</code>, toute la suite du programme de la d\u00e9composition d\u2019un nombre en facteurs premiers est ex\u00e9cut\u00e9 automatiquement.\u00a0\u21a9</p> </li> <li> <p>Voir https://docs.python.org/3/library/urllib.request.html.\u00a0\u21a9</p> </li> </ol>"},{"location":"langages-et-programmation/4-paradigmes-de-programmation/","title":"Paradigmes de programmation","text":"<p>Cours</p> <p>Un paradigme de programmation est une fa\u00e7on d'approcher la programmation et de traiter les solutions aux probl\u00e8mes et leur formulation dans un style appropri\u00e9. La plupart des langages sont multiparadigmes.</p> <p>La suite de ce chapitre pr\u00e9sente certains paragimes parmi les plus utilis\u00e9s<sup>1</sup>.</p>"},{"location":"langages-et-programmation/4-paradigmes-de-programmation/#langages-de-programmation-imperative","title":"Langages de programmation imp\u00e9rative","text":"<p>C\u2019est le paradigme le plus courant, car la quasi-totalit\u00e9 des processeurs qui \u00e9quipent les ordinateurs sont de nature imp\u00e9rative. Il s'agit historiquement des premiers langages, m\u00eame si de nombreux langages modernes utilisent toujours ce principe de fonctionnement.</p> <p>Cours</p> <p>Dans un langage imp\u00e9ratif le programme est construit sous forme d'une suite d'instructions, regroup\u00e9es par blocs et comprenant des sauts conditionnels pour revenir \u00e0 un bloc d'instructions si une condition est r\u00e9alis\u00e9e.</p> <p>Exemples : la plupart des langages courants, y compris des langages de programmation orient\u00e9s objets tels que C#, Visual Basic, C++ et Java, PHP. </p>"},{"location":"langages-et-programmation/4-paradigmes-de-programmation/#langages-de-programmation-fonctionnelle","title":"Langages de programmation fonctionnelle","text":"<p>Cours</p> <p>Dans un langage fonctionnel le programme est construit comme un embo\u00eetement de fonctions qui agissent comme des \u00ab boites noires \u00bb que l\u2019on peut imbriquer les unes dans les autres.</p> <p>Exemples : Lisp, la famille ML (Standard ML, OCaml et autres) et Haskell, mais aussi beaucoup de langages imp\u00e9ratifs (Python ou C#) incluent des extensions de langage qui prennent en charge la programmation fonctionnelle, par exemple les fonctions lambda en Python.</p> <p>Les principes de la programmation fonctionnelle sont les suivants :</p> <ul> <li> <p>Les variables ne sont pas modifi\u00e9es. </p> <p>Les variables Python de type <code>list</code> avec les m\u00e9thodes <code>.append()</code> ou <code>.pop()</code> ne respectent pas les principes de programmation fonctionnelle, voyons comment les utiliser diff\u00e9remment :</p> Exemple de programmation non fonctionnelle Exemple de programmation fonctionnelle <code>&gt;&gt;&gt; l = [1, 2, 3, 4]</code><code>&gt;&gt;&gt; l.append(5)</code><code>&gt;&gt;&gt; l</code><code>[1, 2, 3, 4, 5]</code><code>&gt;&gt;&gt; l.pop()</code><code>5</code> <code>&gt;&gt;&gt; l = [1, 2, 3, 4]</code><code>&gt;&gt;&gt; m = l + [5]</code><code>&gt;&gt;&gt; m</code><code>[1, 2, 3, 4, 5]</code><code>&gt;&gt;&gt; l</code><code>[1, 2, 3, 4]</code><code>&gt;&gt;&gt; n = m[:-1]</code> </li> <li> <p>Les tableaux par compr\u00e9hension, inspir\u00e9es du langage de programmation fonctionnel Haskell, sont adapt\u00e9s \u00e0 la programmation fonctionnelle.</p> <p>Par exemple la liste de carr\u00e9s de tous les nombres impairs de 0 \u00e0 9 :</p> </li> </ul> Exemple de programmation non fonctionnelle Exemple de programmation fonctionnelle <code>carres = []</code><code>for x in range(10):</code> <code>if x%2 != 0:</code> <code>carres.append(x**2)</code> <code>[x**2 for x in range(10) if x%2 != 0]</code> <ul> <li> <p>La r\u00e9cursivit\u00e9 est souvent utilis\u00e9e, en particulier \u00e0 la place des boucles (puisque l\u2019\u00e9tat du programme ne peut pas \u00eatre modifi\u00e9, en particulier avec un variant de boucle). </p> <p>Voyons comment calculer le produit de tous les nombres entiers entre 1 et \\(n\\), appel\u00e9 factorielle de \\(n\\) et not\u00e9 \\(n!\\) :</p> <p>\\(n!  =  1  \\times 2  \\times 3  \\times 4  \\times ...  \\times (n-1)  \\times n\\) </p> Exemple de programmation non fonctionnelle Exemple de programmation fonctionnelle <code>def fact(n):</code> <code>f = 1</code> <code>for i in range(2, n+1):</code> <code>f = f * i</code> <code>return f</code> <code>def fact(n):</code> <code>if n == 1: return 1</code> <code>return n * f(n - 1)</code><code># ou en fonction lambda</code><code>fact = lambda n:1 if n == 1  else n * f(n - 1)</code> </li> <li> <p>Une fonction est une \"fonction pure\", elle renvoie une valeur qui ne d\u00e9pend que de ses param\u00e8tres, et pas de valeur externes.</p> Exemple de programmation non fonctionnelle Exemple de programmation fonctionnelle <code>n = 2</code><code>def inc(k):</code> <code>\"\"\" incr\u00e9mentation par effet de bord \"\"\"</code> <code>global n</code> <code>n = n + k</code> <code>return n</code><code>print(inc(1) + inc(1))</code><code>&gt;&gt;&gt; 7</code> <code>def inc(k):</code> <code>\"\"\" incr\u00e9mentation sans effet de bord\"\"\"</code> <code>n = 2</code> <code>n = n + k</code> <code>return n</code><code>print(inc(1) + inc(1))</code><code>&gt;&gt;&gt; 6</code> <p>Dans l\u2019exemple de programmation non fonctionnelle, la fonction <code>inc(k)</code> ne renvoie pas la m\u00eame valeur lors des deux appels : le premier appel renvoie <code>3</code> (<code>=2 + 1</code>) et le second <code>4</code> (<code>=3 + 1</code>), il est donc impossible de remplacer <code>print(inc(1) + inc(1))</code> par <code>print(2 * inc(1))</code>. </p> </li> <li> <p>Une fonction est dite \"d'ordre sup\u00e9rieur\", elle peut \u00eatre utilis\u00e9e comme param\u00e8tre d\u2019une autre fonction ou renvoy\u00e9e comme r\u00e9sultat d\u2019une autre fonction. Une fonction est aussi dite \"de premi\u00e8re classe\", elle est manipulable comme un type de base, elle peut \u00eatre assign\u00e9e \u00e0 une variable (fonction lambda) ou m\u00eame stock\u00e9e dans une structure de donn\u00e9es. </p> <p>En Python, les fonctions lambda sont un exemple de programmation fonctionnelle.  Cr\u00e9ons une fonction qui renvoie la fonction \"\u00e0 la puissance n\" :</p> <pre><code>def puissance(n):\n    return lambda x: x**n\n</code></pre> <p>que l'on peut l'utiliser pour cr\u00e9er les fonctions <code>carre</code> et <code>cube</code> :</p> <pre><code>&gt;&gt;&gt; carre = puissance(2)\n&gt;&gt;&gt; cube = puissance(3)\n&gt;&gt;&gt; cube(10)\n1000\n</code></pre> <p><code>puissance(5)</code> est la fonction qui renvoie la puissance 5 d'un nombre, par exemple pour calculer \\(10^5\\) :</p> <pre><code>&gt;&gt;&gt; puissance(5)(10)\n10000\n</code></pre> <p>On peut aussi stocker des fonctions dans une structure de donn\u00e9es, par exemple cr\u00e9er un tableau avec toutes les fonctions <code>puissance()</code> entre de 0 et 100 :</p> <pre><code>&gt;&gt;&gt; p = [puissance(i) for i in range(101)]\n&gt;&gt;&gt; p[5](10)\n10000\n</code></pre> </li> </ul>"},{"location":"langages-et-programmation/4-paradigmes-de-programmation/#langages-de-programmation-orientee-objet","title":"Langages de programmation orient\u00e9e objet","text":"<p>Cours</p> <p>La programmation orient\u00e9e objet, ou POO consiste en la d\u00e9finition et l\u2019interaction de briques logicielles appel\u00e9es objets. Un objet repr\u00e9sente un concept, une id\u00e9e ou toute entit\u00e9 du monde physique (une voiture, une personne, etc.).</p> <p>Exemple de langages orient\u00e9s objets : Java, Javascript C++, Python, PHP</p> <p>Une classe regroupe des fonctions et des attributs qui d\u00e9finissent la structure interne et le comportement de ses objets.</p> <p>PEP 8</p> <p>Les noms de classes s\u2019\u00e9crivent en CamelCase https://www.python.org/dev/peps/pep-0008/#class-names</p> <p>Prenons un exemple, cr\u00e9ons une classe <code>Voiture</code> : </p> <pre><code>class Voiture:\n    pass\n</code></pre> <p>Notre classe <code>Voiture</code> est une sorte d'usine \u00e0 cr\u00e9er des voitures, ce n\u2019est pas une voiture. Elle permet de cr\u00e9er un ou plusieurs objets, appel\u00e9s instances de la classe.</p> <p>Cr\u00e9ons maintenant notre premier objet <code>Voiture</code> :</p> <pre><code>ma_voiture = Voiture()\n</code></pre> <p>Les attributs permettent de stocker des informations \u00e0 propos d\u2019un objet Voiture. Dans notre exemple, donnons plusieurs  attributs \u00e0 une voiture :</p> <pre><code>ma_voiture = Voiture()\nma_voiture.marque=\"Peugeot\"\nma_voiture.modele = \"308\"\nma_voiture.km = 25645\n</code></pre> <p>Et les lire ainsi. L'instruction <code>print(\"Ma voiture est une \",ma_voiture.marque, ma_voiture.modele, 'de ',  ma_voiture.km, 'km')</code> affiche dans la console : <pre><code>&gt;&gt;&gt; Ma voiture est une  Peugeot 308 de 25645 km\n</code></pre> Les m\u00e9thodes sont des fonctions qui s\u2019appliquent aux objets de cette classe. Cr\u00e9ons deux nouvelles m\u00e9thodes dans notre classe <code>Voiture</code> :</p> <pre><code>class Voiture:\n\n    def get_km(self):\n        return self.km\n\n    def roule(self, k):\n        self.km = self.km + k\n</code></pre> <p>Utilisons ces m\u00e9thode dans un programme :</p> <pre><code>def main():\n    ma_voiture = Voiture()\n    ma_voiture.marque=\"Peugeot\"\n    ma_voiture.modele = \"308\"\n    ma_voiture.km = 25645\n    ma_voiture.roule(10000)\n    print(ma_voiture.get_km() )\n</code></pre> <p>Plut\u00f4t que de rajouter les attributs les uns apr\u00e8s les autres apr\u00e8s avoir cr\u00e9\u00e9 un objet, on peut ajouter une m\u00e9thode sp\u00e9ciale appel\u00e9e <code>__init__()</code><sup>2</sup> pour les renseigner directement \u00e0 la cr\u00e9ation de l\u2019objet.</p> <pre><code>class Voiture:\n    def __init__(self, ma, mo, k=0):\n        self.marque = ma\n        self.modele  = mo\n        self.km = k\n\ndef main():\n    ma_voiture = Voiture(\"Peugeot\", \"308\", 25645)\n    ma_voiture.roule(10000)\n    print(ma_voiture.get_km() )\u2003\n</code></pre>"},{"location":"langages-et-programmation/4-paradigmes-de-programmation/#langages-de-programmation-logique","title":"Langages de programmation logique","text":"<p>Cours</p> <p>La programmation logique est un paradigme de programmation qui d\u00e9finit les applications \u00e0 l'aide d'un ensemble de faits \u00e9l\u00e9mentaires les concernant et de r\u00e8gles de logique leur associant des cons\u00e9quences plus ou moins directes. Ces faits et ces r\u00e8gles sont exploit\u00e9s par un d\u00e9monstrateur de th\u00e9or\u00e8me ou moteur d'inf\u00e9rence, en r\u00e9action \u00e0 une question ou requ\u00eate.</p> <p>Exemple : Prolog<sup>3</sup> (Prolog est aussi un langage imp\u00e9ratif).</p> <p>Prenons l'exemple du probl\u00e8me logique suivant : Alice et Luc sont mari\u00e9s. Luc est le p\u00e8re de Jean.  Qui est la m\u00e8re de Jean ?</p> <p>Syntaxe Prolog</p> <p>Le symbole  <code>:-</code>  dans une r\u00e8gle se lit \"si\" ; la virgule <code>,</code> dans une r\u00e8gle se lit \"et\", tout ce qui suit le caract\u00e8re <code>%</code> sur une ligne est un commentaire, le nom des variables commencent toujours par une lettre majuscule (exemple : <code>X</code>, <code>Voiture</code>, <code>NUMERO</code>, etc.).</p> <p>La solution peut \u00eatre trouv\u00e9e par un simple programme Prolog r\u00e9alis\u00e9 sur https://swish.swi-prolog.org/.</p> <p>Indiquons les deux faits connus dans le code sourve: 1. alice est l'\u00e9pouse de luc  2. luc est le p\u00e8re de jean</p> <p> Ne pas oublier le point \u00e0 la fin de chaque instruction.</p> <pre><code>% les faits :\nepouse(alice,luc). % alice est l'\u00e9pouse de luc\npere(luc,jean). % luc est le p\u00e8re de jean\n</code></pre> <p>Puis la r\u00e8gle que si un p\u00e8re est mari\u00e9 \u00e0 une femme, alors cette derni\u00e8re est la m\u00e8re du fils (pas de famille recompos\u00e9e ici !) :</p> <pre><code>% les r\u00e8gles :\nmere(M,E):-pere(P,E),epouse(M,P). % M est la m\u00e8re de E si P est le p\u00e8re de E et si M est l'\u00e9pouse de P\n</code></pre> <p>Avant de r\u00e9pondre \u00e0 notre probl\u00e8me, posons quelques questions :</p> <p>jutiliser le bouton Run ou CTRL+Enter pour executer.</p> <ol> <li> <p>Qui est l'\u00e9pouse de luc ?     <pre><code>?- epouse(X,luc).\nX = alice.\n</code></pre></p> </li> <li> <p>Qui est l'\u00e9poux d'alice ? (ou qui a pour \u00e9pouse alice ?)   <pre><code>?- epouse(alice,X).\nX = luc.    \n</code></pre></p> </li> <li> <p>Qui est le p\u00e8re de jean ?     <pre><code>?- pere(X,jean).    \nX = luc.    \n</code></pre></p> </li> <li> <p>Qui est le fils de luc ? (ou qui a pour p\u00e8re luc ?)    <pre><code>?- pere(luc,X). \nX = jean.   \n</code></pre></p> </li> </ol> <p>Noter que pour r\u00e9pondre \u00e0 ces 4 premi\u00e8res questions Prolog n'utilise que les faits, pas la r\u00e8gle d\u00e9finissant la m\u00e8re.</p> <p>Posons maintenant la question qui nous int\u00e9resse. Prolog utilise cette fois la r\u00e8gle d\u00e9finissant la m\u00e8re.</p> <ol> <li> <p>Qui est la mere de jean ?     <pre><code>?- mere(X,jean).\nX = alice.  \n</code></pre></p> </li> <li> <p>Qui est le fils d'alice ? (ou qui a pour m\u00e8re alice ?)     <pre><code>?- mere(alice,X).\nX = jean.   \n</code></pre></p> </li> <li> <p>Qui est le fils de jean ? (ou Qui a pour p\u00e8re jean ?)     <pre><code>?- pere(jean,X).\nfalse.  \n</code></pre></p> </li> <li> <p>Qui est le fils de lucienne ? (ou qui a pour m\u00e8re lucienne ?)       <pre><code>?- mere(lucienne,X).\nfalse.  \n</code></pre></p> </li> </ol> <p>Prolog n'a pas la r\u00e9ponse \u00e0 ces 2 derni\u00e8res questions : il r\u00e9pond alors false.</p> <ol> <li> <p>Qui est la m\u00e8re de qui ?     <pre><code>?- mere(X,Y).\nX = alice,\nY = jean..  \n</code></pre></p> </li> <li> <p>combien de liens de parent\u00e9 \"m\u00e8re/fils\" existe-t-il ?      <pre><code>?- mere(_,_).\ntrue   % 1 seul.    \n</code></pre> Le soulignement (_) signale \u00e0 Prolog que la variable en question n\u2019est pas utilis\u00e9e (\u201cplaceholder\u201d) </p> </li> <li> <p>Existe-t-il une personne qui est sa propre m\u00e8re ?      <pre><code>?- mere(X,X).\nfalse   % non.  \n</code></pre></p> </li> </ol>"},{"location":"langages-et-programmation/4-paradigmes-de-programmation/#langages-de-programmation-evenementielle","title":"Langages de programmation \u00e9v\u00e8nementielle","text":"<p>Cours</p> <p>En programmation \u00e9v\u00e9nementielle le flux du programme est d\u00e9termin\u00e9 par des \u00e9v\u00e9nements tels que les actions de l'utilisateur (clics de souris, pressions de touches), les sorties de capteur ou les messages d'autres programmes ou threads. </p> <p>Exemple : JavaScript</p> <p>La programmation \u00e9v\u00e8nementielle est le paradigme dominant utilis\u00e9 dans la programmation d\u2019Interfaces Homme Machine, ou IHM (GUI en anglais pour graphical user interface) et d'autres applications d\u2019automates.</p> <p>Apr\u00e8s une phase d\u2019initialisation, le programme  \u00ab tourne \u00bb en permanence  \u00ab en attente \u00bb de d\u00e9tecter un \u00e9v\u00e9nement :  une action de l\u2019utilisateur (d\u00e9placement de la souris, appui sur une touche, etc.,) ou un \u00e9v\u00e9nement externe (top d\u2019horloge, etc.)</p> <p> </p> <p>Le programme r\u00e9agit aux \u00e9v\u00e9nements, l\u2019ordre dans lequel il est ex\u00e9cut\u00e9 n\u2019est pas connu \u00e0 l\u2019avance, ce sont  les \u00e9v\u00e8nements qui le d\u00e9terminent.</p> <p>En pratique :</p> <ol> <li> <p>Javascipt avec <code>&lt;element onclick=\"myFunction\"&gt;</code> . </p> <p>Dans notepad, cr\u00e9ons un fichier test.html et ouvrons-le dans un navigateur</p> <p>Syntaxe Prolog</p> <p>On peut acc\u00e9der \u00e0 un \u00e9l\u00e9ment HTML en JavaScript avec <code>document.getElementById(id)</code> o\u00f9 <code>id</code> d\u00e9signe l\u2019\u00e9l\u00e9ment HTML. L\u2019attribut <code>innerHTML</code> d\u00e9finit le contenu de cet \u00e9l\u00e9ment HTML.</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;p id=\"demo\" onclick=\"myFunction()\"&gt;Cliquez ici&lt;p&gt;\n\n&lt;script&gt;\nfunction myFunction() {\ndocument.getElementById(\"demo\").innerHTML = \"Vous avez cliqu\u00e9\n}\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> </li> <li> <p>Javascript avec <code>object.onclick = function(){myScript};</code> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n&lt;p id=\"demo\"&gt; Cliquez ici&lt;/p&gt;\n&lt;script&gt;\ndocument.getElementById(\"demo\").onclick = function() {myFunction()};\n\nfunction myFunction() {\ndocument.getElementById(\"demo\").innerHTML = \"Vous avez cliqu\u00e9\n}\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre></p> </li> </ol>"},{"location":"langages-et-programmation/4-paradigmes-de-programmation/#langages-de-requetes-ou-de-bases-de-donnees","title":"Langages de requ\u00eates ou de bases de donn\u00e9es","text":"<p>Cours</p> <p>Le langage SQL (Structured Query Langages) sp\u00e9cialement con\u00e7u pour faire des requ\u00eates (s\u00e9lectionner, filtrer, mettre \u00e0 jour) sur les syst\u00e8mes de bases de donn\u00e9es.</p>"},{"location":"langages-et-programmation/4-paradigmes-de-programmation/#langages-descriptifs-ou-de-balisage","title":"Langages descriptifs (ou de balisage)","text":"<p>Cours</p> <p>Les langages descriptifs (ou de balisage) sont sp\u00e9cialis\u00e9s dans l'enrichissement d'information textuelle. Ils utilisent des balises, permettant de transf\u00e9rer \u00e0 la fois la structure du document et son contenu. </p> <p>Cette structure est compr\u00e9hensible par un programme informatique, ce qui permet un traitement automatis\u00e9 du contenu. Si ce sont des langages informatiques, ce ne sont pas des langages de programmation \u00e0 proprement parler (on ne peut pas \u00e9crire de programme avec).</p> <p>Exemples: HTML, mais aussi Latex, XML</p> <ol> <li> <p>Une liste compl\u00e8te de paradigmes de programmation est disponible sur : https://en.wikipedia.org/wiki/programming_paradigm.\u00a0\u21a9</p> </li> <li> <p>La m\u00e9thode <code>__init__()</code> est appel\u00e9e le constructeur de la classe.\u00a0\u21a9</p> </li> <li> <p>Le nom Prolog est un acronyme de PROgrammation en LOGique. Il a \u00e9t\u00e9 cr\u00e9\u00e9 par Alain Colmerauer et Philippe Roussel vers 1972 \u00e0 Luminy, Marseille. Le but \u00e9tait de cr\u00e9er un langage de programmation o\u00f9 seraient d\u00e9finies les r\u00e8gles logiques attendues d'une solution et de laisser le compilateur la transformer en s\u00e9quence d'instructions. (Source : Wikipedia)\u00a0\u21a9</p> </li> </ol>"},{"location":"langages-et-programmation/5-mise-au-point-gestion-bugs/","title":"Mise au point des programmes et gestion des bugs","text":"<p>Comment s\u2019assurer qu\u2019un programme fasse ce qu\u2019il est cens\u00e9 faire ? Qu\u2019il ne contient pas de bugs ?  Ces questions que chacun se pose quand il \u00e9crit un programme peuvent devenir extr\u00eamement cruciales et compliqu\u00e9es quand certains programmes informatiques contiennent des millions de lignes de code, voire des milliards (Google)<sup>1</sup> ou avoir des d\u00e9fauts de fonctionnements aux cons\u00e9quences d\u00e9sastreuses  (avionique, nucl\u00e9aire, m\u00e9dical, etc.). Des solutions existent pour essayer de limiter ces effets n\u00e9fastes.</p> <p>L\u2019utilisation combin\u00e9e de sp\u00e9cifications, d'assertions, de documentations des programmes et de jeux de tests permettent de limiter (mais pas de garantir ! <sup>2</sup> ) la pr\u00e9sence de bugs dans les programmes.</p>"},{"location":"langages-et-programmation/5-mise-au-point-gestion-bugs/#bugs-ou-bogues-et-exceptions","title":"Bugs (ou bogues) et exceptions","text":"<p>Il existe de nombreuses causes qui peuvent \u00eatre \u00e0 l\u2019origine de bugs dans un programme : oubli d\u2019un cas<sup>3</sup>, typo, d\u00e9passement de capacit\u00e9 m\u00e9moire<sup>4</sup>, mauvaise communication avec les utilisateurs ou entre programmeurs, etc.</p> <p>Cours</p> <p>Un bug (ou bogue) est une erreur dans un programme \u00e0 l\u2019origine d\u2019un dysfonctionnement. </p> <p>Un bug peut conduire \u00e0 un r\u00e9sultat qui n\u2019est pas celui attendu, par exemple si <code>est_premier(5)</code> renvoyait False, voire m\u00eame dans certains cas \u00e0 une exception (mais ce n\u2019est pas toujours le cas). </p> <p>Cours</p> <p>Une exception est une erreur qui se produit pendant l'ex\u00e9cution du programme. Lorsqu'une exception se produit (on dit que l\u2019exception est 'lev\u00e9e'), l'ex\u00e9cution normale du programme est interrompue et l'exception est trait\u00e9e.</p> <pre><code>num1, num2 = 7, 0\nprint(num1/num2)\n&gt;&gt;&gt; \nZeroDivisionError : division by zero\n</code></pre> <p>Une bonne fa\u00e7on de g\u00e9rer les exceptions est de comprendre les diff\u00e9rents types d'erreurs qui surviennent et pourquoi elles se produisent. Soyons attentifs aux messages d\u2019erreur que nous affiche l\u2019interpr\u00e9teur, ils sont d\u2019une grande utilit\u00e9<sup>5</sup>. En voici certains parmi les plus courants :</p> <ul> <li> <p><code>SyntaxError</code> : Une ligne de code non valide emp\u00eache le programme de s\u2019ex\u00e9cuter. <pre><code>&gt;&gt;&gt; print(\"Hello World)\n  File \"&lt;interactive input&gt;\", line 1\n    print(\"Hello World)\n          ^\nSyntaxError: incomplete input\n</code></pre></p> </li> <li> <p><code>IndentationError</code> : Une mauvaise indentation ne permet pas de d\u00e9finir les blocs de code correctement<sup>6</sup>.</p> </li> </ul> <pre><code>for i in range(10):\nprint(i)\nIndentationError: expected an indented block after 'for' statement on line 1\n</code></pre> <ul> <li> <p><code>TypeError</code> : Une op\u00e9ration utilise des types de donn\u00e9es incompatibles. <pre><code>&gt;&gt;&gt; \"abc\" + 2\nTraceback (most recent call last):\n  File \"&lt;interactive input&gt;\", line 1, in &lt;module&gt;\nTypeError: can only concatenate str (not \"int\") to str\n</code></pre></p> </li> <li> <p><code>ValueError</code> : Une fonction est appel\u00e9e avec une valeur d'argument non autoris\u00e9e.</p> </li> </ul> <pre><code>&gt;&gt;&gt; int('abc')\nValueError: invalid literal for int() with base 10: 'abc'\n</code></pre> <p>Pour corriger les bugs et exceptions in\u00e9vitables lorsqu\u2019on \u00e9crit un programme, le d\u00e9bogueur est un outil tr\u00e8s utile.</p> <p>Cours</p> <p>Le d\u00e9bogueur permet d\u2019effectuer l\u2019ex\u00e9cution ligne par ligne en observant l\u2019\u00e9volution du programme et les valeurs des variables.</p> <p>Pour utiliser le d\u00e9bogueur de PyScripter :</p> <ol> <li>Cr\u00e9er un point d\u2019arr\u00eat sur une ligne (clic sur le num\u00e9ro de la ligne), ou plusieurs.</li> <li>Lancer le d\u00e9bogage (      )  ce qui ex\u00e9cute le script jusqu\u2019au point d\u2019arr\u00eat</li> <li>Ex\u00e9cuter le script pas \u00e0 pas tout en inspectant l\u2019\u00e9volution des variables dans les onglets Variables ou Watches (surveillances). Pour ajouter une variable \u00e0 surveiller, cliquer droit dans la fen\u00eatre Watches et ajouter un nom de la variable ou une expression.</li> </ol>"},{"location":"langages-et-programmation/5-mise-au-point-gestion-bugs/#commentaires-noms-de-variables-et-de-fonctions","title":"Commentaires, noms de variables et de fonctions","text":"<p>Il est difficile de dire ce que fait cette fonction au premier coup d'oeil :</p> <pre><code>def f(x):\n    a = 0\n    for i in range(1, x):\n        if x % i == 0:\n            a = a + i\n    return x == a\n</code></pre> <p>PEP 8</p> <p>Ecrire les noms tout en minuscule avec des mots s\u00e9par\u00e9s par des blancs soulign\u00e9s (<code>_</code>)  par exemple <code>nom_de variable</code> (snake case) plut\u00f4t que  <code>NomDeVariable</code> (camel case)</p> <p>C\u2019est plus d\u00e9j\u00e0 plus lisible avec des noms de fonction et variable qui ont un sens plut\u00f4t que r\u00e9duits \u00e0 une lettre.</p> <pre><code>def parfait(nombre):\n    somme_diviseurs = 0\n    for i in range(1, nombre):\n        if nombre % i == 0:\n            somme_diviseurs = somme_diviseurs + i\n    return nombre == somme_diviseurs \n</code></pre> <p>et encore plus lisible avec des commentaires :</p> <pre><code>def parfait(nombre):\n    somme_diviseurs = 0\n    # Iterer sur tous les entiers i compris entre 1 et nombre - 1\n    for i in range(1, nombre):\n        # Si i est un diviseur de nombre on l'ajoute \u00e0 somme_diviseur\n        if nombre % i == 0:\n            somme_diviseurs = somme_diviseurs + i\n    # Si nombre est egal \u00e0 la somme de ses diviseurs, c'est un nombre parfait\n    return nombre == somme_diviseurs\n</code></pre> <p>Cours</p> <p>PEP 8</p> <p>Limiter la longueur des lignes \u00e0 79 ou 80 caract\u00e8res.</p> <p>\u00c9crire un beau code Python implique d'adopter certaines conventions et bonnes pratiques pour le rendre clair, lisible, maintenable et compr\u00e9hensible pour vous-m\u00eame et pour les autres d\u00e9veloppeurs<sup>7</sup> :</p> <ol> <li> <p>Choisir des noms de variables et de fonctions significatifs et \u00e9viter les noms g\u00e9n\u00e9riques comme \"a\", \"b\", \"x\", etc. qui ne donnent pas d'indication sur leur contenu. Pr\u00e9f\u00e9rer des noms descriptifs comme \"somme_diviseurs\" plut\u00f4t que \"sd\".</p> </li> <li> <p>Commenter le code pour expliquer les parties importantes, les d\u00e9cisions de conception, les algorithmes, etc. Les commentaires doivent \u00eatre clairs, concis et utiles. N'ajoutez pas de commentaires \u00e9vidents qui ne font que r\u00e9p\u00e9ter le code.</p> </li> </ol> <p><pre><code># Commentaire sur un bloc\ninstruction           # Commentaire sur une instruction particuliere\n</code></pre> 3. Eviter les r\u00e9p\u00e9tition de code et diviser les programmes en fonctions logiques, plus modulaires, plus faciles \u00e0 comprendre et \u00e0 d\u00e9boguer.</p>"},{"location":"langages-et-programmation/5-mise-au-point-gestion-bugs/#specifications-de-fonctions","title":"Sp\u00e9cifications de fonctions","text":"<p>Cours</p> <p>La sp\u00e9cification (ou prototype) d\u2019une fonction est un mode d'emploi \u00e0 l\u2019attention des utilisateurs d\u2019une fonction expliquant clairement :</p> <ul> <li> <p>ce que fait la fonction,</p> </li> <li> <p>les param\u00e8tres qu\u2019elle accepte,</p> </li> <li> <p>les valeurs qu\u2019elle renvoie.</p> </li> </ul> <p>En python, la sp\u00e9cification est r\u00e9sum\u00e9e dans la \u00ab docstring \u00bb, un commentaire au d\u00e9but du corps de la fonction entre tripe guillemets (ou triple apostrophes) :</p> <p>Par convention, les <code>\"\"\"</code> de fin sont seuls sur la derni\u00e8re ligne.    </p> <pre><code>def nom_dela_fonction (parametres):\n\"\"\" sp\u00e9cification de la fonction \u00e9crit entre triple guillemets comprenant :\n- ce que fait la fonction,\n- les param\u00e8tres qu\u2019elle accepte,\n- les valeurs qu\u2019elle renvoie. \n\"\"\"  \n</code></pre> <p>Si l\u2019id\u00e9e g\u00e9n\u00e9rale est toujours la m\u00eame, aucun format n'est impos\u00e9 m\u00eame si certaines conventions sont donn\u00e9es dans la PEP 257. En pratique, il existe diff\u00e9rentes habitudes d'\u00e9crire les docstrings de fonctions et il est important de rester consistant \u00e0 travers un m\u00eame programme pour am\u00e9liorer la lisibilit\u00e9 du code. </p> <p>Par exemple, la fonction pr\u00e9c\u00e9dente <code>parfait(nombre)</code> pourrait se pr\u00e9senter sous la forme :</p> <pre><code>def parfait(nombre):\n    \"\"\" (int) -&gt; bool\n    Renvoie True si nombre est parfait, False sinon\n    \"\"\"\n\n    somme_diviseurs = 0\n    # It\u00e9rer sur tous les entiers i compris entre 1 et nombre - 1\n    for i in range(1, nombre):\n        # Si i est un diviseur de nombre on l'ajoute \u00e0 somme_diviseur\n        if nombre % i == 0:\n            somme_diviseurs = somme_diviseurs + i\n    # Si nombre est egal \u00e0 la somme de ses diviseurs, c'est un nombre parfait\n    return nombre == somme_diviseurs\n</code></pre> <p>ou encore :</p> <pre><code>def parfait(nombre):\n    \"\"\" Renvoie True si nombre est parfait, False sinon\n    Parameters:\n        nombre (int): un nombre entier.\n    Returns:\n        bool: True si nombre est parfait, False sinon.\n    \"\"\"\n</code></pre> <p>ou plus simplement sur une seule ligne (dans ce cas les <code>\"\"\"</code>  sont \u00e9crits sur la m\u00eame ligne):</p> <pre><code>def parfait(nombre):\n    \"\"\" Renvoie True si nombre (int) est parfait, False sinon \"\"\"\n</code></pre> <p>La fonction <code>help</code> affiche la docstring d\u2019une fonction :</p> <pre><code>&gt;&gt;&gt; help(est_premier)\nHelp on function parfait in module __main__:\n\nest_premier(nombre)\n    (int) -&gt; bool\n    Renvoie True si un nombre est parfait, False sinon\n</code></pre> <p> Ne pas confondre la sp\u00e9cification encadr\u00e9e par <code>\"\"\"</code> avec les commentaires qui commencent par <code>#</code>. D\u2019ailleurs il est possible d'ajouter des commentaires commen\u00e7ant par <code>#</code>  dans une docstring qui ne seront pas affich\u00e9s par <code>help</code>. La sp\u00e9cification sera lue par le programmeur qui utilise la fonction, les commentaires par celui qui lira et modifiera le code de la fonction. </p> <p>Remarquer l'affichage dans la console ou dans la zone de programme PyScriter la sp\u00e9cification qui s\u2019affiche apr\u00e8s avoir saisi le nom de la fonction, par exemple <code>parfait(</code>. </p>"},{"location":"langages-et-programmation/5-mise-au-point-gestion-bugs/#preconditions-postconditions","title":"Pr\u00e9conditions, postconditions","text":"<p>Testons la fonction <code>parfait(nombre)</code> avec un exemple simple :</p> <p><pre><code>&gt;&gt;&gt; parfait(13)\nFalse\n</code></pre> Que se passe t\u2019il maintenant si un argument qui n\u2019est pas un entier est pass\u00e9 \u00e0 la fonction <code>parfait</code> ? </p> <pre><code>&gt;&gt;&gt; parfait(13.0)\nTraceback (most recent call last):\n  File \"&lt;interactive input&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;module2&gt;\", line 8, in parfait\nTypeError: 'float' object cannot be interpreted as an integer\n</code></pre> <p><code>nombre</code> doit imp\u00e9ratif \u00eatre de type entier. C\u2019est une pr\u00e9condition de la fonction. Il est souvent recommand\u00e9 d'indiquer les pr\u00e9conditions dans la docstring de la fonction pour limiter les risques d'erreur.</p> <pre><code>def parfait(nombre):\n    \"\"\" (int) -&gt; bool\n    Precondition : nombre est de type int et positif\n    Fonction qui renvoie True si nombre est parfait, False sinon\n    \"\"\"\n</code></pre> <p>Cours</p> <p>Les pr\u00e9conditions sont des conditions qui doivent \u00eatre vraies avant l'ex\u00e9cution d'une fonction pour garantir que celle-ci fonctionne correctement. Si une pr\u00e9condition \u00e9choue, cela signifie que l'appel de la fonction n'\u00e9tait pas correct.</p> <p>Les postconditions sont des conditions qui doivent \u00eatre vraies apr\u00e8s l'ex\u00e9cution d'une fonction. Elles permettent de v\u00e9rifier si la fonction s'est ex\u00e9cut\u00e9e correctement et a donn\u00e9 les r\u00e9sultats attendus. </p> <p>Par exemple : - une pr\u00e9condition \u00e0 une fonction effectuant une division est de s\u2019assurer que le d\u00e9nominateur est non nul, </p> <ul> <li>une postcondition \u00e0 une fonction renvoyant la valeur absolue d\u2019un nombre est de v\u00e9rifier que la fonction renvoie une valeur positive.</li> </ul> <p>Les preconditions et postconditions peuvent \u00eatre indiqu\u00e9es dans la docstring ou v\u00e9rifi\u00e9es par des assertions.</p>"},{"location":"langages-et-programmation/5-mise-au-point-gestion-bugs/#variant-et-invariant-de-boucle","title":"Variant et invariant de boucle","text":"<p>Cours</p> <p>Un variant de boucle permet de s\u2019assurer qu\u2019une boucle se terminera.</p> <p>Mais il ne v\u00e9rifie pas qu\u2019un algorithme fournit la r\u00e9ponse attendue.</p> <p>Prenons un exemple. Une fonction de division euclidienne de deux entiers positifs <code>n</code> par <code>d</code> peut s\u2019\u00e9crire de la mani\u00e8re suivante :</p> <pre><code>def division(n, d) :\n    q, r = 0, n                   \n    while r &gt;= d:     \n        q = q + 1     \n        r = r \u2013 d     \n</code></pre> <p>A noter que <code>d &gt; 0</code> est une pr\u00e9condition qui doit \u00eatre v\u00e9rifi\u00e9e au d\u00e9but de la fonction. Si ce n'est pas cas et que <code>d</code> \u2264 0 alors la boucle ne se terminera jamais !</p> <p>Ici le variant de boucle est <code>r</code>. A chaque passage dans la boucle il diminue de <code>d</code> (d est positif) donc la condition <code>r &gt;= d</code> finira par ne plus \u00eatre v\u00e9rifi\u00e9e, la boucle se terminera.</p> <p>Cours</p> <p>Un invariant de boucle est une propri\u00e9t\u00e9 ou une expression : </p> <p>\u2013 qui est vraie avant d'entrer dans la boucle ; </p> <p>\u2013 qui reste vraie apr\u00e8s chaque it\u00e9ration de boucle ; </p> <p>\u2013 et qui, conjointement \u00e0 la condition d\u2019arr\u00eat, permet de montrer que le r\u00e9sultat attendu est bien le r\u00e9sultat calcul\u00e9.</p> <p>Ici l\u2019invariant de boucle est la propri\u00e9t\u00e9: <code>n == q * d + r</code>. Prenons en exemple <code>n = 13</code> et <code>d = 3</code> et observons les \u00e9tats successifs du programme au d\u00e9but de chaque instruction.  Au d\u00e9but de la ligne 2, les valeurs de <code>q</code> et <code>r</code> ne sont pas sp\u00e9cifi\u00e9es, donc la condition <code>r &gt;= d</code> ne peut \u00eatre \u00e9valu\u00e9e, la prochaine instruction \u00e0 ex\u00e9cuter est la ligne 3 :</p> <p><pre><code>(ligne)   q       r       r &gt;= d     (ligne suivante)     n == q * d + r\n=======================================================================\n  2       -        -         -             3                -      \n</code></pre> Au d\u00e9but de la ligne 3, <code>q</code> et <code>r</code> ont pris les valeurs <code>0</code> et <code>13</code>, la condition <code>r  &gt;=  d</code> est v\u00e9rifi\u00e9e, le programme entre dans la boucle et la prochaine instruction \u00e0 ex\u00e9cuter est la ligne 4. Compl\u00e9tons la table. <pre><code>(ligne)   q       r       r &gt;= d     (ligne suivante)     n == q * d + r\n=======================================================================\n  2       -        -         -             3                -      \n  3       0       13       True            4              VRAI (entr\u00e9e dans la boucle)   \n</code></pre></p> <p>Au d\u00e9but de la ligne 4, les valeurs de <code>q</code> et <code>r</code> sont inchang\u00e9es, la condition <code>r  &gt;= d</code> reste donc v\u00e9rifi\u00e9e, l\u2019instruction suivante est 5. Compl\u00e9tons ainsi la table jusqu\u2019\u00e0 la fin du programme : <pre><code>(ligne)   q       r       r &gt;= d     (ligne suivante)     n == q * d + r\n=======================================================================\n  2       -        -         -             3                -      \n  3       0       13       True            4              VRAI (entr\u00e9e dans la boucle)   \n  4       0       13       True            5              VRAI   \n  5       1       13       True            2              FAUX\n  3       1       10       True            4              VRAI (retour dans la boucle)\n  4       1       10       True            5              VRAI   \n  5       2       10       True            3              FAUX\n  3       2        7       True            4              VRAI (retour dans la boucle)\n  4       2        7       True            5              VRAI   \n  5       3        7       True            3              FAUX\n  3       3        4       True            4              VRAI (retour dans la boucle)\n  4       3        4       True            5              VRAI   \n  5       4        4       True            3              FAUX\n  3       4        1       False     sortie de boucle     VRAI \n</code></pre></p> <p>il n'y a pas unicit\u00e9 de variant ni d'invariant de boucle.</p> <p>Observons que la propri\u00e9t\u00e9 <code>n == q * d + r</code> reste vraie \u00e0 chaque retour dans la boucle, m\u00eame si elle n'est pas toujours vraie au milieu de la boucle. Elle est aussi vraie en sortie de boucle et permet de s\u2019assurer que le r\u00e9sultat calcul\u00e9 est celui attendu.</p> <p>Exercice corrig\u00e9</p> <p>On consid\u00e8re la fonction <code>palindrome</code> suivante : <pre><code>def palindrome(mot):\n    \"\"\" Renvoie True si mot est un palindrome, False sinon \"\"\"\n    i = 0\n    j = len(mot) - 1\n    while i &lt;= j:\n        if mot[i] == mot[j]:\n            i = i + 1\n            j = j - 1\n        else:\n            return False\n    return True\n</code></pre></p> <ol> <li>D\u00e9crire l\u2019\u00e9volution des valeurs des variables le fonctionnement de l\u2019algorithme pr\u00e9c\u00e9dent pour le mot <code>\"radar\"</code>.</li> <li>Montrer que <code>j \u2013 i</code> est un variant de boucle. En d\u00e9duire que la fonction <code>palindrome</code> se termine.</li> <li>Montrer que <code>i + j == len(mot) - 1</code> est un invariant de boucle.</li> </ol> R\u00e9ponse 1 <p>La table suivante montre les \u00e9tats successifs du programme avec le mot <code>\"radar\"</code>. <pre><code>(ligne)   i      j     i &lt;= j   mot[i]   mot[j]   j \u2013 i     i + j    (ligne suivante) \n=========================================================================================\n  4       0      -       -        r         -       -         -       (5)                    \n  5       0      4      True      r         r       4         4       (6) entr\u00e9e dans la boucle  \n  6       0      4      True      r         r       4         4       (7) mot[i] == mot[j]\n  7       0      4      True      r         r       4         4       (8) \n  8       1      4      True      a         r       3         5       (5) \n  5       1      3      True      a         a       2         4       (6) entr\u00e9e dans la boucle  \n  6       1      3      True      a         a       2         4       (7) mot[i] == mot[j]\n  7       1      3      True      a         a       2         4       (8) \n  8       2      3      True      d         a       1         5       (5) \n  5       2      2      True      d         d       0         4       (6) entr\u00e9e dans la boucle  \n  6       2      2      True      d         d       0         4       (7) mot[i] == mot[j]\n  7       2      2      True      d         d       0         4       (8) \n  8       3      2      False     a         d      -1         5       (5) \n  5       3      1      False     a         d      -2         4       (11) sortie de la boucle  \n</code></pre></p> R\u00e9ponse 2 <p>A chaque it\u00e9ration <code>j - i</code>  diminue de 2 , c\u2019est un variant de boucle qui finira par devenir n\u00e9gatif, autrement dit la condition <code>i &lt;= j</code> deviendra fausse et la boucle s\u2019arr\u00eatera (\u00e0 moins qu\u2019elle se termine plus t\u00f4t si mot n\u2019est pas un palindrome), donc le programme se terminera. </p> <p>Il est aussi possible de le d\u00e9montrer formellement. Supposons que l\u2019on rentre dans la boucle \u00e0 la ligne 5 avec <code>i</code> et <code>j</code> ayant des valeurs appel\u00e9es \\(x\\) et \\(y\\).  <code>j - i</code>  est \u00e9gal \u00e0 \\(y - x\\).  Apr\u00e8s les lignes 7 et 8,  <code>i</code> devient \u00e9gal \u00e0 \\(x + 1\\) et <code>j</code> \u00e0 \\(y - 1\\), donc  <code>j - i</code>  devient bien \u00e9gal \u00e0 \\((y - 1) \u2013 (x + 1) = (y \u2013 x) - 2\\).  <code>j - i</code>  a bien diminu\u00e9 de \\(2\\).</p> R\u00e9ponse 3 <p>De la m\u00eame fa\u00e7on, il est possible de d\u00e9montrer que <code>i + j == len(mot) - 1</code>   est un invariant de boucle :</p> <ul> <li>Au d\u00e9but du programme, avant de rentrer dans la boucle, <code>i</code> est \u00e9gal \u00e0 0 et  j est \u00e9gal \u00e0 <code>len(mot)- 1</code> donc  <code>i + j</code> est bien \u00e9gal \u00e0 <code>len(mot) - 1</code>.   </li> <li>Lorsqu\u2019on rentre dans la boucle \u00e0 la ligne 5 avec <code>i</code> et <code>j</code> ayant des valeurs \\(x\\) et \\(y\\) telles que \\(x + y\\) est \u00e9gal \u00e0 <code>len(mot) - 1</code> , apr\u00e8s les lignes 7 et 8, <code>i</code> devient \u00e9gal \u00e0 \\(x + 1\\) et <code>j</code> \u00e0 \\(y - 1\\), donc  <code>i + j</code>  est toujours \u00e9gal \u00e0 $(x + 1) + (y - 1) = x + y $ c'est-\u00e0-dire \u00e0 <code>len(mot)  \u2013 1</code>.</li> </ul>"},{"location":"langages-et-programmation/5-mise-au-point-gestion-bugs/#assertions","title":"Assertions","text":"<p>Des assertions permettent de tester les pr\u00e9conditions, postconditions et les invariants de boucles. Leur non-respect alerte sur une erreur de programmation. </p> <p>Cours</p> <p>Une Assertion v\u00e9rifie qu\u2019une expression est *vraie et arr\u00eate le programme sinon . <pre><code>assert &lt;condition&gt; \n</code></pre></p> <p>Un message peut \u00eatre affich\u00e9 quand une assertion est fausse avant d'arr\u00eater le programme :</p> <pre><code>assert &lt;condition&gt;, 'message '\n</code></pre> <p>Reprenons la fonction <code>est_premier(nombre)</code> vue pr\u00e9c\u00e9demment. Le param\u00e8tre <code>nombre</code> doit \u00eatre de type entier et positif. Ce sont des pr\u00e9conditions. Ajoutons les assertions correspondantes au d\u00e9but de la fonction.</p> <pre><code>def est_premier(nombre):\n    \"\"\" (int) -&gt; bool\n    Precondition : nombre est de type int et positif\n    Renvoie True si nombre est premier, False sinon\n    \"\"\"\n    assert type(nombre) == int\n    assert nombre &gt;= 0, 'nombre doit \u00eatre positif' \n    # Cherche un diviseur entre 2 et nombre-1\n    for d in range(2, nombre): \n        if nombre%d == 0:   # d divise nombre donc nombre n'est pas premier\n            return False\n    # Pas diviseur entre 2 et n-1, donc nombre est premier\n    return True \n</code></pre> <p>et testons le r\u00e9sultat :</p> <pre><code>&gt;&gt;&gt; est_premier('5')\nTraceback (most recent call last):\n  File \"&lt;interactive input&gt;\", line 1, in &lt;module&gt;\n  File \"\u2026.\", line 16, in est_premier\n    assert(type(nombre) == int)\nAssertionError  \n\n&gt;&gt;&gt; est_premier(-1)\nTraceback (most recent call last):\n  File \"&lt;interactive input&gt;\", line 1, in &lt;module&gt;\n  File \"\u2026.\", line 7, in est_premier\n    assert nombre &gt;= 0, 'nombre doit \u00eatre positif'\nAssertionError: nombre doit \u00eatre positif\n</code></pre> <p><code>assert</code> est souvent utilis\u00e9 en phase de test seulement ou en programmation d\u00e9fensive<sup>8</sup>. </p> <p>L'instruction <code>try...\u2026except...</code> (hors programme) permet de g\u00e9rer efficament les erreurs pr\u00e9visibles d\u2019utilisateur, lors d\u2019une saisie par exemple : </p> <pre><code>while True:\n    try:\n        n = input(\"Entrez un nombre entier \")\n        n = int(n)\n        break\n    except ValueError:\n        print(n, \"n'est pas un entier, essayer \u00e0 nouveau ...\")\nprint(n, \"est bien un nombre entier\")\n</code></pre>"},{"location":"langages-et-programmation/5-mise-au-point-gestion-bugs/#jeux-de-tests","title":"Jeux de tests","text":"<p>Les sp\u00e9cifications et les v\u00e9rifications des pr\u00e9 et postconditions d\u2019un programme ne garantissent pas l\u2019absence de bugs. Avant de pouvoir utiliser un programme, il est important d\u2019effectuer un jeu de tests pour d\u00e9celer d\u2019\u00e9ventuelles erreurs.</p> <p>Cours</p> <p>Un jeu de test permet de trouver d\u2019\u00e9ventuelles erreurs. Le succ\u00e8s d\u2019un jeu de tests ne garantit pas qu\u2019il n\u2019y ait pas d\u2019erreur.   </p> <p>La qualit\u00e9 et le nombre de tests sont importants.</p>"},{"location":"langages-et-programmation/5-mise-au-point-gestion-bugs/#la-qualite-des-tests","title":"La qualit\u00e9 des tests","text":"<p>Cours</p> <p>Les tests doivent porter sur des valeurs d\u2019arguments \"normales\" mais aussi des valeurs \"sp\u00e9ciales\" ou \"extr\u00eames\" du programme. </p> <p>Par exemple, que se passe-t-il quand les valeurs <code>0</code> ou <code>1</code> sont pass\u00e9es en argument \u00e0 la fonction <code>est_premier</code> ? <pre><code>&gt;&gt;&gt; est_premier(0)\nTrue\n&gt;&gt;&gt; est_premier(1)\nTrue\n</code></pre></p> <p>Mais <code>0</code> et <code>1</code> ne sont pas des nombres premiers ! Il faut donc corriger la fonction en ajoutant ces cas qui avaient \u00e9t\u00e9 oubli\u00e9s.</p> <pre><code>def est_premier(nombre):\n    \"\"\" (int) -&gt; bool\n    Precondition : nombre est de type int et positif\n    Renvoie True si nombre est premier, False sinon\n    \"\"\"\n    assert type(nombre) == int\n    assert nombre &gt;= 0, 'nombre doit \u00eatre positif' \n    # 0 et 1 ne sont pas premiers\n    if (nombre == 0) or (nombre == 1):\n        return False\n    # Cherche un diviseur entre 2 et nombre-1\n    for d in range(2, nombre): \n        if nombre%d == 0:   # d divise nombre donc nombre n'est pas premier\n            return False\n    # Pas diviseur entre 2 et n-1, donc nombre est premier\n    return True \n</code></pre>"},{"location":"langages-et-programmation/5-mise-au-point-gestion-bugs/#le-nombre-de-tests","title":"Le nombre de tests","text":"<p>Cours</p> <p>Un programme de test permet d\u2019effectuer un grand nombre de tests automatiquement.</p> <p>V\u00e9rifions par des assertions la fonction <code>est_premier</code> pour tous les multiples de 2 allant de 4 \u00e0 100.</p> <pre><code>def test_est_premier():\n    \"\"\"Jeu de tests de est_premier() pour tous les multiples de 2 entre 4 et 100 \"\"\"\n    for i in range(2, 51):\n        assert not est_premier(2 * i)                                      \n    return True\n</code></pre> <p>Il est aussi possible d'\u00e9crire un programme de tests en utilisant la c\u00e9l\u00e8bre formule d\u2019Euler : \\(n^2 + n + 41\\) qui produit de nombreux nombres premiers, notamment pour tous les nombres \\(n\\) allant de 0 \u00e0 39.</p> <pre><code>def test2_est_premier():\n    \"\"\"Jeu de tests de est_premier() par la formule d\u2019Euler 2**2+n+41\"\"\"\n    for i in range(40):\n        assert est_premier(i**2 + i + 41) \n    return True\n</code></pre>"},{"location":"langages-et-programmation/5-mise-au-point-gestion-bugs/#le-module-doctest","title":"Le module doctest","text":"<p>La fonction <code>tesmod()</code> du module <code>doctest</code> permet d\u2019effectuer automatiquement un jeu de tests d\u00e9fini dans la docstring d\u2019une fonction. Chaque test \u00e0 effectuer est indiqu\u00e9 dans la docstring sur une ligne commen\u00e7ant par <code>&gt;&gt;&gt;</code> pour simuler la console et le r\u00e9sultat attendu dans la ligne suivante.</p> <p>Par exemple : <pre><code>import doctest\n\ndef est_premier(nombre):\n    \"\"\" (int) -&gt; bool\n    Precondition : nombre est de type int et positif\n    Renvoie True si nombre est premier, False sinon\n    &gt;&gt;&gt; est_premier(3)\n    True\n    &gt;&gt;&gt; est_premier(4)\n    False\n    \"\"\"\n\u2026\n\ndoctest.testmod()\n</code></pre></p> <ol> <li> <p>https://www.informationisbeautiful.net/visualizations/million-lines-of-code/ \u21a9</p> </li> <li> <p>Dans la pratique il n'est pas possible de tester un logiciel dans toutes les conditions qu'il pourrait rencontrer lors de son utilisation et donc pas possible de contrer la totalit\u00e9 des bugs : un logiciel comme Microsoft Word compte 850 commandes et 1 600 fonctions, ce qui fait un total de plus de 500 millions de conditions \u00e0 tester.\u00a0\u21a9</p> </li> <li> <p>En 1996, l'USS Yorktown teste le programme Navy's Smart Ship. Un membre d'\u00e9quipage rentre un z\u00e9ro comme valeur lors de man\u0153uvres. Source : https://en.wikipedia.org/wiki/USS_Yorktown_(CG-48) \u21a9</p> </li> <li> <p>Premier vol d'Ariane 5 en 1996 :  Le code utilis\u00e9 \u00e9tait celui d'Ariane 4, mais les valeurs d'acc\u00e9l\u00e9ration de la fus\u00e9e d\u00e9passent les valeurs maximales pr\u00e9vues ! Source: https://fr.wikipedia.org/wiki/Vol_501_d%27Ariane_5 \u21a9</p> </li> <li> <p>RTFM est, en anglais, le sigle de la phrase Read the fucking manual, injonction signifiant que la r\u00e9ponse \u00e0 une question sur le fonctionnement d'un appareil est \u00e0 chercher dans son mode d'emploi.\u00a0\u21a9</p> </li> <li> <p>Contrairement \u00e0 d'autres langages comme Java, C ou C++, qui utilisent des accolades pour s\u00e9parer les blocs de code, Python utilise l'indentation pour d\u00e9finir la hi\u00e9rarchie et la structure des blocs de code.\u00a0\u21a9</p> </li> <li> <p>Comme le disait Guido van Rossum: \u201cCode is read much more often than it is written.\u201d\u00a0\u21a9</p> </li> <li> <p>La programmation d\u00e9fensive est un mode de programmation qui vise \u00e0 cr\u00e9er des programmes et des applications robustes face aux erreurs et aux entr\u00e9es de donn\u00e9es inattendues.\u00a0\u21a9</p> </li> </ol>"},{"location":"structures-de-donnees/","title":"Structures de donn\u00e9es","text":"<p>On a d\u00e9j\u00e0 \u00e9tudi\u00e9 en classe de premi\u00e8re certaines structures de donn\u00e9es informatiques qui permettent stocker et de manipuler des donn\u00e9es organis\u00e9es : p-uplets, tableaux, dictionnaires. Il en existe beaucoup d'autres, notamment les listes, les piles, les files, les arbres et les graphes, qui font l'objet de ce chapitre.</p> <p>Ces structures de donn\u00e9es sont essentielles en informatique. Elles servent \u00e0 r\u00e9soudre divers probl\u00e8mes et \u00e0 organiser efficacement les donn\u00e9es en fonction des besoins sp\u00e9cifiques d'une application. Le choix de la structure de donn\u00e9es appropri\u00e9e d\u00e9pend de la nature des donn\u00e9es et des op\u00e9rations \u00e0 effectuer.</p> <p>La programmation orient\u00e9e objet est particuli\u00e8rement bien adapt\u00e9e pour impl\u00e9menter certaines de ces structures. C'est l'un des paradigmes de programmation les plus populaires. Nous commen\u00e7ons le chapitre par en \u00e9tudier les grand principes.</p>"},{"location":"structures-de-donnees/1-poo/","title":"Programmation orient\u00e9e objet","text":"<p>Cours</p> <p>La programmation orient\u00e9e objet, ou POO, est un paradigme de programmation informatique. Elle consiste \u00e0 d\u00e9finir des briques logicielles appel\u00e9es objets et \u00e0 d\u00e9crire leurs comportements et interactions.  </p> <p>Un objet en programmation orient\u00e9e objet repr\u00e9sente souvent un concept, une id\u00e9e ou toute entit\u00e9 du monde physique (une voiture, une personne, une page d'un livre, etc.).</p> <p>Exemple de langages orient\u00e9s objets : Java et C++, mais aussi les langages multi-paradigmes comme Python.</p> <p>Cours</p> <p>La classe est comme un \"moule\" \u00e0 partir duquel des objets d'un m\u00eame type peuvent \u00eatre cr\u00e9\u00e9s. Elle d\u00e9finit pour chaque objet de cette classe : </p> <ul> <li> <p>des attributs comportant les informations concernant chaque objet ; </p> </li> <li> <p>des m\u00e9thodes d\u00e9crivant le comportement d'un objet.</p> </li> </ul> <p>Une fois une classe d'objet d\u00e9finie, il est possible de cr\u00e9er des objets sur le mod\u00e8le de cette classe, c'est  l'instanciation. Les objets sont des instances de la classe. </p> <p>Prenons l'exemple d'un programme pour aider un collectionneur de vieilles voitures qui poss\u00e8de une Citroen 2CV avec 152 000 km, une Renault Dauphine avec 75 000 km, etc. Une classe <code>Voiture</code>, d\u00e9crivant les attributs et les m\u00e9thodes d'une voiture, permet d'instancier plusieurs objets, chaque objet repr\u00e9sentant une voiture : la Citroen 2CV (<code>voiture_1</code>), la Renault Dauphine (<code>voiture_2</code>), etc.</p> <p> </p>"},{"location":"structures-de-donnees/1-poo/#les-classes-et-objets","title":"Les classes et objets","text":"<p>Commen\u00e7ons par cr\u00e9er la classe <code>Voiture</code> qui d\u00e9crit les caract\u00e9ristiques d'une voiture :   </p> <p>PEP 8</p> <p>Les noms de classes s'\u00e9crivent en CamelCase : https://www.python.org/dev/peps/pep-0008/#class-names</p> <pre><code>class Voiture:\n    pass\n</code></pre> <p>La classe <code>Voiture</code> n'est pas une voiture, c'est une sorte \u00ab d'usine \u00e0 cr\u00e9er des voitures \u00bb ! Elle permet de cr\u00e9er par la suite des d'objets, des instances de la classe <code>Voiture</code>, sur le mod\u00e8le de cette classe.</p> <p>Cr\u00e9ons maintenant les deux premi\u00e8res voitures du collectionneur, c'est-\u00e0-dire deux instances de la classe <code>Voiture</code> :</p> <pre><code>voiture_1 = Voiture()\nvoiture_2 = Voiture()\n</code></pre> <p>Cours</p> <p>Pour cr\u00e9er un objet, ou instancier, <code>nom_objet</code> depuis la classe <code>NomClasse</code>, il faut \u00e9crire :</p> <p><code>nom_objet = NomClasse()</code></p>"},{"location":"structures-de-donnees/1-poo/#les-attributs","title":"Les attributs","text":"<p>Pour l'instant notre classe <code>Voiture</code> est une coquille vide et les deux objets instanci\u00e9s \u00e0 partir de cette classe, <code>voiture_1</code> et <code>voiture_2</code>, ne contiennent aucune information concernant ces voitures. Il est possible de leur rajouter des caract\u00e9ristiques les d\u00e9crivant avec des attributs, par exemple les attributs <code>marque</code>, <code>modele</code> et <code>km</code> pour l'instance <code>voiture_1</code> : </p> <pre><code>&gt;&gt;&gt; voiture_1 = Voiture()\n&gt;&gt;&gt; voiture_1.marque = \"Citroen\"\n&gt;&gt;&gt; voiture_1.modele = \"2 CV\"\n&gt;&gt;&gt; voiture_1.km = 152000\n</code></pre> <p>et ensuite de lire les attributs ainsi :</p> <pre><code>&gt;&gt;&gt; voiture_1.marque\n'Citroen'\n</code></pre> <p>Mais les attributs <code>marque</code>, <code>modele</code> et <code>km</code>  ont \u00e9t\u00e9 cr\u00e9\u00e9s pour l'objet <code>voiture_1</code>, ils n'existent pas pour les autres instances de <code>Voiture</code>, par exemple pour l'objet <code>voiture_2</code> : </p> <pre><code>&gt;&gt;&gt; voiture_2.marque\nTraceback (most recent call last):\n  File \"&lt;interactive input&gt;\", line 1, in &lt;module&gt;\nAttributeError: 'Voiture' object has no attribute 'marque'\n</code></pre> <p>Cours</p> <p>Un attribut  <code>nom_attribut</code> d'un objet <code>nom_objet</code> s'obtient avec : <code>nom_objet.nom_attribut</code></p>"},{"location":"structures-de-donnees/1-poo/#constructeur","title":"Constructeur","text":"<p>La cr\u00e9ation d'un nouvel objet avec l'instruction <code>voiture_1 = Voiture()</code> appelle une m\u00e9thode particuli\u00e8re nomm\u00e9e <code>__init__</code>. C'est le constructeur de la classe. Il est possible de le modifier pour d\u00e9finir des attributs pour toutes les instances de <code>Voiture</code> d\u00e8s leur instanciation :</p> <p> Attention aux deux blancs soulign\u00e9s (ou tirets bas) au d\u00e9but et \u00e0 la fin d'<code>init</code>, c'est souvent une erreur difficile \u00e0 d\u00e9celer quand il en manque un !</p> <pre><code>class Voiture:\n    def __init__(self):\n        self.marque = \"\"\n        self.modele = \"\"\n        self.km = 0\n</code></pre> <p>Noter le param\u00e8tre <code>self</code> de la fonction qui repr\u00e9sente l'objet qui est instanci\u00e9 par la m\u00e9thode <code>__init__</code>.</p> <p>Toutes les instances de <code>Voiture</code> poss\u00e9deront ces attributs, mais les valeurs peuvent \u00eatre diff\u00e9rentes pour chaque instance et \u00e9voluer diff\u00e9remment.</p> <pre><code>&gt;&gt;&gt; voiture_1 = Voiture()\n&gt;&gt;&gt; voiture_1.modele\n''\n&gt;&gt;&gt; voiture_1.modele = \"2 CV\"\n&gt;&gt;&gt; voiture_1.modele \n'2 CV'\n</code></pre> <p>Avec ce constructeur, tous les objets sont cr\u00e9\u00e9s avec les attributs initi\u00e9s \u00e0 la m\u00eame valeur (<code>\"\"</code> ou <code>0</code>). Ce n'est pas pratique. La m\u00e9thode <code>__init__</code> est une m\u00e9thode comme les autres, elle peut avoir des param\u00e8tres, par exemple la marque et le mod\u00e8le de la voiture, ainsi que le nombre de kilom\u00e8tres (assign\u00e9 \u00e0 la valeur 0 par d\u00e9faut s'il n'est pas renseign\u00e9).</p> <p>PEP 8</p> <p>Comme les fonctions et les modules, les classes et les m\u00e9thodes publiques comportent une docstring. Voir https://peps.python.org/pep-0008/#documentation-strings</p> <pre><code>class Voiture:\n    \"\"\" \n    Classe d'objets repr\u00e9sentants des voitures de collection \n\n    Attributs:\n    marque (str): la nom de la marque de la voiture\n    modele (str): le mod\u00e8le de la voiture\n    km (int): les km parcourus par la voiture\n    \"\"\"\n\n    def __init__(self, ma, mo, k=0):\n        self.marque = ma\n        self.modele = mo\n        self.km = k\n</code></pre> <p>L'instruction <code>Voiture('Citroen', '2 CV')</code> appelle le constructeur  <code>__init__</code>  cr\u00e9ant ainsi un nouvel objet <code>Voiture</code> en lui donnant les valeurs de ses attributs <code>'Citroen'</code>, <code>'2 CV'</code> et <code>152000</code>.</p> <pre><code>&gt;&gt;&gt; voiture_1 = Voiture('Citroen', '2 CV', 152000)\n&gt;&gt;&gt; voiture_1.modele\n'2 CV'\n&gt;&gt;&gt; voiture_1.km\n152000\n</code></pre>"},{"location":"structures-de-donnees/1-poo/#les-methodes","title":"Les m\u00e9thodes","text":"<p>D\u00e9finir une classe c'est aussi d\u00e9finir les comportements communs aux objets de la classe : ce sont les m\u00e9thodes. Les m\u00e9thodes sont des fonctions d\u00e9finies dans une classe. Nous avons d\u00e9j\u00e0 vu la m\u00e9thode <code>__init__</code> appel\u00e9e \u00e0 l'instanciation. On peut ajouter d'autres m\u00e9thodes dans la classe <code>Voiture</code>.</p> <p>Cours</p> <p>Les m\u00e9thodes prennent toujours comme premier param\u00e8tre le mot r\u00e9serv\u00e9 <code>self</code> de fa\u00e7on \u00e0 d\u00e9signer l'objet sur lequel va s'appliquer la m\u00e9thode.</p> <p>Par exemple une m\u00e9thode <code>roule(k)</code>, permettant d'ajouter <code>k</code> kilom\u00e8tres quand un voiture, roule s'\u00e9crit  :</p> <pre><code>class Voiture:\n    \"\"\" \n    Classe d'objets repr\u00e9sentants des voitures de collection \n\n    Attributs:\n    marque (str): la nom de la marque de la voiture\n    modele (str): le mod\u00e8le de la voiture\n    km (int): les km parcourus par la voiture\n    \"\"\"\n\n    def __init__(self,ma, mo, k=0):\n        self.marque = ma\n        self.modele = mo\n        self.km = k\n\n    def roule(self, k):\n        self.km = self.km + k\n</code></pre> <p>Cours</p> <p>Pour appeler une m\u00e9thode <code>nom_methode(self, param1, param2..)</code> qui s'applique \u00e0 un objet <code>nom_objet</code>, il faut \u00e9crire : <code>nom_objet.nom_methode(param1, param2 ,\u2026)</code>. </p> <p>Le param\u00e8tre <code>self</code> est toujours le premier param\u00e8tre dans la d\u00e9finition d'une m\u00e9thode, il d\u00e9crit l'objet sur lequel s'applique la m\u00e9thode, il n'appara\u00eet pas dans les arguments de la m\u00e9thode lors de l'appel.</p> <p>Appelons la m\u00e9thode <code>roule(self, k)</code> :</p> <pre><code>&gt;&gt;&gt; voiture_1 = Voiture('Citroen', '2 CV', 152000)\n&gt;&gt;&gt; voiture_1.km\n152000\n&gt;&gt;&gt; voiture_1.roule(15000)\n&gt;&gt;&gt; voiture_1.km\n167000\n</code></pre> <p>Ici quand la m\u00e9thode <code>voiture_1.roule(15000)</code> est ex\u00e9cut\u00e9e, <code>self</code> prend le nom de l'objet <code>voiture_1</code> et <code>k</code> la valeur  <code>15000</code>.</p> <p>Notons aussi qu'une m\u00e9thode peut renvoyer une valeur. Prenons l'exemple de <code>revision</code>, une m\u00e9thode qui renvoie les kilom\u00e8tres avant la prochaine r\u00e9vision  : </p> <pre><code>class Voiture:\n    \"\"\" \n    Classe d'objets repr\u00e9sentants des voitures de collection \n\n    Attributs:\n    marque (str): la nom de la marque de la voiture\n    modele (str): le mod\u00e8le de la voiture\n    km (int): les km parcourus par la voiture\n\n    M\u00e9thodes:\n    roule(km): ajoute des km parcourus\n    revision(): renvoie le nombre de km restant avant la prochaine revision des 15000\n    \"\"\"\n\n    def __init__(self,ma, mo , k=0):\n        self.marque = ma\n        self.modele = mo\n        self.km = k\n\n    def roule(self, km):\n        self.km = self.km + km\n\n    def revision(self):\n        return 15000 - self.km % 15000\n\n&gt;&gt;&gt; voiture_1 = Voiture('Citroen', '2 CV', 152000)\n&gt;&gt;&gt; voiture_1.revision()\n13000\n</code></pre> <p>Il existe en Python quelques m\u00e9thodes particuli\u00e8res. Comme <code>__init__()</code>, leur nom est entour\u00e9 de deux paires de blancs soulign\u00e9s. Par exemple l'instruction <code>&gt;&gt;&gt; dir(list)</code> dans la console permet observer les m\u00e9thodes des variables de type <code>list</code>.</p> <p>Les paires de blancs soulign\u00e9s (ou tirets bas) indiquent que ces m\u00e9thodes ne sont pas appel\u00e9es directement (elles sont priv\u00e9es) mais plut\u00f4t par le biais de fonctions particuli\u00e8res : </p> <ul> <li> <p><code>__init__(self)</code> est appel\u00e9e \u00e0 l'instanciation par <code>nom_objet = nom_classe()</code>.</p> </li> <li> <p><code>__str__(self)</code> est appel\u00e9e par la fonction <code>print()</code>. La valeur renvoy\u00e9e par <code>__str__()</code> sera affich\u00e9e quand on fera <code>print(nom_objet)</code> ou bien la cha\u00eene de caract\u00e8re renvoy\u00e9e par <code>str(nom_objet)</code>.</p> <p><pre><code>def __str__(self):\n    return self.modele + ' '+ self.marque\n</code></pre> Noter l'utilisation de <code>return</code> et non de <code>print()</code> dans la d\u00e9finition de la m\u00e9thode <code>__str__(self)</code>, c'est souvent risque d'erreurs.</p> <pre><code>&gt;&gt;&gt; print(voiture_1)\n2 CV Citroen\n</code></pre> </li> <li> <p><code>__len__(self)</code> est appel\u00e9e par <code>len(nom_objet)</code>.</p> </li> <li><code>__add__(self, other)</code> pour ajouter deux objet avec le signe \u00ab <code>+</code> \u00bb; <code>__mul__(self, other)</code> pour les multiplier avec \u00ab <code>*</code> \u00bb; <code>__lt__(self, other)</code> pour comparer avec \u00ab <code>&lt;</code> \u00bb, etc.\u2003</li> </ul>"},{"location":"structures-de-donnees/1-poo/#alias","title":"Alias","text":"<p>Lorsqu'un objet est assign\u00e9 \u00e0 une variable, par exemple  <code>voiture_1 = Voiture('Citroen', '2 CV')</code>, la variable est une r\u00e9f\u00e9rence \u00e0 cet objet, c'est-\u00e0-dire son adresse m\u00e9moire. D\u00e8s lors, deux variables peuvent faire r\u00e9f\u00e9rence au m\u00eame objet, ce sont des alias. On peut acc\u00e9der ou modifier l'objet par l'une ou l'autre.  Cela m\u00e8ne \u00e0 de nombreuses erreurs de programmation.</p> <pre><code>&gt;&gt;&gt; voiture_2 = Voiture('Renault','Dauphine', 75254)\n&gt;&gt;&gt; v = voiture_2\n</code></pre> <p>Les deux variables <code>voiture_2</code> et <code>v</code> pointent maintenant sur le m\u00eame objet :</p> <pre><code>&gt;&gt;&gt; voiture_2\n&lt;__main__.Voiture object at 0x02E102C8&gt;\n&gt;&gt;&gt; v\n&lt;__main__.Voiture object at 0x02E102C8&gt;\n&gt;&gt;&gt;\n</code></pre> <p>Et par cons\u00e9quent, une modification de l'un modifie l'autre : </p> <pre><code>&gt;&gt;&gt; voiture_2.km\n75254\n&gt;&gt;&gt; v.roule(10000)\n&gt;&gt;&gt; voiture_2.km\n85254\n</code></pre>"},{"location":"structures-de-donnees/1-poo/#variable-de-classe","title":"Variable de classe","text":"<p>Nous avons d\u00e9fini une classe comportant des attributs et des m\u00e9thodes. Les attributs sont d\u00e9clar\u00e9s \u00e0 l'int\u00e9rieur du constructeur de l'objet et prennent donc une valeur qui est propre \u00e0 chaque objet instanci\u00e9 de la classe. Deux objets diff\u00e9rents appartenant \u00e0 la m\u00eame classe ont des valeurs d'attributs qui peuvent \u00eatre diff\u00e9rents. C'est pourquoi les attributs sont aussi appel\u00e9s des variables d'instance. </p> <p>Dans notre exemple, la classe  <code>Voiture</code> d\u00e9finit les attributs et les m\u00e9thodes qui s'appliquent \u00e0 chaque voiture, c'est-\u00e0-dire \u00e0 chaque instance de cette classe. Mais comment conna\u00eetre le nombre total d'instances qui ont \u00e9t\u00e9 cr\u00e9\u00e9es \u00e0 partir ce cette classe ?  Ce n'est pas une valeur qui est propre \u00e0 une instance en particulier. Elle concerne plut\u00f4t toute la classe.</p> <p>\u00c0 l'oppos\u00e9 de ces variables d'instance, il est utile dans certains cas d'avoir des variables dont la valeur est commune \u00e0 toutes les instances de la m\u00eame classe. Ces variables sont des variables de classe. La valeur d'une variable de classe est partag\u00e9e par toutes les instances de cette classe. Chacune des instances de la classe peut la lire ou la modifier.</p> <p>Une variable de classe est d\u00e9clar\u00e9e en dehors du constructeur de la classe. Noter qu'\u00e0 la diff\u00e9rence d'une variable d'instance, elle ne commence pas par <code>self.</code> puisqu'elle ne s'applique pas \u00e0 une instance en particulier :</p> <p><pre><code>class Voiture:\n    total_voiture = 0\n\n    def __init__(self,ma, mo, k=0):\n        self.marque = ma\n        self.modele = mo\n        self.km = k\n        Voiture.total_voiture += 1\n</code></pre> puis <code>NomClasse.nom_variable_de_classe</code> permet d'utiliser cette variable de classe (en opposition \u00e0 <code>nom_objet.nom_attribut</code> pour une variable d'instance) :</p> <pre><code>&gt;&gt;&gt; Voiture.total_voiture\n0\n&gt;&gt;&gt; voiture_1 = Voiture('Citroen', '2 CV', 152000)\n&gt;&gt;&gt; Voiture.total_voiture\n1\n&gt;&gt;&gt; voiture_1 = Voiture('Renault','Dauphine', 75000)\n&gt;&gt;&gt; Voiture.total_voiture\n2\n&gt;&gt;&gt;\n</code></pre>"},{"location":"structures-de-donnees/1-poo/#encapsulation","title":"Encapsulation","text":"<p>Ajoutons maintenant une nouvelle variable de classe <code>total_km</code> qui garde en m\u00e9moire le total des kilom\u00e8tres parcourus par toutes les instances de <code>Voiture</code> :</p> <pre><code>class Voiture:\n    total_voiture = 0\n    total_km = 0\n\n    def __init__(self,ma, mo, k=0):\n        self.marque = ma\n        self.modele = mo\n        self.km = k\n        Voiture.total_voiture += 1\n        Voiture.total_km += k\n\n    def roule(self, k):\n        self.km=self.km + k\n        Voiture.total_km += k\n</code></pre> <p>puis cr\u00e9ons deux voitures et faisons rouler une des deux :</p> <pre><code>&gt;&gt;&gt; Voiture.total_km\n0\n&gt;&gt;&gt; voiture_1 = Voiture('Citroen', '2 CV', 125000)\n&gt;&gt;&gt; voiture_2 = Voiture('Renault','Dauphine', 75000)\n&gt;&gt;&gt; Voiture.total_km\n200000\n&gt;&gt;&gt; voiture_2.roule(10000)\n&gt;&gt;&gt; Voiture.total_km\n230000\n</code></pre> <p>Jusqu'ici tout va bien. Mais que se passe-t-il si on change la valeur de l'attribut <code>km</code> d'une instance de <code>Voiture</code> directement ?</p> <pre><code>&gt;&gt;&gt; voiture_2.km = 100000\n&gt;&gt;&gt; Voiture.total_km\n230000\n</code></pre> <p>L'attribut <code>km</code> de <code>voiture_2</code> a chang\u00e9 mais pas la valeur de la variable de classe <code>total_km</code>, elle n'est plus correcte ! C'est un probl\u00e8me. </p> <p>Pour \u00e9viter ce genre de probl\u00e8me, il faut \u00ab prot\u00e9ger \u00bb la variable de classe <code>total_km</code> pour que sa valeur ne soit pas modifi\u00e9e directement. C'est comme si cette variable <code>total_km</code> \u00e9tait mise \u00e0 \u00ab l'int\u00e9rieur d'une bo\u00eete interne \u00bb \u00e0 l'objet, cach\u00e9e de \u00ab l\u2019ext\u00e9rieur \u00bb, afin qu'elle ne soit lue et modifi\u00e9e qu'en utilisant des m\u00e9thodes qui garantissent que sa valeur reste correcte. C'est le m\u00e9canisme d'encapsulation.</p> <p>Cours</p> <p>L'encapsulation consiste \u00e0 \u00ab enfermer \u00bb certains attributs et certaines m\u00e9thodes \u00e0 l'int\u00e9rieur d'un objet pour qu'ils ne soient pas accessibles directement depuis \u00ab l'ext\u00e9rieur \u00bb de cet objet. </p> <p>Les attributs et m\u00e9thodes qui ne sont pas accessibles depuis l'ext\u00e9rieur de l'objet sont des attributs et m\u00e9thodes priv\u00e9s. Ceux qui restent accessibles sont des attributs et m\u00e9thodes publics.</p> <p>En Python, un simple blanc soulign\u00e9, ou tiret bas, au d\u00e9but d'un nom d'attribut indique que cet attribut est priv\u00e9, par exemple dans notre exemple <code>self._km</code>.</p> <pre><code>class Voiture:\n    total_voiture = 0\n    total_km = 0\n\n    def __init__(self,ma, mo, k=0):\n        self.marque = ma\n        self.modele = mo\n        self._km = k\n        Voiture.total_voiture += 1\n        Voiture.total_km += k\n\n    def roule(self, k):\n        self._km = self._km + k\n        Voiture.total_km += k\n    ...\n</code></pre> <p>Pour respecter le principe de l'encapsulation, il faut \u00e9viter de lire ou \u00e9crire la valeur de l'attribut <code>_km</code> d'une instance de <code>Voiture</code> directement depuis \u00ab l\u2019ext\u00e9rieur \u00bb de l'objet. </p> <p>Cours</p> <p>Une classe doit fournir des m\u00e9thodes (publiques) qui font l'interface avec l'ext\u00e9rieur :</p> <ul> <li>accesseurs (ou getters par convention leur nom commence par get) les m\u00e9thodes permettant d'obtenir la valeur d'un attribut, et</li> <li>mutateurs (ou setters, par convention leur nom commence par set) pour en modifier la valeur.</li> </ul> <pre><code>class Voiture:\n    total_voiture = 0\n    total_km = 0\n\n    def __init__(self, ma, mo, k=0):\n        self.marque = ma\n        self.modele = mo\n        self._km = k\n        Voiture.total_voiture += 1\n        Voiture.total_km += k\n\n    def get_km(self):\n        return self._km\n\n    def set_km(self, k):\n        Voiture.total_km -= self._km        # on soustrait l'ancienne valeur de km\n        self._km = k\n        Voiture.total_km += k               # on rajoute la nouvelle valeur\n\n    def roule(self, k):\n        self._km = self._km + k\n        Voiture.total_km += k\n</code></pre> <p>Noter que ce simple blanc soulign\u00e9, ou tiret bas, au d\u00e9but du nom de l'attribut n'est qu'une convention d'\u00e9criture entre programmeurs, elle n'est pas prise en compte par l'interpr\u00e9teur et il est toujours possible de le lire et de le modifier directement sans passer par son mutateur. </p> <pre><code>&gt;&gt;&gt; voiture_1 = Voiture('Citroen', '2 CV', 152000)\n&gt;&gt;&gt; voiture_1._km\n152000\n&gt;&gt;&gt; voiture_1._km = 160000\n&gt;&gt;&gt; voiture_1._km\n160000\n</code></pre> <p>Le probl\u00e8me persiste !</p> <p>Pour aller plus loin, certains programmeurs utilisent aussi un double blanc soulign\u00e9 au d\u00e9but d'un nom d'attribut priv\u00e9.  </p> <pre><code>class Voiture:\n    def __init__(self, ma, mo, k=0):\n        #...\n        self.__km = k\n        #...\n</code></pre> <p>Dans ce cas, l'attribut <code>__km</code> ne peut plus \u00eatre lu par <code>``voiture_1.__km</code> : <pre><code>&gt;&gt;&gt; voiture_1 = Voiture('Citroen', '2 CV', 152000)\n&gt;&gt;&gt; voiture_1.__km\nTraceback (most recent call last):\n  File \"&lt;interactive input&gt;\", line 1, in &lt;module&gt;\nAttributeError: 'Voiture' object has no attribute '__km'\n</code></pre> mais il peut encore \u00eatre modifi\u00e9 avec des effets ind\u00e9sirables :</p> <pre><code>&gt;&gt;&gt; voiture_1.__km = 160000\n&gt;&gt;&gt; voiture_1.__km\n160000\n&gt;&gt;&gt; voiture_1.get_km()\n152000\n</code></pre> <p>Le probl\u00e8me persiste, cette utilisation est contest\u00e9e<sup>1</sup>.</p> <p>Pour aller encore plus loin (hors programme) une autre mani\u00e8re \u00ab Pythonesque \u00bb de respecter le principe d'encapsulation est d'utiliser des d\u00e9corateurs pour transformer les attributs en propri\u00e9t\u00e9s (hors programme)<sup>2</sup> .</p>"},{"location":"structures-de-donnees/1-poo/#heritage-et-polymorphisme-hors-programme","title":"H\u00e9ritage et polymorphisme (hors programme)","text":"<p>Cours</p> <p>L'h\u00e9ritage consiste \u00e0 cr\u00e9er une nouvelle classe (la classe fille) \u00e0 partir d'une classe existante (super classe ou classe m\u00e8re).</p> <p>Cela permet de d\u00e9finir de nouveaux attributs et de nouvelles m\u00e9thodes pour la classe fille, qui s'ajoutent \u00e0 ceux et celles h\u00e9rit\u00e9es de la classe m\u00e8re sans avoir \u00e0 les r\u00e9\u00e9crire.</p> <p>Admettons que l'on veuille cr\u00e9er une classe de voiture \u00e9lectrique qui a les propri\u00e9t\u00e9s de la classe <code>Voiture</code> plus un certain nombre de kWh pour 100 kilom\u00e8tres.</p> <p>La d\u00e9finition de la classe fille mentionne la m\u00e8re. La m\u00e9thode <code>__init__</code> appelle le constructeur de la m\u00e8re et permet d'ajouter des attributs. On pourrait aussi ajouter des m\u00e9thodes propres \u00e0 la classe fille.</p> <pre><code>class VoitureElectrique(Voiture):\n\n    def __init__(self, ma, mo, k=0, kwh=0):\n        Voiture.__init__(self, ma, mo, k)     # ou super().__init__()\n        self.kwh = kwh\n</code></pre> <p>Noter la syntaxe <code>class VoitureElectrique(Voiture)</code> qui indique le lien m\u00e8re-fille entre les classe <code>Voiture</code> et <code>VoitureElectrique</code>. Cr\u00e9ons maintenant une instance de <code>VoitureElectrique</code> : </p> <pre><code>&gt;&gt;&gt; voiture_3 = VoitureElectrique('TESLA', 'S', kwh=18)\n</code></pre> <p>Toutes les m\u00e9thodes de la classe m\u00e8re s'appliquent \u00e0 la fille :</p> <pre><code>&gt;&gt;&gt; voiture_3.roule(1000)\n&gt;&gt;&gt; voiture_3.get_km()\n1000\n</code></pre> <p>Cours</p> <p>Le polymorphisme permet de modifier le comportement d'une classe fille par rapport \u00e0 sa classe m\u00e8re.</p> <p>Cela permet d'adapter le comportement des objets. Par exemple, cr\u00e9ons une classe fille pour des voitures qui ne roulent plus, appel\u00e9e <code>Epave</code> et modifions la m\u00e9thode <code>roule()</code> de cette classe : </p> <pre><code>class Epave(Voiture):\n\n     # inutile de red\u00e9finir __init__ on utilise le constructeur de la classe m\u00e8re\n\n    def roule(self, k):\n        pass\n</code></pre> <p>La m\u00e9thode <code>roule()</code> d'une instance d'<code>Epave</code> n'est plus h\u00e9rit\u00e9e de celle de la classe m\u00e8re <code>Voiture</code>, elle se comporte diff\u00e9remment :</p> <pre><code>&gt;&gt;&gt; voiture_4 = Epave('Trabant','601', 150000)\n&gt;&gt;&gt; voiture_4.roule(10000)\n&gt;&gt;&gt; voiture_4.get_km()\n150000\n&gt;&gt;&gt;\n</code></pre> <ol> <li> <p>R\u00e8gle du \u00ab name mangling \u00bb :  Voir PEP 8 \u00ab Generally, double leading underscores should be used only to avoid name conflicts with attributes in classes designed to be subclassed. Note: there is some controversy about the use of __names (see below). \u00bb\u00a0\u21a9</p> </li> <li> <p>Une classe Voiture en utilisant des d\u00e9corateurs Python :     <pre><code>class Voiture:\n\n    total_voiture = 0\n    total_km = 0\n\n    def __init__(self, ma, mo, k=0):\n        self.marque = ma\n        self.modele = mo\n        self._km = k\n        Voiture.total_voiture += 1\n        Voiture.total_km += k\n\n    # propri\u00e9t\u00e9 km. Permet d'utiliser nom_objet.km\n    @property     \n    def km(self):\n        return self._km \n\n    # setter de l'attribut km. Pour utiliser nom_objet.km = \u2026.\n    @km.setter         \n    def km(self, k):\n        Voiture.total_km -= self._km \n        self._km = k\n        Voiture.total_km += k\n\n    def roule(self, k):\n        self._km=self._km + k\n        Voiture.total_km += k\n\nvoiture_1 = Voiture('Citroen','2 CV')\nvoiture_1.km = 152000\n</code></pre> \u21a9</p> </li> </ol>"},{"location":"structures-de-donnees/2-structures-interface-implementation/","title":"Structures de donn\u00e9es, interface et impl\u00e9mentation","text":"<p>Cours</p> <p>Une structure de donn\u00e9es ou type abstrait de donn\u00e9es (TAD ) est un ensemble de donn\u00e9es organis\u00e9es et d'op\u00e9rations sur ces donn\u00e9es.</p> <p>On parle de type abstrait car c'est une  \"vue de l'esprit\" permettant la manipulation de ces donn\u00e9es par un algorithme sans rentrer dans les d\u00e9tails d'impl\u00e9mentation.  </p> <p>Par exemples, les entiers relatifs avec les op\u00e9rations: +, *, /, etc. ou les bool\u00e9ens avec AND, OR et NOT constituent des structures de donn\u00e9es bien connues.</p> <p>Cours</p> <p>L'interface d'une structure de donn\u00e9es est l'ensemble des op\u00e9rateurs n\u00e9cessaires \u00e0 la manipulation de cette structure. </p> <p>L'utilisateur d'une structure de donn\u00e9es n'a besoin de conna\u00eetre que son interface, comme la partie visible d'un iceberg. L'interface le renseigne sur toutes les op\u00e9rations possibles sur cette structure de donn\u00e9es, sans en conna\u00eetre l'ensemble du fonctionnement interne qui lui est cach\u00e9, comme la partie immerg\u00e9e de cet iceberg.</p> <p></p> <p>Cours</p> <p>L'interface d'une structure de donn\u00e9es comporte un ensemble de fonctions de bases (appel\u00e9es primitives), les principales permettant de cr\u00e9er (Create), lire (Read), \u00e9crire (Update) ou supprimer (Delete) (CRUD en abr\u00e9g\u00e9) des donn\u00e9es. </p> <p>Pour une m\u00eame interface, il peut y avoir diverses impl\u00e9mentations de la m\u00eame structure de donn\u00e9es, qui d\u00e9pendent par exemple de contraintes du langage de programmation utilis\u00e9 ou de choix de programmation. </p> <p>Cours</p> <p>L'impl\u00e9mentation d'une  structure de donn\u00e9es consiste \u00e0 la \"traduire\" dans un langage informatique. </p> <p>Toutes les structures de donn\u00e9es ne sont pas toutes impl\u00e9ment\u00e9es dans tous les langages informatiques et il faut parfois les programmer pour les utiliser.</p>"},{"location":"structures-de-donnees/3-listes/","title":"Structures lin\u00e9aires : Listes","text":"<p>Cours</p> <p>Une liste<sup>1</sup> est une structure abstraite de donn\u00e9es constitu\u00e9e d'\u00e9l\u00e9ments d'un m\u00eame type, chacun poss\u00e9dant une position (ou rang) dans la liste. </p> <p>La composition d'une liste change quand de nouveaux \u00e9l\u00e9ments sont ajout\u00e9s \u00e0 la liste ou des \u00e9l\u00e9ments sont supprim\u00e9s de la liste. Une liste peut \u00e9ventuellement \u00eatre vide.  </p> <p>Une liste (non vide) est compos\u00e9e de deux parties :</p> <ul> <li>La t\u00eate (not\u00e9e car<sup>2</sup>), qui est le dernier \u00e9l\u00e9ment ajout\u00e9 \u00e0 la liste ;</li> <li>La queue (note cdr<sup>3</sup> ), qui contient le reste de la liste, elle-m\u00eame une liste.</li> </ul> <p>La longueur de la liste est le nombre d'\u00e9l\u00e9ments composant la liste. Une liste vide a une longueur z\u00e9ro.</p> <p>Notons ici le caract\u00e8re r\u00e9cursif de cette d\u00e9finition o\u00f9 la queue d'une liste est elle-m\u00eame une liste ! </p>"},{"location":"structures-de-donnees/3-listes/#interface","title":"Interface","text":"<p>Les principales primitives constituant l'interface d'une liste sont :</p> <ul> <li><code>creer() \u2192 liste</code> : construire une liste vide.</li> <li><code>est_vide() \u2192 bool</code> : v\u00e9rifier si une liste est vide ou non.</li> <li><code>inserer_tete(element)</code> : ins\u00e9rer un \u00e9l\u00e9ment en t\u00eate de la la liste.</li> <li><code>supprimer_tete() \u2192  element</code> : supprimer l'\u00e9l\u00e9ment de t\u00eate.</li> <li><code>taille() \u2192 int</code> : renvoyer le nombre d'\u00e9l\u00e9ments de la liste.</li> <li><code>tete() \u2192  element</code> : lire le premier \u00e9l\u00e9ment (la t\u00eate) de la liste.</li> <li><code>queue() \u2192 liste</code> : acc\u00e9der au reste de la liste (la queue).</li> </ul> <p>Il est possible d'ajouter quelques primitives suppl\u00e9mentaires, par exemple :</p> <ul> <li><code>ins\u00e9rer(element, i)</code> : ins\u00e9rer un \u00e9l\u00e9ment en i\u00e8me position de la liste.</li> <li><code>lire(i) \u2192 element</code> : acc\u00e9der au i\u00e8me \u00e9l\u00e9ment de la liste (get).</li> </ul>"},{"location":"structures-de-donnees/3-listes/#implementation","title":"Impl\u00e9mentation","text":"<p>La liste est un type abstrait, son impl\u00e9mentation peut se faire sous diff\u00e9rentes formes, en particulier les tableaux et les listes cha\u00een\u00e9es.</p> <p> Attention \u00e0 ne pas confondre type abstrait de donn\u00e9es liste avec le type <code>list</code> de Python. Le type <code>list</code> Python est en r\u00e9alit\u00e9 un tableau dynamique, ce n'est qu'une forme d'impl\u00e9mentation particuli\u00e8re de la structure de donn\u00e9es abstraite liste mais ce n'est pas la seule.</p>"},{"location":"structures-de-donnees/3-listes/#recursive-avec-des-tuples-imbriques","title":"R\u00e9cursive avec des tuples imbriqu\u00e9s","text":"<p>Une liste peut \u00eatre impl\u00e9ment\u00e9e sous la forme :</p> <ul> <li>d'un tuple vide <code>()</code>, si la liste est vide ; ou sinon</li> <li>d'un couple compos\u00e9 de la t\u00eate de la liste et de sa queue : <code>(car, cdr)</code>.</li> </ul> <p>Prenons par exemple une liste vide impl\u00e9ment\u00e9e par le tuple <code>()</code>, et ins\u00e9rons l'\u00e9l\u00e9ment <code>'a'</code> en t\u00eate, la nouvelle liste obtenue est <code>('a', ())</code>, sa t\u00eate est <code>'a'</code> et sa queue <code>()</code>. Ins\u00e9rons maintenant un \u00e9l\u00e9ment <code>'b'</code> dans cette liste, la nouvelle liste obtenue est <code>('b', ('a', ()))</code>, sa t\u00eate est <code>'b'</code> et sa queue <code>('a', ())</code>. Puis ins\u00e9rons successivement les \u00e9l\u00e9ments <code>'c'</code> et <code>'d'</code>, la nouvelle liste  est <code>('d', ('d', ('b', ('a', ()))))</code>, la t\u00eate est <code>'d'</code> et la queue <code>('d', ('b', ('a', ())))</code>.</p> <p>Ecrivons en Python ces premi\u00e8res primitives de liste qui permettent de cr\u00e9er une liste vide puis d'ins\u00e9rer un \u00e9l\u00e9ment en t\u00eate de liste :</p> <pre><code>def creer():\n    return ()  # renvoie une tuple vide\n\ndef est_vide(L):\n    return L == ()\n\ndef inserer_tete(L, e):\n    return (e, L)\n\nma_liste = creer()\nma_liste = inserer_tete(ma_liste, 'a')\nma_liste = inserer_tete(ma_liste, 'b')\nma_liste = inserer_tete(ma_liste, 'c')\nma_liste = inserer_tete(ma_liste, 'd')\n</code></pre> <p>Ajoutons quelques primitives suppl\u00e9mentaires :</p> <pre><code>def tete(L):\n    return L[0]\n\ndef queue(L):\n    return L[1]\n</code></pre> <p>La taille de la liste est calcul\u00e9e de fa\u00e7on r\u00e9cursive :</p> <pre><code>def taille(L):\n    if est_vide(L):\n        return 0\n    else:\n        return 1 + taille(queue(L))\n</code></pre> <p>L'affichage est aussi r\u00e9cursif :</p> <pre><code>def afficher(L):\n    if est_vide(L):\n        print('')     \n    else:\n        print(tete(L), end=' - ' ) \n        afficher(queue(L))\n</code></pre> <p>ainsi que la recherche d'un \u00e9l\u00e9ment dans la liste :</p> <pre><code>def chercher(L, elem):\n    if est_vide(L):\n        return False \n    elif tete(L) == elem:\n        return True \n    else:\n        return chercher(queue(L) , elem) \n</code></pre>"},{"location":"structures-de-donnees/3-listes/#avec-un-tableau-de-taille-fixe","title":"Avec un tableau de taille fixe","text":"<p>Un tableau en informatique est en g\u00e9n\u00e9ral repr\u00e9sent\u00e9 par une suite de \"cases m\u00e9moire\", toutes de m\u00eames tailles, contenant les diff\u00e9rents \u00e9l\u00e9ments du tableau.  Une plage d'adresses m\u00e9moire est r\u00e9serv\u00e9e afin de stocker tous les \u00e9l\u00e9ments.</p> <p> </p> <p>Cette repr\u00e9sentation pr\u00e9sente deux avantages :</p> <ul> <li> <p>pour un tableau sans case vide, elle est tr\u00e8s compacte, puisqu'elle se contente de stocker les donn\u00e9es ;</p> </li> <li> <p>l'acc\u00e8s un \u00e9l\u00e9ment du tableau par son \\(indice\\) s'effectue relativement rapidement en temps constant. Son  adresse se calcule facilement:     \\(adresseElement = adresseTableau + indice \\times  tailleCase\\)</p> </li> </ul> <p>Impl\u00e9mentons en Python une liste sous forme d'un tableau de taille fixe \\(n + 1\\) en utilisant une variable de type <code>list</code> :</p> <ul> <li>la premi\u00e8re case du tableau contient le nombre d'\u00e9l\u00e9ments de la liste ;</li> <li>les cases suivantes (d'indice <code>1</code> \u00e0 <code>n</code>) contiennent les \u00e9l\u00e9ments de la liste ou <code>None</code>.</li> </ul> <p>Exemple : une liste de taille 5 avec les \u00e9l\u00e9ments <code>'c'</code>, <code>'b'</code>, <code>'a'</code>  se pr\u00e9sentera sous la forme  <code>[3, 'c', 'b', 'a', None, None]</code>.</p> <p>Cr\u00e9ons l'interface d'une telle liste :</p> <pre><code>def creer_liste(longueur):\n    L = [None] * (longueur + 1)\n    L[0] = 0\n    return L\n</code></pre> <p>La primitive pour ins\u00e9rer un \u00e9l\u00e9ment en t\u00eate de liste est alors :</p> <pre><code>def inserer_tete(L, elem):\n    # verifions si la liste est pleine\n    if L[0] == len(L) - 1: raise IndexError('La liste est d\u00e9j\u00e0 pleine')\n    else:\n        for i in range(L[0], 0, -1):\n            L[i+1]= L[i]\n        L[1] = elem\n        L[0] += 1\n</code></pre> <p>A noter qu'il est inutile de renvoyer la valeur de <code>L</code> car c'est une variable de type <code>list</code>, donc muable.</p> <pre><code>inserer_tete(L, 'a')\ninserer_tete(L, 'b')\ninserer_tete(L, 'c')\n</code></pre> <p>Une fonction pour afficher la liste s'\u00e9crit :</p> <pre><code>def afficher(L):\n    for i in range(1, L[0] + 1):\n        print(L[i], end = \"-\")\n    print(\"\")\n</code></pre> <p>Ajoutons une primitive permettant de supprimer la t\u00eate de la liste :</p> <pre><code>def supprimer_tete(L):\n    # v\u00e9rifions d'abord que la liste n'est pas vide\n    if L[0] == 0: raise IndexError('La liste est d\u00e9j\u00e0 vide')\n    else:\n        for i in range(1, L[0] ):\n            L[i]= L[i+1]\n        L[L[0]] = None\n        L[0] -= 1\n</code></pre> <p>Testons le r\u00e9sultat :</p> <pre><code>L = creer_liste(5)\ninserer_tete(L, 'a')\ninserer_tete(L, 'b')\ninserer_tete(L, 'c')\ninserer_tete(L, 'd')\ninserer_tete(L, 'e')\nafficher(L)\nsupprimer_tete(L)\nsupprimer_tete(L)\nsupprimer_tete(L)\nafficher(L)\n</code></pre> <p>Il est aussi possible de rajouter quelques primitives pour :</p> <ul> <li>acc\u00e9der au i-\u00e8me \u00e9l\u00e9ment de la liste (get) ; </li> <li>ins\u00e9rer un \u00e9l\u00e9ment en t\u00eate d'une liste ;</li> <li>ins\u00e9rer un \u00e9l\u00e9ment en i-\u00e8me position ;</li> <li>etc.</li> </ul> <p>Pour aller plus loin, il est aussi possible d'\u00e9crire une classe <code>Liste</code> avec des m\u00e9thodes similaire.</p>"},{"location":"structures-de-donnees/3-listes/#avec-le-type-list-de-python","title":"Avec le type <code>list</code> de Python","text":"<p>Dans de nombreux langages informatiques, un tableau est une structure de donn\u00e9es de taille fixe<sup>4</sup>. Pour ins\u00e9rer des donn\u00e9es suppl\u00e9mentaires, il faut cr\u00e9er un nouveau tableau plus grand et d\u00e9placer les \u00e9l\u00e9ments du premier tableau vers le second tout en ajoutant la donn\u00e9e au bon endroit.  C'est la notion de tableau dynamique, c'est \u00e0 dire un tableau dont la taille peut varier. </p> <p>Cours</p> <p>En Python le type <code>list</code> est un tableau dynamique. C'est une forme d'impl\u00e9mentation particuli\u00e8re de la structure de donn\u00e9es abstraite de liste (mais ce n'est pas la seule).  Attention de ne pas confondre les deux termes.</p> <p>Le type <code>list</code> en Python offre toutes les primitives de base d'une liste :</p> <pre><code>&gt;&gt;&gt; L = []       # creer une liste \n&gt;&gt;&gt; L == []       # est_vide()\nTrue\n&gt;&gt;&gt; L.insert(0, 'a')         # inserer_tete()\n&gt;&gt;&gt; L.insert(0, 'b')         # inserer_tete()\n&gt;&gt;&gt; L.insert(0, 'c')         # inserer_tete()\n&gt;&gt;&gt; L.insert(0, 'd')         # inserer_tete()\n&gt;&gt;&gt; L.insert(0, 'e')         # inserer_tete()\n&gt;&gt;&gt; len(L)       # taille()\n5\n&gt;&gt;&gt; L.pop(0)       # supprimer_tete()\n'e'\n&gt;&gt;&gt; L[0]       # tete()\n'd'\n&gt;&gt;&gt; L[1:]       # queue()\n['c', 'b', 'a']\n</code></pre> <p>Notons qu'ici la t\u00eate est \u00e0 la premi\u00e8re position de <code>L</code>. </p> <p>Le type <code>list</code> propose bien d'autres op\u00e9rateurs que les listes : extraction d'une sous-liste (<code>L[debut:fin]</code>), remplacement d'un \u00e9l\u00e9ment (<code>L[i] = nouvelle_valeur</code>), tri (<code>L.sort()</code>), retournement (<code>L.reverse()</code>), suppression d'un \u00e9l\u00e9ment (<code>L.pop(i)</code>), application d'une fonction (<code>map(fonction, L</code>), etc. N\u00e9anmoins, s'il peut sembler la solution miracle \u00e0 de nombreux besoins, les tableaux dynamiques ne sont pas efficaces pour ins\u00e9rer ou supprimer un \u00e9l\u00e9ment en plein milieu du tableau.</p> <p> </p> <p>Par exemple, lorsqu'une nouvelle valeur <code>'e'</code> est ins\u00e9r\u00e9e en t\u00eate d'une liste <code>['d', 'c', 'b', 'a']</code>, c'est-\u00e0-dire \u00e0 la premi\u00e8re position de ce tableau Python, avec la m\u00e9thode <code>insert()</code> :</p> <pre><code>&gt;&gt;&gt; L\n['d', 'c', 'b', 'a']\n&gt;&gt;&gt; L.insert(0, 'e')\n&gt;&gt;&gt; L\n['e', 'd', 'c', 'b', 'a']\n</code></pre> <p>c'est une op\u00e9ration qui est en r\u00e9alit\u00e9 tr\u00e8s couteuse, car elle consiste \u00e0 :</p> <ol> <li>agrandir le tableau ; </li> <li>d\u00e9placer tous les \u00e9l\u00e9ments du tableau d'une case vers la droite, en commen\u00e7ant par la fin ; </li> <li>et enfin \u00e9crire la valeur <code>'e'</code> dans la premi\u00e8re case.</li> </ol> <p>C'est donc la m\u00eame chose que d'\u00e9crire :</p> <pre><code>&gt;&gt;&gt; L = ['d, 'c', 'b', 'a']\n&gt;&gt;&gt; L.append(None)\n&gt;&gt;&gt; for i in range(len(L) -1, 0, -1):\n...     L[i] = L[i-1]\n&gt;&gt;&gt; L[0] = 'e'\n&gt;&gt;&gt; t\n['e', 'd', 'b', 'c', 'a']\n</code></pre> <p>Le nombre d'op\u00e9rations est proportionnel \u00e0 la taille du tableau. Ajouter ou supprimer le premier \u00e9l\u00e9ment d'un tableau d'un million d'\u00e9l\u00e9ments n\u00e9cessite pr\u00e8s d'un million d'op\u00e9rations. C'est une complexit\u00e9 en \\(O(n)\\) <sup>5</sup>.</p> <p>Le choix d'impl\u00e9mentation qui a \u00e9t\u00e9 fait ici de placer la t\u00eate de liste en position 0 d'un tableau Python suis les impl\u00e9mentations pr\u00e9c\u00e9dentes, il aurait \u00e9t\u00e9 judicieux d'inverser l'ordre de la liste dans le tableau et d'utiliser <code>L.append('a')</code> et <code>L.pop()</code> pour <code>inserer_tete</code> et <code>supprimer_tete</code>.</p>"},{"location":"structures-de-donnees/3-listes/#avec-une-liste-chainee","title":"Avec une liste cha\u00een\u00e9e","text":"<p>La liste chain\u00e9e apporte une solution au probl\u00e8me de co\u00fbt d'insertion et suppression d'\u00e9l\u00e9ments des tableaux dynamiques.  Elle servira aussi de brique de base aux structures de donn\u00e9es de piles et de files \u00e9tudi\u00e9es dans la suite de ce chapitre.</p> <p>Dans une liste cha\u00een\u00e9e, chaque \u00e9l\u00e9ment de la liste est stock\u00e9 dans une cellule contenant :</p> <ul> <li>l'\u00e9l\u00e9ment ;</li> <li>un pointeur (ou r\u00e9f\u00e9rence) sur la cellule suivante ;</li> <li>\u00e9ventuellement (pour les listes doublement cha\u00een\u00e9es), un pointeur sur la cellule pr\u00e9c\u00e9dente.</li> </ul> <p>Voil\u00e0 ce que \u00e7a donne pour repr\u00e9senter la liste <code>'c'</code>, <code>'b'</code>, <code>'a'</code> :</p> <p> </p> <p>L'usage d'une liste cha\u00een\u00e9e est souvent pr\u00e9conis\u00e9 pour des raisons de rapidit\u00e9 de traitement, lorsque les insertions et les suppressions d'\u00e9l\u00e9ments quelconques sont plus fr\u00e9quentes que les acc\u00e8s. En effet, les insertions et les suppressions se font en temps constant car elles ne demandent au maximum que deux \u00e9critures. </p> <p>Voici par exemple comment ins\u00e9rer l'\u00e9l\u00e9ment <code>'z'</code> entre les \u00e9l\u00e9ments <code>'c'</code> et <code>'b'</code> :</p> <p> </p> <p>En revanche, la liste cha\u00een\u00e9e pr\u00e9sente deux inconv\u00e9nients :</p> <ul> <li> <p>elle prend beaucoup de place, puisqu'il faut rajouter un pointeur pour chaque \u00e9l\u00e9ment ;</p> </li> <li> <p>l'acc\u00e8s \u00e0 un \u00e9l\u00e9ment est relativement long et est proportionnel \u00e0 l'indice de l'\u00e9l\u00e9ment, puisqu'il faut parcourir la liste depuis le d\u00e9but (ou la fin) pour atteindre l'\u00e9l\u00e9ment voulu.</p> </li> </ul> <p>Impl\u00e9mentons une telle liste cha\u00een\u00e9e en programmation orient\u00e9e objet.</p> <p>Commen\u00e7ons par la classe d'objets <code>Cellule</code> dont les instances ont deux attributs <code>valeur</code> et <code>suivante</code>. <code>suivante</code> pointe sur la cellule suivante d'une cellule ou sur <code>None</code> pour la derni\u00e8re cellule de la liste cha\u00een\u00e9e.</p> <pre><code>class Cellule:\n    ''' une cellule de liste chain\u00e9e\n    '''\n\n    def __init__(self, v, s):\n        self.valeur = v\n        self.suivante = s\u2003\n</code></pre> <p>Il est d\u00e9j\u00e0 possible de construire la liste <code>'c'</code>, <code>'b'</code>, <code>'a'</code> :</p> <pre><code>lst = Cellule('c', Cellule('b', Cellule('a', None)))\n\n&gt;&gt;&gt; lst\n&lt;__main__.Cellule object at 0x03633BE0&gt;\n</code></pre> <p> </p> <p>Ajoutons une m\u00e9thode pour afficher la valeur d'une cellule en utilisant <code>__str__()</code> qui renvoie une chaine de caract\u00e8re permettant d'afficher un objet avec la fonction <code>print()</code>. </p> <pre><code>    def __str__(self):\n        return 'valeur:' + self.valeur\n</code></pre> <p>Cr\u00e9ons maintenant la classe <code>ListeChainee</code> pour repr\u00e9senter une liste cha\u00een\u00e9e par :</p> <ul> <li><code>None</code> si la liste est vide ; ou </li> <li>une instance de <code>Cellule</code> qui contient la t\u00eate avec un attribut <code>suivant</code> qui pointe vers une autre liste, la queue.</li> </ul> <p>On retrouve la d\u00e9fintion r\u00e9cursive d'une liste.</p> <pre><code>class ListeChainee:\n    ''' liste chain\u00e9e    '''\n    def __init__(self):\n        self.tete = None\n</code></pre> <p> </p> <p>et une premi\u00e8re instance de liste chain\u00e9e vide :</p> <pre><code>lst = ListeChainee()\n</code></pre> <p>Ajoutons imm\u00e9diatement la premi\u00e8re primitive qui v\u00e9rifie si une liste est vide ou non :</p> <pre><code>    def est_vide(self):\n        if self.tete is None: return True                   \n        else: return False\n</code></pre> <p>Maintenant ajoutons une primitive pour ins\u00e9rer une <code>Cellule</code> en t\u00eate de liste :</p> <pre><code>    def inserer_tete(self, v):\n        self.tete= Cellule(v, self.tete)\n</code></pre> <p>Comme attendu, la liste n'est plus vide : </p> <pre><code>&gt;&gt;&gt; lst = ListeChainee()\n&gt;&gt;&gt; lst.inserer_tete('a')\n&gt;&gt;&gt; lst.est_vide()\nFalse\n</code></pre> <p>Ajoutons les deux autres \u00e9l\u00e9ments \u00e0 cette liste :</p> <pre><code>&gt;&gt;&gt; lst.inserer_tete('b')\n&gt;&gt;&gt; lst.inserer_tete('c')\n</code></pre> <p>La longueur de la liste peut constituer un attribut priv\u00e9 de la classe avec un accesseur pour l'obtenir :</p> <pre><code>class ListeChainee:\n    ''' liste chainee     '''\n    def __init__(self):\n        self.tete = None\n        self._longueur = 0\n\n    def longueur(self):\n        return self._longueur\n</code></pre> <p>Affichons la t\u00eate de liste :</p> <pre><code>&gt;&gt;&gt; print(lst.tete)\nvaleur:c\n</code></pre> <p>Une primitive <code>get</code> permet de lire l'\u00e9l\u00e9ment en position <code>n</code> :</p> <pre><code>    def get(self, n):\n        cellule = self.tete\n        for i in range(n):\n            cellule = cellule.suivante\n        return cellule\n</code></pre> <p>En moyenne, s'il est imm\u00e9diat de trouver l'\u00e9l\u00e9ment de t\u00eate, il faut \\(n\\) op\u00e9rations pour trouver le dernier \u00e9l\u00e9ment dans une liste de longueur \\(n\\), donc en moyenne \\(n/2\\), la complexit\u00e9 est en \\(O(n)\\) ce qui est tr\u00e8s co\u00fbteux en comparaison d'un tableau dynamique.  </p> <p>Ajoutons une assertion sur la valeur de <code>n</code> dans le cas o\u00f9 <code>n</code> est sup\u00e9rieur \u00e0 <code>_longueur</code>  : <pre><code>        assert n &lt; self._longueur, \"n doit \u00eatre inf\u00e9rieur \u00e0 la taille de la liste\"\n</code></pre> Ou alors la primitive peut renvoyer un code erreur, <code>-1</code> par exmple :</p> <pre><code>        if n &gt;= self._longueur: return -1\n</code></pre> <p>La m\u00e9thode <code>__str__()</code> permet d'afficher toute la liste avec <code>print()</code> en parcourant toute la liste :</p> <pre><code>    def __str__(self):\n        affiche = ''\n        cellule = self.tete\n        for i in range(self._longueur):\n            affiche += cellule.valeur + ';'\n            cellule = cellule.suivante\n        return affiche\n\nprint (lst)\n</code></pre> <p>Compl\u00e9tons l'interface avec une primitive pour ajouter un \u00e9l\u00e9ment en position <code>n</code>, (comme l'\u00e9l\u00e9ment <code>'z'</code> entre <code>'c'</code> et <code>'b'</code> dans l'exemple ci-dessus) :</p> <pre><code>    def inserer(self, v, n):\n        if n &gt; self._longueur: return -1\n        if n == 0: self.tete = Cellule(v,self.tete)\n        else:\n            old = self.get_element(n - 1)\n            new = Cellule(v, old.suivante)\n            old.suivante = new\n        self._longueur += 1\n</code></pre> <p>En moyenne, comme pour la recherche , un \u00e9l\u00e9ment est ajout\u00e9 imm\u00e9diatement en t\u00eate de liste, et apr\u00e8s \\(n\\) op\u00e9rations en derni\u00e8re position dans une liste de longueur \\(n\\), donc en moyenne apr\u00e8s \\(n/2\\) op\u00e9rations. La complexit\u00e9 est en \\(O(n)\\) est comparable au tableau dynamique, mais le nombre d'\u00e9critures est grandement r\u00e9duit.</p> <p>Pour aller plus loin,  il est possible de d\u00e9finir une m\u00e9thode pour supprimer l'\u00e9l\u00e9ment en position <code>n</code>, v\u00e9rifier la pr\u00e9sence d'une valeur dans la liste, trier une liste, concat\u00e9ner deux listes, etc.</p> <p>Noter que cette impl\u00e9mentation permet de cr\u00e9er une liste muable (mutable en anglais) ce qui permet par exemple d'ins\u00e9rer un \u00e9l\u00e9ment en t\u00eate de liste ou m\u00eame au milieu.</p> <ol> <li> <p>Le langage de programmation Lisp (invent\u00e9 par John McCarthy en 1958) a \u00e9t\u00e9 un des premiers langages de programmation \u00e0 introduire cette notion de liste (Lisp signifie \"list processing\").\u00a0\u21a9</p> </li> <li> <p>contents of address register \u21a9</p> </li> <li> <p>contents of decrement register \u21a9</p> </li> <li> <p>Par exemple pour d\u00e9clarer un tableau de 4 entiers en C, il faut \u00e9crire <code>int myNumbers[4];</code>.\u00a0\u21a9</p> </li> <li> <p>Le co\u00fbt d'insertion d'un \u00e9l\u00e9ment en d\u00e9but de tableau est proportionnel \u00e0 la taille du tableau, ce qui peut \u00eatre observ\u00e9 avec le module <code>time</code>:  <pre><code>import time\n\nL = [i for i in range (100000)]  \nstart = time.time()\nfor i in range(100):\n    L.insert(0, 0)\nend = time.time()\nprint((end - start) / 1000)\n</code></pre> Pour en savoir plus sur le co\u00fbt des op\u00e9rations sur les listes : https://wiki.python.org/moin/TimeComplexity \u21a9</p> </li> </ol>"},{"location":"structures-de-donnees/4-piles/","title":"Structures lin\u00e9aires : Piles","text":"<p>Cours</p> <p> </p> <p>En informatique, une pile (en anglais stack) est un type abstrait de donn\u00e9es sur le principe \u00ab dernier arriv\u00e9, premier sorti \u00bb (ou LIFO pour Last In, First Out).</p> <p>Le dernier \u00e9l\u00e9ment ajout\u00e9 \u00e0 la pile, ou empil\u00e9, est le premier qui sera sorti, ou d\u00e9pil\u00e9.</p> <p>Le dernier \u00e9l\u00e9ment empil\u00e9 est le sommet de la pile.</p> <p>Le fonctionnement est donc celui d'une pile d'assiettes : on ajoute des assiettes sur la pile, et on les r\u00e9cup\u00e8re dans l'ordre inverse, en commen\u00e7ant par la derni\u00e8re ajout\u00e9e. </p> <p> </p> <p>Les piles trouvent de nombreuses applications en informatique, par exemple :</p> <ul> <li> <p>Dans un navigateur web, une pile sert \u00e0 m\u00e9moriser les pages Web visit\u00e9es. L'adresse de chaque nouvelle page visit\u00e9e est empil\u00e9e et l'utilisateur d\u00e9pile l'adresse de la page pr\u00e9c\u00e9dente en cliquant le bouton \u00ab Afficher la page pr\u00e9c\u00e9dente \u00bb.</p> </li> <li> <p>La fonction \u00ab Annuler la frappe \u00bb (en anglais \u00ab Undo \u00bb) d'un traitement de texte m\u00e9morise les modifications apport\u00e9es au texte dans une pile.</p> </li> </ul>"},{"location":"structures-de-donnees/4-piles/#interface","title":"Interface","text":"<p>Les principales primitives constituant l'interface d'une pile sont :</p> <ul> <li><code>creer() \u2192 pile</code> : construire une pile vide.</li> <li><code>est_vide() \u2192 bool</code> : v\u00e9rifier si une pile est vide ou non.</li> <li><code>empiler(element)</code> : ajouter un \u00e9l\u00e9ment sur la pile (Push en anglais).</li> <li><code>d\u00e9piler() \u2192 element</code> : enl\u00e8ver un \u00e9l\u00e9ment de la pile et le renvoyer (Pop en anglais).</li> <li><code>taille() \u2192 int</code> : renvoyer le nombre d'\u00e9l\u00e9ments dans la pile (la hauteur).</li> </ul> <p>Exemple :</p> <p>Soit une pile <code>P</code> compos\u00e9e des \u00e9l\u00e9ments suivants : 12, 14, 8, 7, 19 et 22 (le sommet de la pile est 22). Pour chaque exemple ci-dessous on repart de la pile d'origine :</p> <ul> <li><code>d\u00e9piler(P)</code> renvoie 22 et la pile <code>P</code> est maintenant compos\u00e9e des \u00e9l\u00e9ments suivants : 12, 14, 8, 7 et 19 (le sommet de <code>P</code> est 19).</li> <li><code>empiler(P, 42)</code> la pile <code>P</code> est maintenant compos\u00e9e des \u00e9l\u00e9ments suivants : 12, 14, 8, 7, 19, 22 et 42</li> <li>si on applique <code>d\u00e9piler(P)</code> 6 fois de suite, <code>est_vide(P)</code> renvoie vrai.</li> <li>apr\u00e8s avoir appliqu\u00e9 <code>d\u00e9piler(P)</code> une fois, <code>taille(P)</code> renvoie 5.</li> </ul>"},{"location":"structures-de-donnees/4-piles/#implementation","title":"Impl\u00e9mentation","text":"<p>La pile est un type abstrait, son impl\u00e9mentation peut se faire sous diff\u00e9rentes formes, par exemple avec une liste cha\u00een\u00e9e ou un tableau dynamique de type <code>list</code> Python.</p>"},{"location":"structures-de-donnees/4-piles/#avec-une-liste-chainee","title":"Avec une liste cha\u00een\u00e9e","text":"<p>Sur la m\u00eame id\u00e9e que la classe <code>ListeChainee</code> vue pr\u00e9c\u00e9demment, il est possible de peut cr\u00e9er une classe <code>Pile</code> de toute pi\u00e8ce bas\u00e9e sur la class <code>Cellule</code>.</p> <pre><code>class Cellule:\n    '''Cellule de Pile '''\n\n    def __init__(self, v, d=None):\n        self.valeur = v      # Valeur de la Cellule\n        self.dessous = d     # Cellule de dessous\n\nclass Pile:\n    '''Pile sous forme d'une liste chainee de cellules'''\n    def __init__(self):\n        self.sommet = None\n        self._hauteur = 0          # Nombre d'\u00e9l\u00e9ment de la Pile\n\n    def est_vide(self):\n        return self.sommet == None\n\n    def empiler(self, v):\n        self.sommet = Cellule(v, self.sommet)\n        self._hauteur += 1\n\n    def depiler(self):\n        if self.est_vide(): raise IndexError(\"la pile est vide\")\n        v = self.sommet.valeur\n        self.sommet = self.sommet.dessous\n        self._hauteur -= 1\n        return v\n\n    def taille(self):\n        return self._hauteur\n</code></pre> <p>Cr\u00e9ons maintenant une instance de <code>Pile</code> : <pre><code>&gt;&gt;&gt; p = Pile()\n&gt;&gt;&gt; p.taille()\n0\n&gt;&gt;&gt; p.empiler('a')\n&gt;&gt;&gt; p.empiler('b')\n&gt;&gt;&gt; p.empiler('c')\n&gt;&gt;&gt; p.depiler()\n'c'\n&gt;&gt;&gt; p.taille()\n2\n</code></pre></p>"},{"location":"structures-de-donnees/4-piles/#avec-le-type-list-de-python","title":"Avec le type <code>list</code> de Python","text":"<p>Il est aussi possible de cr\u00e9er tr\u00e8s facilement une classe <code>Pile</code> en utilisant le type <code>list</code> avec les m\u00e9thodes <code>pop()</code> et <code>append()</code> :</p> <pre><code>class Pile:\n    ''' structure de Pile en utilisant le type list'''\n\n    def __init__(self):\n        self.pile = []\n\n    def est_vide(self):\n        return len(self.pile) == 0\n\n    def empiler(self, v):\n        self.pile.append(v)\n\n    def depiler(self):\n        if self.est_vide(): raise IndexError(\"la pile est vide\")\n        return self.pile.pop()\n\n    def taille(self):\n        return len(self.pile)\n\n    def __str__(self):\n        ch = ''\n        for v in self.pile:\n            ch = ch + \"|\\t\" + str(v) + \"\\t|\\n\"   # Affiche les \u00e9lements de la pile : |  v  |\n        ch = ch + \"---------\"\n        return ch\n</code></pre> <p>Cr\u00e9ons maintenant une instance de <code>Pile</code> :</p> <pre><code>&gt;&gt;&gt; p = Pile()\n&gt;&gt;&gt; p.est_vide()\nTrue\n&gt;&gt;&gt; p.depiler()\nTraceback (most recent call last):\n  File \"&lt;interactive input&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;module1&gt;\", line 15, in depiler\nIndexError: la pile est vide\n&gt;&gt;&gt; p.empiler('a')\n&gt;&gt;&gt; p.empiler('b')\n&gt;&gt;&gt; p.empiler('c')\n&gt;&gt;&gt; p.est_vide()\nFalse\n&gt;&gt;&gt; p.depiler()\n'c''\n&gt;&gt;&gt;\n</code></pre> <p>Enregistons cette classe de <code>Pile</code> dans un fichier \"pile.py\", elle nous sera utile par la suite.</p> <p>Pour faire encore plus simple, programmons une pile avec la m\u00eame id\u00e9e, mais sans utiliser la POO : </p> <p><pre><code>def creer():\n    return  []\n\ndef est_vide(p):\n    return len(p) == 0\n\ndef empiler(p, v):\n    p.append(v)         # Inutile de renvoyer p, le type list est muable\n\ndef depiler(p):\n    if est_vide(p): raise IndexError(\"la pile est vide\")\n    return p.pop()\n\ndef taille(p):\n    return len(p)\n\ndef afficher(p):\n    for v in p:\n        print(\"|\\t\", v, \"\\t|\\n\")   # Affiche les \u00e9lements de la pile : |  v  |\n    print(\"---------\")\n</code></pre> puis</p> <pre><code>&gt;&gt;&gt; p = creer()\n&gt;&gt;&gt; est_vide(p)\nTrue\n&gt;&gt;&gt; depiler(p)\nTraceback (most recent call last):\n  File \"&lt;interactive input&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;module1&gt;\", line 11, in depiler\nIndexError: la pile est vide\n&gt;&gt;&gt; empiler(p, 'a')\n&gt;&gt;&gt; empiler(p, 'b')\n&gt;&gt;&gt; empiler(p, 'c')\n&gt;&gt;&gt; depiler(p)\n'c'\n&gt;&gt;&gt; taille(p)\n2\n</code></pre> <p>Finalement en Python, une simple variable de type <code>list</code> avec la fonction <code>len()</code> et les m\u00e9thodes <code>.append()</code> et <code>.pop()</code> est une fa\u00e7on rapide et simple de cr\u00e9er une pile avec toutes ses primitives :  <pre><code>&gt;&gt;&gt; p = []           # creer()\n&gt;&gt;&gt; len(p) == 0      # est_vide()\nTrue\n&gt;&gt;&gt; p.append('a')    # empiler()\n&gt;&gt;&gt; p.append('b')    # empiler()\n&gt;&gt;&gt; p.append('c')    # empiler()\n&gt;&gt;&gt; len(p)           # taille()\n3\n&gt;&gt;&gt; p.pop()          # depiler()\n'c'\n</code></pre></p>"},{"location":"structures-de-donnees/5-files/","title":"Structures lin\u00e9aires : Files","text":"<p>Cours</p> <p></p> <p></p> <p>En informatique, une file (en anglais queue) est un type abstrait de donn\u00e9es sur le principe \u00ab premier arriv\u00e9, premier sorti \u00bb (ou FIFO pour First In, First Out).</p> <p>Le premier \u00e9l\u00e9ment ajout\u00e9 \u00e0 la file, ou enfil\u00e9, est le premier qui sera sorti, ou d\u00e9fil\u00e9.</p> <p>Le premier \u00e9l\u00e9ment enfil\u00e9 est en sortie de la file, le dernier est en entr\u00e9e.</p> <p>Le fonctionnement est celui d'une file d'attente : les premi\u00e8res personnes qui arrivent dans la file sont ensuite les premi\u00e8res qui en sortiront. </p> <p> </p> <p>Ici aussi, les files trouvent de nombreuses applications en informatique, en g\u00e9n\u00e9ral pour m\u00e9moriser temporairement des transactions qui doivent attendre pour \u00eatre trait\u00e9es, par exemple par les logiciels d'imprimantes qui traitent les demandes dans l'ordre dans lequel elles arrivent en les pla\u00e7ant dans une file d'attente ; ou par l'ordonnanceur d'un syst\u00e8me d'exploitation qui accorde du temps machine \u00e0 chaque processus dans l'ordre o\u00f9 il arrive, sans en privil\u00e9gier aucun.</p>"},{"location":"structures-de-donnees/5-files/#interface","title":"Interface","text":"<p>Les principales primitives constituant l'interface d'une file sont :</p> <ul> <li><code>creer() \u2192 file</code> : construire d'une file vide.</li> <li><code>est_vide() \u2192 bool</code> : v\u00e9rifier si une file est vide ou non.</li> <li><code>enfiler(element)</code> : ajouter un \u00e9l\u00e9ment dans la file (enqueue en anglais).</li> <li><code>d\u00e9filer() \u2192 element</code> : enl\u00e8ver un \u00e9l\u00e9ment de la file et le renvoyer (dequeue en anglais).</li> <li><code>taille() \u2192 int</code> : renvoyer le nombre d'\u00e9l\u00e9ments dans la file.</li> </ul> <p>Exemples :</p> <p>Soit une file <code>F</code> compos\u00e9e des \u00e9l\u00e9ments suivants : 12, 14, 8, 7, 19 et 22 (le premier \u00e9l\u00e9ment rentr\u00e9 dans la file est 22 ; le dernier \u00e9l\u00e9ment rentr\u00e9 dans la file est 12). Regardons chaque exemple ci-dessous en repartant de la file d'origine :</p> <ul> <li> <p><code>enfiler(F,42)</code> la file <code>F</code> est maintenant compos\u00e9e des \u00e9l\u00e9ments suivants : 42, 12, 14, 8, 7, 19 et 22 (le premier \u00e9l\u00e9ment rentr\u00e9 dans la file est 22 ; le dernier \u00e9l\u00e9ment rentr\u00e9 dans la file est 42)</p> </li> <li> <p><code>d\u00e9filer(F)</code> la file <code>F</code> est maintenant compos\u00e9e des \u00e9l\u00e9ments suivants : 12, 14, 8, 7, et 19 (le premier \u00e9l\u00e9ment rentr\u00e9 dans la file est 19 ; le dernier \u00e9l\u00e9ment rentr\u00e9 dans la file est 12)</p> </li> <li> <p>apr\u00e8s <code>d\u00e9filer(F)</code> 6 fois de suite, <code>est_vide(F)</code> renvoie vrai.</p> </li> <li> <p>apr\u00e8s avoir appliqu\u00e9 <code>d\u00e9filer(F)</code> une fois, <code>taille(F)</code> renvoie 5.</p> </li> </ul>"},{"location":"structures-de-donnees/5-files/#implementation","title":"Impl\u00e9mentation","text":""},{"location":"structures-de-donnees/5-files/#avec-le-type-list-de-python","title":"Avec le type <code>list</code> de Python","text":"<p>La liste est un type abstrait, son impl\u00e9mentation peut se faire sous diff\u00e9rentes formes, par exemple en reprenant l'impl\u00e9mentation d'une Pile avec une variable de type <code>list</code> il suffit de modifier <code>pop()</code> en <code>pop(0)</code> pour \u00e9crire la m\u00e9thode <code>defiler()</code>.</p> <pre><code>    def defiler(self):\n        if self.est_vide(): raise IndexError(\"la file est vide\")\n        return self.pile.pop(0)\n</code></pre>"},{"location":"structures-de-donnees/5-files/#avec-deux-piles","title":"Avec deux piles","text":"<p>Voici une autre approche d'impl\u00e9mentation d'une file, en utilisant deux piles : une pile \u00ab entrante \u00bb et une pile \u00ab sortante \u00bb.</p> <p> </p> <ol> <li> <p>Enfiler : Chaque fois qu'un nouvel \u00e9l\u00e9ment est enfil\u00e9 dans la file, il est empil\u00e9 dans la pile entrante.     Pour commencer enfilons trois nouveaux \u00e9l\u00e9ments <code>'a'</code>, <code>'b'</code> et <code>'c'</code>.</p> <ul> <li> <p><code>'a'</code> est enfil\u00e9 dans la file et empil\u00e9 dans la pile entrante :</p> <p> </p> </li> <li> <p><code>'b'</code> est enfil\u00e9 dans la file et empil\u00e9 dans la pile entrante :</p> <p> </p> </li> <li> <p><code>'c'</code> est enfil\u00e9 dans la file et empil\u00e9 dans la pile entrante :</p> <p> </p> </li> <li> <p>Les trois \u00e9l\u00e9ments <code>'a'</code>, <code>'b'</code> et <code>'c'</code> sont pr\u00e9sents dans la file et dans la pile entrante. Noter comment l'\u00e9l\u00e9ment <code>'a'</code> qui est en t\u00eate de file se trouve tout en bas de la pile.</p> <p> </p> </li> </ul> </li> <li> <p>D\u00e9filer quand la pile sortante est vide : Il n'y a pas aucun \u00e9l\u00e9ment pr\u00eat \u00e0 \u00eatre d\u00e9pil\u00e9 de la pile sortante, il faut d'abord la \u00ab remplir \u00bb avec tous les \u00e9l\u00e9ments pr\u00e9sents dans la pile entrante, puis d\u00e9piler le sommet de la pile sortante.      D\u00e9filons l'\u00e9l\u00e9ment <code>'a'</code> qui se trouve en t\u00eate de la file :</p> <ul> <li> <p>Tous les \u00e9l\u00e9ments pr\u00e9sents dans la pile entrante, <code>'a'</code>, <code>'b'</code> et <code>'c'</code>, sont d\u00e9pil\u00e9s et empil\u00e9s \u00e0 la suite dans la pile sortante.</p> <p> </p> </li> <li> <p>L'\u00e9l\u00e9ment <code>'a'</code> en t\u00eate de file est d\u00e9fil\u00e9. Il se trouve au sommet de la pile sortante, il est d\u00e9pil\u00e9.</p> <p> </p> </li> </ul> </li> <li> <p>D\u00e9filer quand la pile sortante n'est pas vide : Il suffit de d\u00e9piler le sommet de la pile sortante. D\u00e9filons l'\u00e9l\u00e9ment <code>'b'</code> qui se trouve maintenant en t\u00eate de la file :</p> <p> </p> </li> </ol> <p>Transcrivons cela en Python en cr\u00e9ant un nouveau fichier \u00ab file.py \u00bb dans le m\u00eame r\u00e9pertoire que \u00ab pile.py \u00bb  et importons ce module <code>pile</code>.</p> <pre><code>import pile\n</code></pre> <p>Il est maintenant possible d'instancier des objets de la classe <code>Cellule</code> ou <code>Pile</code> et d'utiliser les m\u00e9thodes associ\u00e9es :</p> <pre><code>c = pile.Cellule('a', None)\np = pile.Pile()\n</code></pre> <p>Cr\u00e9ons nos deux piles :</p> <pre><code>import pile\n\nclass File:\n    ''' File sous forme de deux Piles\n    '''\n    def __init__(self):\n        self.entrante = pile.Pile()\n        self.sortante = pile.Pile()\n</code></pre> <p>La m\u00e9thode <code>est_vide</code> est imm\u00e9diate, il suffit que les deux piles soient vides :</p> <pre><code>    def est_vide(self):\n        return self.entrante.est_vide() and self.sortante.est_vide()\n\n\n&gt;&gt;&gt; f = File()\n&gt;&gt;&gt; f.est_vide()\nTrue\n</code></pre> <p>Pour enfiler un \u00e9l\u00e9ment dans la file, il suffit de l'empiler dans la pile entrante :</p> <pre><code>    def enfiler(self, v):\n        self.entrante.empiler(v)\n\n\n&gt;&gt;&gt; f = File()\n&gt;&gt;&gt; f.est_vide()\nTrue\n&gt;&gt;&gt; f.enfiler('a')\n&gt;&gt;&gt; f.est_vide()\nFalse\n</code></pre> <p>Mais pour d\u00e9filer, il faut g\u00e9rer les deux cas vus pr\u00e9c\u00e9demment : <pre><code>    def defiler(self):\n        if self.est_vide():\n            raise IndexError (\"La file est vide\")\n        if self.sortante.est_vide():\n            #  TOUTE la pile entrante est d\u00e9pil\u00e9e dans la sortante\n            while not self.entrante.est_vide():\n                self.sortante.empiler(self.entrante.depiler())\n        return self.sortante.depiler()\n\n&gt;&gt;&gt; f = File()\n&gt;&gt;&gt; f.enfiler('a')\n&gt;&gt;&gt; f.enfiler('b')\n&gt;&gt;&gt; f.enfiler('c')\n&gt;&gt;&gt; f.defiler()\n'a'\n</code></pre></p>"},{"location":"structures-de-donnees/6-dictionnaires/","title":"Dictionnaires","text":"<p>Cours</p> <p>Un dictionnaire est un type abstrait de donn\u00e9es constitu\u00e9 d'\u00e9l\u00e9ments sous forme de couples cl\u00e9-valeur (key-value en anglais).</p> <p>Un dictionnaire n'a pas d'ordre, on acc\u00e8de \u00e0 chaque valeur par sa cl\u00e9. </p> <p>La cl\u00e9 d'un dictionnaire peut \u00eatre un mot (de type <code>str</code>), un nombre (de type <code>int</code> ou <code>float</code>), un p-uplet, etc., mais pas un tableau (type <code>list</code>) ni un autre dictionnaire car ce sont des types muables.</p>"},{"location":"structures-de-donnees/6-dictionnaires/#interface","title":"Interface","text":"<p>Les principales primitives constituant l'interface d'un dictionnaire sont :</p> <ul> <li><code>creer() \u2192 dict</code> : construire d'un dictionnaire vide.</li> <li><code>est_vide() \u2192 bool</code> : v\u00e9rifier si un dictionnaire est vide ou non.</li> <li><code>ajouter(cl\u00e9, valeur)</code> : ajouter un \u00e9l\u00e9ment form\u00e9 du couple cl\u00e9-valeur.</li> <li><code>supprimer(cl\u00e9) \u2192 valeur</code> : supprimer un \u00e9l\u00e9ment identifi\u00e9 par sa cl\u00e9.</li> <li><code>lire(cl\u00e9) \u2192 valeur</code> : lire la valeur associ\u00e9e \u00e0 une cl\u00e9.</li> <li><code>taille() \u2192 int</code> : renvoyer le nombre d'\u00e9l\u00e9ments dans un dictionnaire.</li> </ul>"},{"location":"structures-de-donnees/6-dictionnaires/#implementation","title":"Impl\u00e9mentation","text":"<p>Prenons pour exemple de vouloir stocker les capitales de plusieurs pays dans une structure de donn\u00e9es. Ni les tableaux, ni les listes cha\u00een\u00e9es ne semblent offrir une solution efficace  :</p> <ul> <li> <p>Les pays ne sont pas class\u00e9s dans un ordre particulier, un tableau ne permettrait donc pas d'acc\u00e9der facilement \u00e0 la capitale d'un pays.</p> </li> <li> <p>Une liste cha\u00een\u00e9e aurait l'inconv\u00e9nient de devoir parcourir toute la liste pour acc\u00e9der \u00e0 la capitale d'un pays.</p> </li> </ul> <p>Dans ce cas, un dictionnaire est la structure de donn\u00e9e la mieux adapt\u00e9e.</p> <p>Python poss\u00e8de naturellement une structure de dictionnaire (le type <code>dict</code>). Mais ce  n'est pas le cas dans tous les langages, plusieurs impl\u00e9mentations sont alors possibles, par exemple en utilisant une fonction de hachage. </p>"},{"location":"structures-de-donnees/6-dictionnaires/#avec-le-type-dict-de-python","title":"Avec le type <code>dict</code> de Python","text":"<p>Les dictionnaires Python, de type <code>dict</code>, offrent imm\u00e9diatement toutes les primitives d'un dictionnaire : </p> <pre><code>&gt;&gt;&gt; capitale = {}           # cr\u00e9er()\n&gt;&gt;&gt; len(capitale) == 0      # est_vide()\nTrue\n&gt;&gt;&gt; capitale[\"France\"] = \"Paris\"     # ajouter(cle, valeur)\n&gt;&gt;&gt; capitale[\"Allemagne\"] = \"Berlin\"     # ajouter(cle, valeur)\n&gt;&gt;&gt; capitale[\"Italie\"] = \"Rome\"     # ajouter(cle, valeur)\n&gt;&gt;&gt; capitale[\"France\"]              # lire(cle)\n'Paris'\n&gt;&gt;&gt; len(capitale)           # taille()\n3\n&gt;&gt;&gt; capitale.pop(\"Italie\")          # supprimer(cl\u00e9) \n'Rome'\n</code></pre> <p>Rappelons quelques unes des autres fonctionnalit\u00e9s vues en classe de premi\u00e8re : </p> <ul> <li> <p>Un dictionnaire peut \u00eatre cr\u00e9\u00e9 avec plusieurs couples de cl\u00e9s-valeurs s\u00e9par\u00e9s par des virgules, le tout encadr\u00e9 par des accolades \u201c{ }\u201d :</p> <pre><code>&gt;&gt;&gt; capitale = {'France': 'Paris', 'Allemagne': 'Berlin', 'Italie': 'Rome'}\n</code></pre> </li> <li> <p>Les \u00e9l\u00e9ments sont affich\u00e9s sans ordre particulier :     <pre><code>&gt;&gt;&gt; capitale\n{'Allemagne': 'Berlin', 'France': 'Paris', 'Italie': 'Rome'}\n</code></pre></p> </li> <li> <p>Il est possible d\u2019acc\u00e9der \u00e0 une valeur par sa cl\u00e9, et uniquement par sa cl\u00e9, mais pas par sa position. Les valeurs d'un dictionnaire n'ont pas de position :</p> <p><pre><code>&gt;&gt;&gt; capitale[\"France\"]\n'Paris'\n&gt;&gt;&gt; capitale[0]\nTraceback (most recent call last):\nFile \"&lt;pyshell#12&gt;\", line 1, in &lt;module&gt;\n    capitale[0]\nKeyError: 0\n</code></pre> Dans ce cas, l'interpr\u00e9teur renvoie un message d'erreur car la cl\u00e9 <code>0</code> n'existe pas dans le dictionnaire <code>capitale</code>. </p> </li> <li> <p>La m\u00e9thode <code>.get()</code> permet aussi de r\u00e9cup\u00e9rer une valeur associ\u00e9e \u00e0 une cl\u00e9, mais sans lever d'erreur si la cl\u00e9 n'existe pas :</p> <pre><code>&gt;&gt;&gt; capitale.get('France')\n'Paris'\n&gt;&gt;&gt; capitale.get(0)\n&gt;&gt;&gt; capitale.get('Espagne', 'Non d\u00e9fini')\nNon d\u00e9fini\n</code></pre> </li> <li> <p>Le mot cl\u00e9 <code>in</code> permet de v\u00e9rifier si une cl\u00e9 est pr\u00e9sente dans un dictionnaire.</p> <p><pre><code>&gt;&gt;&gt; \"France\" in capitale\nTrue\n&gt;&gt;&gt; \"Espagne\" in capitale\nFalse\n</code></pre>  Les mot cl\u00e9 <code>in</code> s'applique seulement aux cl\u00e9s d'un dictionnaire, pas \u00e0 ses valeurs :</p> <pre><code>&gt;&gt;&gt; \"Paris\" in capitale\nFalse\n</code></pre> </li> <li> <p>De la m\u00eame fa\u00e7on, <code>for</code> permet d'it\u00e9rer sur les cl\u00e9s d'un dictionnaire :  </p> <p><pre><code>&gt;&gt;&gt; for cle in capitale:\n...     print(capitale[cle], 'est en', cle)\n...\nBerlin est en Allemagne\nParis est en France\nRome est en Italie\n</code></pre> <sup>1</sup></p> </li> <li> <p>Les m\u00e9thodes <code>.keys()</code> et <code>.values()</code> renvoient les cl\u00e9s et les valeurs d'un dictionnaire :</p> <p><pre><code>&gt;&gt;&gt; capitale.keys()\ndict_keys(['Allemagne', 'France', 'Italie'])\n&gt;&gt;&gt; capitale.values()\ndict_values(['Berlin', 'Paris', 'Rome'])\n</code></pre> et la m\u00e9thode <code>.items()</code> renvoie tous les couples de cl\u00e9-valeur d'un dictionnaire :</p> <pre><code>&gt;&gt;&gt; capitale.items()\ndict_items([('Allemagne', 'Berlin'), ('France', 'Paris'), ('Italie', 'Rome')])\n</code></pre> <p> Les objets renvoy\u00e9s par ces trois m\u00e9thodes sont de types Python un peu particuliers : <code>dict_keys</code>, <code>dict_values</code> et <code>dict_items</code>. Pour les utiliser, il faut souvent les transformer en tableaux avec la fonction <code>list()</code> :</p> <pre><code>&gt;&gt;&gt; list(capitale.values())\n['Berlin', 'Paris', 'Rome']\n&gt;&gt;&gt; list(capitale.items())\n[('Allemagne', 'Berlin'), ('France', 'Paris'), ('Italie', 'Rome')]\n</code></pre> </li> <li> <p>Il est possible de modifier la valeur associ\u00e9e \u00e0 une cl\u00e9 existante (rappel : si la cl\u00e9 n'existe pas, un nouvel \u00e9l\u00e9ment est cr\u00e9\u00e9 dans le dictionnaire) : </p> <pre><code>capitale[\"Italie\"] = \"Roma\"\n</code></pre> </li> <li> <p>La m\u00e9thode <code>.pop(cl\u00e9)</code> ou l'instruction <code>del</code> permettent de supprimer un \u00e9l\u00e9ment :</p> <pre><code>&gt;&gt;&gt; capitale\n{'Allemagne': 'Berlin', 'France': 'Paris', 'Italie': 'Roma'}\n&gt;&gt;&gt; capitale.pop(\"Italie\")\n&gt;&gt;&gt; capitale\n{'Allemagne': 'Berlin', 'France': 'Paris'}\n&gt;&gt;&gt; del capitale[\"France\"]\n&gt;&gt;&gt; capitale\n{'Allemagne': 'Berlin'}\n</code></pre> <p>Ou encore le dictionnaire entier avec l'instruction <code>del capitale</code>, dans ce cas la variable <code>capitale</code> n'existe plus.</p> </li> <li> <p>Autre particularit\u00e9 vue en classe de premi\u00e8re, un dictionnaire peut \u00eatre cr\u00e9\u00e9 par compr\u00e9hension :</p> <pre><code>&gt;&gt;&gt; carres = {x:x**2 for x in range(10)}\n&gt;&gt;&gt; carres\n{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81} \n</code></pre> </li> <li> <p>Enfin, les dictionnaires sont de types muables , il faut donc faire particuli\u00e8rement attention pour copier un dictionnaire ou passer un dictionnaire en argument d'une fonction<sup>2</sup>.</p> </li> </ul>"},{"location":"structures-de-donnees/6-dictionnaires/#avec-un-tableau-et-une-fonction-de-hachage","title":"Avec un tableau et une fonction de hachage","text":"<p>Commen\u00e7ons par cr\u00e9er une classe <code>Dico</code>, stockant les valeurs d'un dictionnaire dans un tableau de 100 valeurs : <pre><code>class Dico:\n\n    def __init__(self):\n        self.t = [None] * 100\n</code></pre></p> <p>\u00c0 quelle position du tableau enregistrer les noms de capitale associ\u00e9s \u00e0 chaque pays ? C'est le r\u00f4le d'une fonction de hachage qui permet de transformer la cl\u00e9, ici le nom du pays, en un indice du tableau. </p> <p>Cours</p> <p>Une fonction de hachage est un algorithme math\u00e9matique qui transforme une valeur donn\u00e9e (par exemple une cha\u00eene de caract\u00e8re ou un autre type de donn\u00e9e) en une cha\u00eene alphanum\u00e9rique, appel\u00e9e valeur de hachage ou hash en anglais. </p> <p>L'op\u00e9ration inverse qui permet de retrouver la valeur initiale \u00e0 partir de la valeur de hachage est en principe difficile \u00e0 r\u00e9aliser.</p> <p>Il existe des m\u00e9thodes math\u00e9matiques complexes<sup>3</sup> pour d\u00e9finir des fonctions de hachage efficaces. Pour notre exemple, nous utilisons une fonction tr\u00e8s simple qui additionne les valeurs Unicode de chaque lettre, le tout modulo 100 :</p> <pre><code>def hachage(chaine):\n    hash = 0\n    for c in chaine:\n        hash += ord(c)\n    return hash % 100\n</code></pre> <p> </p> <p>La valeur renvoy\u00e9e par cette fonction de hachage sera l'indice dans le tableau. Par exemple, la capitale de la cha\u00eene <code>'France'</code> sera stock\u00e9e dans le tableau en position d'indice 91, la capitale de <code>'Allemagne'</code> en 2, etc. :</p> <pre><code>&gt;&gt;&gt; hachage('France')\n91\n&gt;&gt;&gt; hachage('Allemagne')\n2\n</code></pre> <p>Note: Il est tr\u00e8s difficile de retrouver, \u00e0 partir d'une valeur de hachage par exemple <code>2</code>, quelle \u00e9tait la cha\u00eene d'origine, ici <code>'Allemagne'</code> .</p> <p>Ajoutons les primitives d'un dictionnaire \u00e0 la classe <code>Dico</code> : <pre><code>class Dico:\n\n    def __init__(self):\n        self.t = [None] * 100\n\n\n    def ajouter(self, cle, valeur):\n        self.t[hachage(cle)] = valeur\n\n    def lire(self, cle):\n        return self.t[hachage(cle)]\n\n    def supprimer(self, cle):\n        self.t[hachage(cle)] == None\n\n    def taille(self):\n        l = 0\n        for elem in self.t:\n            if elem is not None: l += 1\n        return l\n\n    def est_vide(self):\n        return self.taille() == 0\n</code></pre> et cr\u00e9ons le dictionnaire des capitales :</p> <pre><code>&gt;&gt;&gt; capitale = Dico()\n&gt;&gt;&gt; capitale.ajouter('France', 'Paris')\n&gt;&gt;&gt; capitale.ajouter('Allemagne', 'Berlin')\n&gt;&gt;&gt; capitale.ajouter('Italie', 'Rome')\n&gt;&gt;&gt; capitale.lire('France')\nParis\n</code></pre> <p>On dit qu'il y a une \u00ab collision \u00bb quand la fonction de hachage n'est pas assez performante, comme ici, et renvoie la m\u00eame valeur de hachage pour deux cl\u00e9s diff\u00e9rentes :</p> <pre><code>&gt;&gt;&gt; hachage('Danemark')\n3\n&gt;&gt;&gt; hachage('Irlande')\n3\n</code></pre> <p>Dans ce cas, l'impl\u00e9mentation du dictionnaire doit permettre de g\u00e9rer la collision, par exemple en faisant pointer l'indice correspondant \u00e0 plusieurs cl\u00e9s vers une liste cha\u00een\u00e9e contenant toutes les cl\u00e9s-valeurs partageant ce m\u00eame indice.</p> <ol> <li> <p>Il est aussi possible d'utiliser la m\u00e9thode <code>items()</code> et d'\u00e9crire : <code>&gt;&gt;&gt; for cle, val in 'capitale.items(): val, 'est en', cle)</code> \u21a9</p> </li> <li> <p> Attention au signe <code>=</code> pour copier un dictionnaire : <pre><code>&gt;&gt;&gt; d1 = {'one':1, 'two':2, 'three':3}\n&gt;&gt;&gt; d2 = d1\n&gt;&gt;&gt; d2['three'] = 4\n&gt;&gt;&gt; d1 \n{'one':1, 'two':2, 'three':4}\n</code></pre> <code>d1</code> a aussi \u00e9t\u00e9 modifi\u00e9e quand on a modifi\u00e9 <code>d2</code> ! Les deux variables <code>d1</code> et <code>d2</code> sont en fait deux noms qui font r\u00e9f\u00e9rence vers le m\u00eame objet. Pour rem\u00e9dier \u00e0 ce probl\u00e8me, il faut utiliser aussi la fonction <code>dict()</code> qui renvoie un nouveau dictionnaire :</p> <pre><code>&gt;&gt;&gt; d1 = {'one':1, 'two':2, 'three':3}\n&gt;&gt;&gt; d2 = dict(d1)\n&gt;&gt;&gt; d2['three'] = 4\n&gt;&gt;&gt; d1 \n{'one':1, 'two':2, 'three':3}\n&gt;&gt;&gt; d2 \n{'one':1, 'two':2, 'three':4}\n</code></pre> <p>Ou encore utiliser la m\u00e9thode <code>.copy()</code> :</p> <pre><code>&gt;&gt;&gt; d1 = {'one':1, 'two':2, 'three':3}\n&gt;&gt;&gt; d2 = d1.copy()\n</code></pre> <p>Note: Si le dictionnaire contient des tableaux, les deux m\u00e9thodes ci-dessus ne fonctionnent plus, il faut utiliser <code>deepcopy</code>.</p> <p> Attention aussi aux dictionnaires pass\u00e9s en param\u00e8tre d'une fonction :</p> <p><pre><code>def test(var):\n    print(\"Adresse de la variable pass\u00e9e en argument: \", hex(id(var))  )\n    var['3'] = 3\n    print(\"Adresse de la variable une fois modifi\u00e9e: \", hex(id(var)))\n\nd = {'1': 1, '2':2}\nprint(\"Adresse de la variable dictionnaire: \", hex(id(d)) )\ntest(d)\nprint(\"dictionnaire=\", d)\n</code></pre> \u21a9</p> </li> <li> <p>Il existe de nombreux algorithme de hachage : </p> <ul> <li>MD5 : un des premiers algorithmes de hachage, il est aujourd\u2019hui consid\u00e9r\u00e9 comme peu s\u00fbr.</li> <li>SHA-1  (SHA est l\u2019acronyme de Secure Hashing Algorithm) : il n\u2019est plus recommand\u00e9 pour le stockage s\u00e9curis\u00e9 des mots de passe car il est sujet \u00e0 des attaques.</li> <li>SHA-2 : une famille d\u2019algorithmes de hachage, comprenant SHA-256 et SHA-512. Plus s\u00e9curis\u00e9 que SHA-1, il est aussi tr\u00e8s utilis\u00e9 en cryptographie, par exemple, le Bitcoin utilise SHA-256.</li> </ul> <p>\u21a9</p> </li> </ol>"},{"location":"structures-de-donnees/7-arbres/","title":"Structures hi\u00e9rarchiques : arbres","text":"<p>Cours</p> <p>Un arbre est un type abstrait de donn\u00e9es constitu\u00e9 d'un ensemble de n\u0153uds, reli\u00e9s entre eux par des ar\u00eates et organis\u00e9s de mani\u00e8re hi\u00e9rarchique :</p> <p> </p> <ul> <li>Un n\u0153ud particulier est la racine.</li> <li>Chaque n\u0153ud peut avoir aucun, un ou plusieurs fils. Les n\u0153uds qui n'ont pas de fils sont appel\u00e9s les feuilles de l'arbre, les autres (autre que la racine) sont des n\u0153uds internes. L'arit\u00e9 d'un n\u0153ud est son nombre de fils.</li> <li>Chaque n\u0153ud a un unique p\u00e8re, \u00e0 l'exception de la racine qui n'en n'a pas. Les n\u0153uds qui ont le m\u00eame p\u00e8re sont appel\u00e9s des fr\u00e8res.</li> <li>Le chemin \u00e0 la racine d'un n\u0153ud est la liste des n\u0153uds qu'il faut parcourir depuis la racine jusqu'au n\u0153ud consid\u00e9r\u00e9.</li> <li>L'\u00e9tiquette est la valeur donn\u00e9e \u00e0 chaque n\u0153ud (ici les noms de langages informatiques).</li> </ul> <p>Les arbres trouvent de nombreuses applications en informatique, par exemple dans une arborescence de fichiers ou pour des strat\u00e9gies de jeux.</p> <p>Cours</p> <ul> <li> <p>La taille d'un arbre est son nombre de n\u0153uds.</p> </li> <li> <p>La profondeur d'un n\u0153ud est  le nombre de noeuds, ou niveaux, entre la racine le n\u0153ud. La profondeur de la racine est donc 1.</p> </li> <li> <p>La hauteur d'un arbre est la plus grande profondeur d'une feuille de l'arbre.  Un arbre r\u00e9duit \u00e0 la racine a une hauteur de 1, un arbre vide a une hauteur de 0 (par convention).</p> </li> </ul> <p> Il n'existe pas de d\u00e9finition universelle pour la hauteur d'un arbre et la profondeur d'un n\u0153ud dans un arbre. Dans certains cas la profondeur est le nombre d'ar\u00eates entre la racine le n\u0153ud, la hauteur de l'arbre r\u00e9duit \u00e0 la racine est alors de 0 et la hauteur de l'arbre vide est -1<sup>1</sup>.</p>"},{"location":"structures-de-donnees/7-arbres/#interface","title":"Interface","text":"<p>Les principales primitives constituant l'interface d'un arbre sont :</p> <ul> <li><code>creer() \u2192 arbre</code> : construire un arbre vide.</li> <li><code>est_vide() \u2192 bool</code> : v\u00e9rifier si un arbre est vide ou non.</li> <li><code>taille() \u2192 int</code> : renvoyer la taille d'un arbre.</li> <li><code>hauteur() \u2192 int</code> : renvoyer la hauteur d'un arbre.</li> <li><code>profondeur(n\u0153ud) \u2192 int</code> : renvoyer la profondeur d'un n\u0153ud.</li> <li><code>est_feuille(noeud) \u2192 bool</code> : v\u00e9rifier si un n\u0153ud est une feuille ou pas.</li> <li><code>branche(noeud) \u2192 arbre</code> : renvoyer un sous-arbre de racine n\u0153ud. \u2003</li> </ul> <p>Python ne propose pas de fa\u00e7on native l'impl\u00e9mentation des arbres. Ils peuvent \u00eatre impl\u00e9ment\u00e9s de plusieurs fa\u00e7ons.</p>"},{"location":"structures-de-donnees/7-arbres/#implementation-avec-un-dictionnaire","title":"Impl\u00e9mentation avec un dictionnaire","text":"<p>Une premi\u00e8re impl\u00e9mentation est d'utiliser un dictionnaire dont les cl\u00e9s sont les \u00e9tiquettes des n\u0153uds et les valeurs des tableaux de fils.</p> <p> </p> <pre><code>arbre = {'A':['B', 'C', 'D', 'E', 'F', 'G'], 'B':['H','I'],\n         'C':[], 'D':[], 'E':['J','K'], 'F':[], 'G':['L'],\n         'H':[''], 'I':[], 'J':[], 'K':[], 'L':[]\n         }\n</code></pre> <p>Les primitives s'\u00e9crivent :</p> <pre><code>def creer():\n    return {}\n\ndef est_vide(arbre):\n    return len(arbre) == 0\n\ndef taille(arbre):\n    return len(arbre)\n\ndef ajouter_noeud(arbre, fils, pere = None):\n    if fils not in arbre:\n        arbre[fils] = []      # ajoute le noeud fils \u00e0 l'arbre\n        if pere is not None:\n            arbre[pere].append(fils)   # et dans la liste des fils du pere\n\n\ndef est_feuille(arbre, noeud):\n    \"\"\" True si n est une feuille, False sinon\"\"\"\n    return arbre[noeud] == []       # si noeud n'a pas de fils\n</code></pre> <p>puis pour cr\u00e9er notre arbre :</p> <pre><code>a = creer()\najouter_noeud(a, 'A')\nfor fils in ['B', 'C', 'D', 'E', 'F', 'G']:\n    ajouter_noeud(a, fils, 'A')      # les fils de 'A'\nfor fils in ['H', 'I']:\n    ajouter_noeud(a, fils, 'B')      # les fils de 'B'\nfor fils in ['J', 'K']:\n    ajouter_noeud(a, fils, 'E')      # les fils de 'E'\najouter_noeud(a, 'L', 'G')\n</code></pre> <p>Il est aussi possible de rajouter quelques primitives de profondeur, hauteur, etc. :</p> <pre><code>def pere(arbre, noeud):\n    \"\"\" Renvoie le pere de noeud\"\"\"\n    for n in arbre:\n        if noeud in arbre[n]:      # si noeud est un fils de n\n            return n\n    return None     # n est la racine, le pere est None\n\n\n\ndef profondeur(arbre, noeud):  \n    \"\"\" Renvoie la profondeur de noeud\"\"\"\n    p = 1\n    while pere(arbre, noeud) is not None:    # tant qu'on n'est pas \u00e0 la racine\n        p = p + 1           # on ajoute 1 \u00e0 p\n        noeud = pere(arbre, noeud)  # on remplace noeud par son pere\n    return p\n\n\n# ou en r\u00e9cursif\ndef profondeur_rec(arbre, noeud):\n    \"\"\" Renvoie la profondeur de n\"\"\"\n    if pere(arbre, noeud) is None: return 1    # la profondeur de la racine est 0\n    return 1 + profondeur_rec(arbre, pere(arbre, noeud))\n\n\ndef hauteur(arbre):\n    \"\"\" Renvoie la hauteur de l'arbre\"\"\"\n    p_max = 0\n    for n in arbre:\n        if profondeur(arbre, n) &gt; p_max:\n            p_max = profondeur(arbre, n)\n    return p_max\n</code></pre>"},{"location":"structures-de-donnees/7-arbres/#arbre-binaire","title":"Arbre binaire","text":"<p>Cours</p> <p> </p> <p>Un arbre binaire (AB) est un cas particuliers d'arbre o\u00f9 chaque n\u0153ud poss\u00e8de au maximum deux fils ordonn\u00e9s : un fils gauche et/ou un fils droit. </p> <p>Les fils gauche et droit ne sont pas intervertibles !</p> <p>Il est possible d'avoir des arbres binaires de m\u00eame taille mais de \u00ab forme \u00bb tr\u00e8s diff\u00e9rente :</p> Arbre binaire filiforme (ou d\u00e9g\u00e9n\u00e9r\u00e9)Arbre binaire parfait <p>Tous ses n\u0153uds poss\u00e8dent un unique fils (on parle aussi de peigne).</p> <p> </p> <p>Tous ses n\u0153uds poss\u00e8dent exactement 2 fils (sauf les feuilles qui en ont z\u00e9ro !).</p> <p> </p> <p>Il en r\u00e9sulte certaines propri\u00e9t\u00e9s sur la taille \\(n\\)  et la hauteur \\(h\\) d'un arbre binaire :</p> <ul> <li> <p>Un arbre filiforme de taille \\(n\\) a une hauteur \\(h\\) \u00e9gale \u00e0 \\(n\\), c'est la plus grande hauteur possible donc pour tout AB : $h \u2264  n $.</p> </li> <li> <p>On peut aussi montrer<sup>2</sup> qu'un arbre binaire parfait de hauteur \\(h\\) a une taille \\(n\\) \u00e9gale \u00e0  \\(2^{h} - 1\\) , c'est la plus grande taille possible donc pour tout AB : $ n \u2264  2^{h} \u2013 1$. On en d\u00e9duit que \\(log_2 (n+1) \u2264 h\\) o\u00f9 \\(log_2 (n+1)\\) est le logarithme en base \\(2\\) de \\(n+1\\)<sup>3</sup>.</p> </li> </ul> <p>Cours</p> <p>La taille \\(n\\) d'un arbre binaire quelconque de hauteur \\(h\\)  est encadr\u00e9e par :     \\(h \u2264 n \u2264 2^{h } - 1\\)</p> <p>R\u00e9ciproquement, la hauteur \\(h\\) d'un arbre binaire de taille \\(n\\) est encadr\u00e9e par :   \\(log_2 (n+1) \u2264 h \u2264 n\\)</p>"},{"location":"structures-de-donnees/7-arbres/#implementation-avec-des-p-uplets-imbriques","title":"Impl\u00e9mentation avec des p-uplets imbriqu\u00e9s","text":"<p>Les arbres binaires ont au plus deux fils, il est donc possible d'utiliser des tripl\u00e9s imbriqu\u00e9s contenant pour chaque n\u0153ud : sa valeur, son fils de gauche et son fils de droite (dans cet ordre).</p> <p> </p> <pre><code>&gt;&gt;&gt; n4 = (4, (), ())\n&gt;&gt;&gt; n5 = (5, (), ())\n&gt;&gt;&gt; n2 = (2, n4, n5)\n&gt;&gt;&gt; n6 = (6, (), ())\n&gt;&gt;&gt; n3 = (3, (), n6)\n&gt;&gt;&gt; a = (1, n2, n3)\n&gt;&gt;&gt; a\n(1, (2, (4, (), ()), (5, (), ())), (3, (), (6, (), ())))\u2003\n</code></pre>"},{"location":"structures-de-donnees/7-arbres/#implementation-recursive","title":"Impl\u00e9mentation r\u00e9cursive","text":"<p>Notons qu'un arbre binaire peut-\u00eatre est d\u00e9fini de fa\u00e7on r\u00e9cursive comme \u00e9tant :</p> <ul> <li>soit un arbre vide,</li> <li>soit compos\u00e9  d'un n\u0153ud racine avec une valeur, un sous-arbre gauche et un sous-arbre droit.</li> </ul> <p>Les sous-arbres de gauche et droite sont aussi des arbres (autrement dit des n\u0153uds avec deux sous-arbres, etc\u2026). </p> <p>Impl\u00e9mentons sur ce mod\u00e8le un arbre binaire par une classe <code>Noeud</code>, r\u00e9cursive, poss\u00e9dant trois attributs :</p> <p> </p> <ul> <li><code>valeur</code> pour l'\u00e9tiquette du noeud ;</li> <li><code>gauche</code>, le sous-arbre gauche, c'est une instance de <code>Noeud</code> (ou <code>None</code> si le n\u0153ud n'a pas de fils gauche) ;</li> <li><code>droite</code>, le sous-arbre droit, c'est une instance de <code>Noeud</code> (ou <code>None</code> si le n\u0153ud n'a pas de fils droit).</li> </ul> <pre><code>class Noeud:\n    def __init__(self, v, g=None, d=None):\n        self.valeur = v    \n        self.gauche = g   # None ou un Noeud\n        self.droite = d   # None ou un Noeud\n</code></pre> <p>et cr\u00e9ons un arbre non vide (un arbre vide est <code>None</code>) :</p> <p> </p> <pre><code>n4 = Noeud(4) \nn5 = Noeud(5) \nn2 = Noeud(2, n4, n5) \nn6 = Noeud(6) \nn3 = Noeud(3, d=n6) \na = Noeud(1, n2, n3)\n</code></pre> <p>ce qui peut aussi s'\u00e9crire directement :</p> <pre><code>a = Noeud(1, Noeud(2, Noeud(4), Noeud(5)), Noeud(3, None, Noeud(6)))\n</code></pre> <p>Ajoutons une premi\u00e8re m\u00e9thode pour v\u00e9rifier si un n\u0153ud est une feuille :</p> <pre><code>    def est_feuille(self) -&gt; bool:\n        return self.gauche is None and self.droite is None\n</code></pre> <p>puis la taille et la hauteur de l'arbre :</p> <pre><code>    def taille(self):\n        \"\"\" Renvoie la taille (le nombre de noeud) de l'arbre\"\"\"\n        # taille du sous-arbre droit\n        if self.droite is None:\n            td = 0 \n        else: \n            td = self.droite.taille()\n\n        # taille du sous-arbre gauche\n        if self.gauche is None: \n            tg = 0\n        else: \n            tg = self.gauche.taille()\n\n        # 1 (pour le noeud self) + taille \u00e0 gauche + la taille \u00e0 droite\n        return 1 + td + tg\n\n    def hauteur(self):\n        \"\"\" Renvoie la hauteur (la plus grande profondeur) de l'arbre,\n        Par convention, la taille d'un arbre r\u00e9duit \u00e0 la racine est 1, celle de l'arbre vide est 0\"\"\"\n\n        # hauteur du sous-arbre droit\n        if self.droite is None:\n            hd = 0 \n        else:\n            hd = self.droite.hauteur()\n\n        # hauteur du sous-arbre gauche\n        if self.gauche is None:\n            hg = 0\n        else:\n            hg = self.gauche.hauteur()\n\n        # 1 (pour le noeud self) + la plus grande taille entre gauche et droite\n        return 1 + max(hd , hg)\n</code></pre> <p>On retrouve cette impl\u00e9mentation avec une classe <code>Noeud</code> dans la plupart des exercices de baccalaur\u00e9at<sup>4</sup>, parfois la nommant <code>arbre</code>, ou <code>AB</code>. N\u00e9anmoins on peut lui reprocher de ne pas repr\u00e9senter correctement la d\u00e9finition propos\u00e9e d'un arbre, puisque les arbres et sous-arbres vides sont repr\u00e9sent\u00e9s par <code>None</code>, ce qui n'est pas une instance de cette classe ! </p> <p>En plus de nous limiter aux arbres non-vides (dit \u00ab enracin\u00e9s \u00bb) et d'imposer des manipulations p\u00e9nibles dans le code pour v\u00e9rifier si un sous-arbre est <code>None</code> ou pas (comme ici <code>if self.droite is None: ...</code>), cela engendre beaucoup d'erreurs de programmation (utilisations erron\u00e9es des m\u00e9thodes de la classe <code>Noeud</code> sur <code>None</code>).</p> <p> Pour tenter de rem\u00e9dier \u00e0 ces d\u00e9fauts, on trouve plusieurs variantes d'impl\u00e9mentation, plus ou moins satisfaisantes. </p> <p>Une premi\u00e8re variante consiste \u00e0 ajouter une classe d'arbre qui pointe sur <code>None</code> quand l'arbre est vide et sur un <code>Noeud</code> racine quand l'arbre est enracin\u00e9<sup>5</sup> (sur le m\u00eame mod\u00e8le des listes chain\u00e9es utilisant les classes <code>Cellules</code> et <code>ListeChainees</code>).</p> <p>La structure r\u00e9cursive est la classe <code>Noeud</code>, pas la classe <code>AB</code> !</p> <p> </p> <p>Ajoutons \u00e0 notre structure cette classe <code>AB</code> avec un attribut racine qui est de type <code>Noeud</code> ou <code>None</code> pour un arbre vide.</p> <pre><code>class AB:\n    def __init__(self, racine=None):\n        self.racine = racine     # None ou un Noeud\n</code></pre> <p>Il est maintenant possible d'impl\u00e9menter un arbre vide comme un objet de la classe <code>AB</code> : <pre><code>arbre = AB()\n</code></pre></p> <p>ou un arbre complet :</p> <pre><code>arbre = AB(Noeud(1, Noeud(2, Noeud(4), Noeud(5, Noeud(7), Noeud(8))), Noeud(3, None, Noeud(6, Noeud(9)))))\n</code></pre> <p>Ajoutons les primitives d'un arbre binaire :</p> <pre><code>class AB:\n    def est_vide(self):\n        return self.racine == None\n\n    def hauteur(self):\n        if self.racine is None: return 0\n        # renvoie la hauteur du n\u0153ud racine\n        return self.racine.hauteur()\n\n    def taille(self):\n        if self.racine is None: return 0\n        # renvoie la taille du n\u0153ud racine\n        return self.racine.taille()\n</code></pre> <p>Une seconde variante que l'on rencontre parfois<sup>6</sup> consiste \u00e0 ne garder qu'une seule classe <code>Noeud</code> et en repr\u00e9sentant un arbre vide avec une instance dont l'attribut <code>self.valeur</code> prend la valeur <code>None</code>. </p> <pre><code>class Noeud:\n    def __init__(self, v=None, g=None, d=None):\n        self.valeur = v   # None pour un arbre vide \n        self.gauche = g   # None ou un Noeud\n        self.droite = d   # None ou un Noeud\n</code></pre> <p>On peut alors simplement cr\u00e9er un arbre vide : <pre><code>arbre_vide = Noeud()\n</code></pre> Ici, l'objet <code>arbre_vide</code> est repr\u00e9sent\u00e9 par un noeud \u00e0 part enti\u00e8re. On peut utiliser les m\u00e9thodes de la classe <code>Noeud</code> pour calculer la hauteur et la taille :</p> <pre><code>&gt;&gt;&gt; arbre_vide.taille()\n1\n</code></pre> <p>L'arbre vide comporte un noeud, la m\u00e9thode renvoie une taille 1 au lieu de 0 ! De m\u00eame <code>.hauteur()</code> renvoie 1 au lieu de 0. Il faut donc modifier les deux m\u00e9thodes en cons\u00e9quence.</p>"},{"location":"structures-de-donnees/7-arbres/#arbres-binaires-de-recherche","title":"Arbres binaires de recherche","text":"<p>Cours</p> <p> </p> <p>Un arbre binaire de recherche (ABR)  est un cas particulier d'arbre binaire sans lequel :</p> <ul> <li>Chaque n\u0153ud a une valeur (ou cl\u00e9) sup\u00e9rieure \u00e0 celles de tous les n\u0153uds de son sous-arbre gauche.</li> <li>Chaque n\u0153ud a une valeur inf\u00e9rieure \u00e0 celles de tous les n\u0153uds de son sous-arbre droit.</li> <li>Tous les sous-arbres sont aussi des ABR.</li> </ul> <p>Note : \u00ab sup\u00e9rieur \u00bb et   \u00ab inf\u00e9rieur \u00bb peuvent \u00eatre au sens strict ou large en fonction de la d\u00e9finition donn\u00e9e.</p> <p>Consid\u00e8rons l'arbre binaire de recherche pr\u00e9c\u00e9dent qui servira comme support pour illustrer la suite.</p> <p>Plut\u00f4t que de dupliquer la classe <code>AB</code> pr\u00e9c\u00e9dente en <code>ABR</code> et de la modifier, nous allons cr\u00e9er une sous-classe par h\u00e9ritage<sup>7</sup> et lui ajouter les sp\u00e9cificit\u00e9s d'un ABR. </p> <p>Inutile de r\u00e9\u00e9crire le constructeur :</p> <pre><code>class ABR(AB):\n    pass\n\na = ABR(Noeud(7, Noeud(4, Noeud(2), Noeud(6)), Noeud(11, Noeud(9, Noeud(8), Noeud(10)), Noeud(12))))\n</code></pre> <p>Toutes les m\u00e9thodes de la classe <code>AB</code> fonctionnent par h\u00e9ritage pour un objet de la classe <code>ABR</code> :</p> <pre><code>&gt;&gt;&gt; a.taille()\n9\n&gt;&gt;&gt; a.hauteur()\n3\n</code></pre> <p>Ajoutons des m\u00e9thodes propres aux ABR :</p>"},{"location":"structures-de-donnees/7-arbres/#cles-min-et-max","title":"Cl\u00e9s min et max","text":"<p>Pour acc\u00e9der \u00e0 la plus petite cl\u00e9 d'un ABR, il suffit de descendre sur les fils \u00e0 gauche autant que possible. Le dernier n\u0153ud visit\u00e9 qui n'a pas de fils gauche porte la plus petite valeur de l'ABR. De la m\u00eame fa\u00e7on, pour trouver la plus grande valeur, il suffit de descendre sur les fils \u00e0 droite.</p> <p>La classe <code>ABR</code> n'\u00e9tant pas r\u00e9cursive, il faut d\u00e9finir une m\u00e9thode r\u00e9cursive au niveau de la classe <code>Noeud</code> qui descend le plus \u00e0 gauche<sup>8</sup> :</p> <p><pre><code>class Noeud:\n    def desc_g(self):\n        ''' renvoie la feuille la plus \u00e0 gauche'''\n        if self.gauche is None: return self.valeur\n        return self.gauche.desc_gauche()\n</code></pre> puis renvoyer sa valeur dans la classe ABR pour obtenir le min d'un arbre :</p> <pre><code> class ABR :\n   def min(self):\n        \"\"\" Renvoie la plus petite valeur de l'arbre \"\"\"\n        if self.racine is None: return None\n        return self.racine.desc_g().valeur\n</code></pre>"},{"location":"structures-de-donnees/7-arbres/#verifier-que-larbre-est-un-abr-hors-programme","title":"V\u00e9rifier que l'arbre est un ABR (hors programme)","text":"<p>Pour v\u00e9rifier qu'un arbre est un ABR, il faut v\u00e9rifier que :</p> <ul> <li>La cl\u00e9 de chaque n\u0153ud est plus grande que le max de son sous-arbre de gauche, et plus petite que le min de son sous-arbre de droite.</li> <li>Les sous-arbres de droites et de gauches sont des ABR.</li> </ul> <p>Impl\u00e9mentons cette v\u00e9rification de fa\u00e7on r\u00e9cursive au niveau de la classe <code>N\u0153ud</code> :</p> <pre><code>class Noeud:\n\n    def verif_noeud(self):\n        ''' v\u00e9rifie que le sous-arbre de racine noeud est un ABR'''\n        if self.gauche is None: g = True\n        else:\n            g = self.valeur &gt; self.gauche.desc_d().valeur and self.gauche.verif_noeud()\n        if self.droite is None: d = True\n        else:\n            d = self.valeur &lt; self.droite.desc_g().valeur and self.droite.verif_noeud()\n        return g and d\n</code></pre> <p>Rajoutons une m\u00e9thode au niveau de la classe <code>ABR</code> :</p> <pre><code>    def verif_ABR(self):\n        \"\"\" Renvoie True si self est bien un ABR \"\"\"\n        if self.racine is None: return True\n        return self.racine.verif_noeud()\n</code></pre> <ol> <li> <p>Un arbre vide a une hauteur de 0 et un arbre r\u00e9duit \u00e0 la racine une hauteur de 1 dans la plupart des sujets de bac (21-Sujet_0, 21-NSIJ2ME1, 21-NSIJ2ME2, 22-NSIJ1AS1, 22-NSIJ1JAN1, 22-NSIJ1PO1, 22-NSIJ2JA1, 22-NSIJ2ME1, 23-NSIJ2G11 et 23-NSIJ2LI1) sauf les sujets  22-NSIJ1NC1, 24-NSIJ2PO1, 25-NSIPE2, 25-NSIJ2ME1 et 25-NSI-17 o\u00f9 un arbre vide a une hauteur de -1 et un arbre r\u00e9duit \u00e0 la racine une hauteur de 0.\u00a0\u21a9</p> </li> <li> <p>Par r\u00e9currence la taille d'un arbre racine est \\(2^{1} - 1 = 1\\), et si la taille d'un arbre parfait de hauteur \\(h-1\\) est \\(2^{h-1} -1\\), pour obtenir la taille de l'arbre parfait de hauteur \\(h\\) il faut ajouter \\(2^{(h-1)}\\) nouveaux n\u0153uds, au total on obtient \\(2^{h-1} -1 + 2^{h-1} = 2 \\times 2^{h-1} - 1 = 2^{h} -1\\).\u00a0\u21a9</p> </li> <li> <p>Le logarithme en base 2, not\u00e9 \\(log_2\\) est une op\u00e9ration math\u00e9matique qui calcule la puissance \u00e0 laquelle il faut \u00e9lever le nombre 2 pour obtenir un nombre donn\u00e9. Par exemple \\(log_2 (8)\\) est \\(3\\) car\\(2^3 = 8\\).\u00a0\u21a9</p> </li> <li> <p>On trouve des arbres impl\u00e9ment\u00e9s par une seule classe r\u00e9cursive dans les sujets 21-NSIJ1ME1,  22-NSIJ2ME1,  22-NSIJ1LR1,  23-NSIJ2AS1 23-NSIJ2LI1,  23-NSIJ2LR1,   23-NSIJ2ME1,   23-NSIJ2PO1,   23-sujet_0-b,   25-NSIJ2JA1,   25-NSIPE2,   25-NSIJ2AN1\u00a0\u21a9</p> </li> <li> <p>On trouve un arbre impl\u00e9ment\u00e9 par une classe <code>Noeud</code> r\u00e9cursive et une classe <code>Arbre</code> dans les sujets 21-NSIJ2ME2 \u21a9</p> </li> <li> <p>On trouve un arbre impl\u00e9ment\u00e9 par une classe <code>Noeud</code> dont l'attribut <code>valeur</code> d'un arbre vide est \u00e9gal \u00e0 <code>None</code> dans les sujets  21-NSIJ2PO1 et [25-NSIJ1G11] (https://www.education.gouv.fr/media/227719/download). Par ailleurs, le sujet   https://e-nsi.gitlab.io/pratique/N2/800-arbre_bin/sujet/ montre un exemple de ce type d'impl\u00e9mentation compl\u00e9tement r\u00e9cursif.\u00a0\u21a9</p> </li> <li> <p>L'h\u00e9ritage est un des grands principes de la programmation orient\u00e9e objet (POO) permettant de cr\u00e9er une nouvelle classe \u00e0 partir d'une classe existante. La sous classe h\u00e9rite des attributs et des m\u00e9thodes de la classe m\u00e8re et en ajoute de nouveaux.\u00a0\u21a9</p> </li> <li> <p>On peut aussi d\u00e9finir une fonction r\u00e9cursive directement dans la m\u00e9thode <code>min()</code> de la classe <code>ABR</code>. <pre><code>class ABR:\n    def min(self):\n        \"\"\" Renvoie la plus petite valeur de l'arbre \"\"\"\n        if self.racine is None: return None\n\n        def desc_g(n):\n            while n.gauche is not None:\n                n = desc_g(n.gauche)\n            return n\n\n        return desc_g(self.racine).valeur\n</code></pre> \u21a9</p> </li> </ol>"},{"location":"structures-de-donnees/8-graphes/","title":"Structures relationnelles : graphes","text":"<p>Cours</p> <p>Un graphe est un type abstrait de donn\u00e9es constitu\u00e9 de sommets reli\u00e9s entre eux par des ar\u00eates ou arcs (selon le type de graphe). </p> <p>Un graphe peut \u00eatre :</p> <ul> <li>non-orient\u00e9, chaque ar\u00eate peut-\u00eatre parcourue dans les deux sens.</li> <li>orient\u00e9, chaque arc ne peut-\u00eatre parcouru que dans un seul sens indiqu\u00e9 par une fl\u00e8che.</li> <li>pond\u00e9r\u00e9, chaque ar\u00eate porte une valeur (aussi appel\u00e9e poids ou co\u00fbt).</li> </ul> graphe non orient\u00e9graphe orient\u00e9graphe pond\u00e9r\u00e9 <p> </p> <p> </p> <p> </p> <p>Les graphes trouvent de nombreuses applications en informatique, par exemple dans une mod\u00e9lisation de r\u00e9seau de routeurs, de r\u00e9seau social, de r\u00e9seau routier, de labyrinthe, etc.</p> <p>Cours</p> <p>Le nombre de sommets d'un graphe est l'ordre du graphe, le nombre d'ar\u00eates est la taille du graphe.</p> <p>Deux sommets reli\u00e9s entre eux par une ar\u00eate sont dits adjacents ou voisins.</p> voisinage de A dans un graphe orient\u00e9voisisage de D dans un graphe orient\u00e9voisinage de D dans un graphe non orient\u00e9 <p> </p> <p> </p> <p> </p> <p>Le degr\u00e9 d'un sommet est le nombre d'ar\u00eates issues de ce sommet. La somme des degr\u00e9s des sommets est le double du nombre d'ar\u00eates du graphe<sup>1</sup>.</p> <p>Un m\u00eame graphe peut avoir de nombreuses repr\u00e9sentations graphiques. Voici trois repr\u00e9sentation d'un m\u00eame graphe :</p> <p> </p> <p>Cours</p> <p>Un chemin (ou chaine pour les graphes non orient\u00e9s) est une suite de sommets reli\u00e9s par des ar\u00eates. </p> <p>Un cycle (ou circuit pour les graphes non orient\u00e9s) est un chemin ferm\u00e9.</p> <p>Remarque : dans un graphe orient\u00e9, il peut exister un chemin menant du sommet x au sommet y, alors que l'inverse n'est pas possible.</p> <p>Exemple : chemin menant de A \u00e0 C, que l'on peut noter A\u2192B\u2192D\u2192C</p> <p> </p> <p>Cours</p> <p>La distance entre deux sommets d'un arbre est la longueur (nombre d'ar\u00eates) du chemin le plus court (s'il y en a un) reliant ces deux sommets.</p> <p>Exemple : la distance entre A et C est la distance du plus court chemin de A \u00e0 C (A\u2192D\u2192C), soit 2 (ar\u00eates).  </p> <p>Cours</p> <p>Un graphe non orient\u00e9 est connexe si pour toute paire (x, y) de sommets, il existe un chemin de x \u00e0 y.</p> <p>Un graphe orient\u00e9 est connexe si le graphe non orient\u00e9 obtenu en ne tenant pas compte du sens des ar\u00eates est connexe. Un graphe orient\u00e9 est fortement connexe si pour toute paire (x, y) de sommets, il existe un chemin de x \u00e0 y et un chemin de y \u00e0 x.</p> <p>Exemple : Un graphe orient\u00e9 connexe, mais pas fortement connexe (il n'existe pas de chemin menant \u00e0 A).</p> <p> </p> <p>Cours</p> <p>Un chemin eul\u00e9rien est un chemin dans le graphe qui passe par toutes les ar\u00eates juste une seule fois. Si ce chemin est ferm\u00e9, on parlera de cycle eul\u00e9rien. Un graphe est dit eul\u00e9rien s'il poss\u00e8de un cycle eul\u00e9rien.</p> <p>Un chemin hamiltonien est un chemin dans le graphe qui passe par tous les sommets une et une seule fois. Si ce chemin est ferm\u00e9, on parlera de cycle hamiltonien. Un graphe est dit hamiltonien s'il poss\u00e8de un cycle hamiltonien.</p> <p>Exemples :</p> <ul> <li> <p>Un graphe avec un chemin hamiltonien d-e-c-b-a et un cycle hamiltonien d-e-b-a-c.</p> <p> </p> </li> <li> <p>Un graphe avec un chemin eul\u00e9rien e-b-d-e-c-a-b-c-d mais pas de cycle eul\u00e9rien.</p> <p> </p> </li> </ul> <p>Cours</p> <p>Th\u00e9or\u00e8me d'Euler:</p> <ul> <li> <p>Un graphe connexe admet un chemin eul\u00e9rien si et seulement si ses sommets sont tous de degr\u00e9 pair sauf au plus deux.</p> </li> <li> <p>Un graphe connexe admet un circuit eul\u00e9rien si et seulement si tous ses sommets sont de degr\u00e9 pair.</p> </li> </ul> <p>Le probl\u00e8me des sept ponts de K\u00f6nigsberg<sup>2</sup> est le probl\u00e8me de savoir si on peut traverser chaque pont de la ville de K\u00f6nigsberg en une promenade, une fois sur chaque pont. Comme le montre la figure ci-dessous, le probl\u00e8me se mod\u00e9lise \u00e0 l'aide d'un graphe comme suit : les ponts constituent les ar\u00eates et les \u00eeles et les berges les sommets. Comme ce graphe n'admet pas de chemin eul\u00e9rien, le probl\u00e8me n'a pas de solutions.</p> <p> </p> <p>Exercice corrig\u00e9</p> <p>Montrer que le dessin ci-dessous peut \u00eatre trac\u00e9 enti\u00e8rement sans lever le crayon. Proposer un cycle eul\u00e9rien.</p> <p> </p> R\u00e9ponse <p>Il y a 2 ou 4 ar\u00eates partant de chaque sommet, tous les sommets du graphe sont de degr\u00e9 pair, il existe donc un cycle eul\u00e9rien.</p> <p>Par exemple : a-e-f-g-k-h-i-e-b-c-d-f-i-j-h-g-d-a</p> <p>Exercice corrig\u00e9</p> <p>Un facteur d\u00e9sire faire sa tourn\u00e9e sans passer deux fois dans la m\u00eame rue. Est-ce possible si sa tourn\u00e9e a les profils suivants (o\u00f9 chaque rue est repr\u00e9sent\u00e9e par une ar\u00eate) :</p> <p> </p> R\u00e9ponse <p>a) Non c'est impossible, toutes les ar\u00eates du graphe sont de degr\u00e9 impair, il n'existe pas de chemin eul\u00e9rien</p> <p>b) oui c'est possible, mais il ne peut pas retourner \u00e0 son point de d\u00e9part car toutes les ar\u00eates du graphe sont de degr\u00e9 pair sauf deux, il existe donc un chemin eul\u00e9rien mais pas un cycle eul\u00e9rien.</p>"},{"location":"structures-de-donnees/8-graphes/#interface","title":"Interface","text":"<p>Les principales primitives constituant l'interface d'un graphe sont :</p> <ul> <li><code>creer() \u2192 graphe</code> : construire un graphe vide.</li> <li><code>est_vide() \u2192 bool</code> : v\u00e9rifier si un graphe est vide ou non.</li> <li><code>taille() \u2192 int</code> : renvoyer la taille d'un graphe (nombre d'ar\u00eates).</li> <li><code>ordre() \u2192 int</code> : renvoyer l'ordre d'un graphe (nombre de noeuds).</li> <li><code>voisins(S) \u2192 [sommets]</code> : renvoyer la liste des sommets  voisins de S.</li> <li><code>chemin(S1, S2) \u2192 [sommets]</code> : renvoyer un chemin allant de S1 \u00e0 S2 (s'il existe).</li> </ul>"},{"location":"structures-de-donnees/8-graphes/#implementation","title":"Impl\u00e9mentation","text":"<p>Un graphe est enti\u00e8rement d\u00e9fini par l'ensemble de ses sommets et l'ensemble de ses ar\u00eates. Les sommets d'un graphe peuvent repr\u00e9senter n'importe quel type de donn\u00e9e. Le choix d'une repr\u00e9sentation plut\u00f4t qu'une autre d\u00e9pend des usages que l'on souhaite faire du graphe (construction, parcours, \u2026) </p>"},{"location":"structures-de-donnees/8-graphes/#matrice-dadjacence","title":"Matrice d'adjacence","text":"<p>Cours</p> <p>Soit un graphe de \\(n\\) sommets, d'indices \\(0\\), \\(1\\), ..., \\(n\u22121\\).</p> <p>La matrice d'adjacence de ce graphe est un tableau \\(A\\) \u00e0 deux dimensions, de taille \\(n \\times n\\), contenant des bool\u00e9ens \\(A[i][j]\\) indiquant s'il y a adjacence entre les sommets d'indices \\(i\\) et \\(j\\).</p> <p>Exemple : matrice d'adjacence du graphe orient\u00e9 ci-dessous :</p> <p> </p> <p>Impl\u00e9mentons un graphe avec une matrice d'adjacence dans une classe <code>Graphe</code> :</p> <pre><code>class Graphe:\n    def __init__(self, oriente = False):\n        self.matrice = []    # matrice d'adjacence\n        self.oriente = oriente \n        self.sommets = []    # etiquettes des sommets\n\n    def ordre(self):\n        \"\"\" renvoie le nombre de sommet\"\"\"\n        return len(self.matrice)\n\n    def est_vide(self):\n        return self.ordre() == 0\n</code></pre> <p>Pour ajouter un sommet, il faut \u00e9tendre le tableau d'une ligne et d'une colonne :</p> <pre><code>        def ajouter_sommet(self, s):\n        \"\"\" ajoute un sommet avec l'\u00e9tiquette s \"\"\"\n        assert s not in self.sommets, 'sommet d\u00e9j\u00e0 existant'\n        n = self.ordre()\n        for i in range(n):\n            self.matrice[i].append(0)   # rajoute 0 \u00e0 chaque ligne\n        self.matrice.append([0] * (n+1)) # rajoute une ligne de 0s\n        self.sommets.append(s)\n</code></pre> <p>Pour ajouter un arc (ou une ar\u00eate pour un graphe non orient\u00e9) entre sommets, il faut trouver la position des sommets dans la matrice d'adjacence :</p> <pre><code>    def ajouter_arc(self, s1, s2):\n        \"\"\" ajoute une ar\u00eate (arc) entre les sommet s1 et s2\"\"\"\n        assert s1 in self.sommets and s2 in self.sommets, 'sommets inexistants'\n        i1 = self.sommets.index(s1)\n        i2 = self.sommets.index(s2)\n        \"\"\" ajoute un arc allant de s1 \u00e0 s2 \"\"\"\n        self.matrice[i1][i2] = 1\n        if not self.oriente:\n            self.matrice[i2][i1] = 1\n</code></pre> <p>Cr\u00e9ons maintenant le graphe orient\u00e9 :</p> <pre><code>G = Graphe(oriente=True)\nG.ajouter_sommet(\"A\")   # sommet A\nG.ajouter_sommet(\"B\")   # sommet B\nG.ajouter_sommet(\"C\")   # sommet C\nG.ajouter_sommet(\"D\")   # sommet D\nG.ajouter_arc(\"A\", \"B\")  # arc de A vers B\nG.ajouter_arc(\"A\", \"D\")  # arc de A vers D\nG.ajouter_arc(\"B\", \"D\")  # arc de B vers D\nG.ajouter_arc(\"C\", \"B\")  # arc de C vers B\nG.ajouter_arc(\"D\", \"B\")  # arc de D vers B\nG.ajouter_arc(\"D\", \"C\")  # arc de D vers C\n</code></pre> <p>Et ajoutons des m\u00e9thodes qui renvoient les voisins et le degr\u00e9 d'un n\u0153ud :</p> <pre><code>    def voisins(self, s):\n        \"\"\" renvoie les voisins de s\"\"\"\n        n = self.sommets.index(s)\n        v = []\n        for i in range(self.ordre()):\n            if self.matrice[n][i] == 1:\n                v.append(self.sommets[i])\n        return v\n\n    def degre(self, s):\n        \"\"\" renvoie le degre de s\"\"\"\n        n = self.sommets.index(s)\n        d = 0\n        for i in range(self.ordre()):\n            if self.matrice[n][i] == 1:    # les ar\u00eates partant de A\n                d += 1\n            if self.matrice[i][n] == 1:    # les ar\u00eates arrivant en A\n                d += 1\n        if self.oriente:\n            return d\n        # si le graphe n'est pas orient\u00e9, on a compt\u00e9 les ar\u00eates 2 fois\n        else:\n            return d//2\n</code></pre> <p>Affichons enfin la matrice avec un peu de formatage :</p> <pre><code>    def __str__(self):\n        # ligne avec les noms d'\u00e9tiquettes\n        affiche = '\\t' + '\\t'.join([str(s) for s in self.sommets]) + '\\n'\n        # pour chaque ligne\n        for ligne in range(len(self.matrice)):\n            # on affiche le nom du sommet\n            affiche = affiche + str(self.sommets[ligne]) + '\\t'\n            # les valeurs de chaque colonne\n            affiche = affiche + '\\t'.join([str(val) for val in self.matrice[ligne]])\n            # retour \u00e0 la ligne\n            affiche = affiche + '\\n'\n        return affiche\n\n&gt;&gt;&gt; print(G)\n    A   B   C   D   \nA   0   1   0   1   \nB   0   0   0   1   \nC   0   1   0   0   \nD   0   1   1   0   \n</code></pre> <p>Avantages et Inconv\u00e9nients de cette structure :</p> <ul> <li> <p>La dimension de la matrice est \u00e9gale au carr\u00e9 du nombre de sommets (\\(n \\times n\\)), ce qui peut repr\u00e9senter un important espace en m\u00e9moire.</p> </li> <li> <p>Le fonction pour obtenir les voisins d'un sommet a un co\u00fbt d'ordre \\(O(n)\\).</p> </li> </ul>"},{"location":"structures-de-donnees/8-graphes/#liste-ou-dictionnaire-dadjacence","title":"Liste ou dictionnaire d'adjacence","text":"<p>Cours</p> <p>Dans un graphe non-orient\u00e9, la liste d'adjacence associe chaque sommet \u00e0 la liste de ses voisins.</p> <p>Dans un graphe orient\u00e9, la liste des successeurs associe chaque sommet \u00e0 la liste des sommets que l'on peut atteindre directement par un arc \u00e0 partir de ce sommet ; et la liste des pr\u00e9d\u00e9cesseurs donne la liste des sommets menant \u00e0 ce sommet.</p> <p> </p> <p>Exemple : le dictionnaire d'adjacence du graphe ci-contre : </p> <p><pre><code>{A: [B, D],\n B: [D],\n C: [B],\n D: [B, C]}\n</code></pre> L'ordre des voisins d'un sommet n'a pas d'importance, et on ne veut pas dupliquer les voisins, on peut pr\u00e9f\u00e9rer utiliser des ensembles<sup>3</sup> : </p> <pre><code>{A: {B, D}, \n B: {D}, \n C: {B},  \n D: {B, C}}\n</code></pre> <p>Impl\u00e9mentons un graphe avec un dictionnaire d'adjacence dans une classe <code>Graphe</code> :</p> <pre><code>class Graphe:\n    \"\"\" \"\"\"\n    def __init__(self, oriente = True):\n        self.A = {}                # Dictionnaire d'adjacence\n        self.oriente = oriente     # Graphe orient\u00e9 ou pas\n\n    def est_vide(self):\n        return len(self.A) == 0\n\n    def ordre(self):\n        return len(self.A)\n\n    def __repr__(self):\n        return str(self.A)\n\n    def ajouter_sommet(self, x):\n        if not x in self.A:\n            self.A[x] = set()\n\n    def ajouter_arete(self, x, y):\n        \"\"\" Ajoute une ar\u00eate entre les sommets x et y \"\"\"\n        self.ajouter_sommet(x)\n        self.ajouter_sommet(y)\n        self.A[x].add(y)\n        if not self.oriente:\n            self.A[y].add(x)\n</code></pre> <p>Ajoutons quelques m\u00e9thodes :</p> <pre><code>    def voisins(self, x):\n        \"\"\" Renvoie l'ensemble des voisins du sommet x \"\"\"\n        return self.A[x]\n\n    def arete(self, x, y):\n        \"\"\" Renvoie True s'il existe une ar\u00eate entre les sommets x et y \"\"\"\n        return x in self.A[y]\u2003\n</code></pre> <p>Et cr\u00e9ons maitenant le graphe orient\u00e9 :</p> <pre><code>g = Graphe()\ng.ajouter_arete('A', 'B')\ng.ajouter_arete('A', 'D')\ng.ajouter_arete('B', 'D')\ng.ajouter_arete('C', 'B')\ng.ajouter_arete('D', 'B')\ng.ajouter_arete('D', 'C')\nprint(g. A)\n</code></pre> <p>On peut ajouter des m\u00e9thodes qui renvoient les degr\u00e9s d'un n\u0153ud et ses voisins :</p> <pre><code>    def degre(self, x):\n        return len(self.A[x])\n\n    def voisin(self, x):\n        return self.A[x]\n</code></pre> <p>Avantages et Inconv\u00e9nients de cette structure : </p> <ul> <li> <p>les donn\u00e9es repr\u00e9sent\u00e9es par les sommets peuvent \u00eatre directement les cl\u00e9s du dictionnaire, sous r\u00e9serve d'\u00eatre hashable (dans le cas contraire, on utilisera, comme pour la matrice d'adjacence, des indices).</p> </li> <li> <p>le dictionnaire d'un graphe contenant beaucoup d'ar\u00eates occupe plus de m\u00e9moire que la matrice d'adjacence.</p> </li> <li> <p>l'obtention des voisins d'un sommet est cette fois-ci une op\u00e9ration en temps constant.</p> </li> </ul> <ol> <li> <p>En ajoutant les degr\u00e9s de chaque sommet (c'est \u00e0 dire le nombre d'ar\u00eates issues de ce sommet), on comptabilise deux fois chaque ar\u00eate (une fois avec le sommet d'une extr\u00e9mit\u00e9 et une seconde fois avec le sommet de l'autre extr\u00e9mit\u00e9 de l'ar\u00eate).  Il en d\u00e9coule que la somme des degr\u00e9s des sommets est n\u00e9cessairement paire et donc que le nombre de sommets de degr\u00e9 impair est pair.\u00a0\u21a9</p> </li> <li> <p>voir \"Briller en Soci\u00e9t\u00e9 #27: Les 7 ponts de K\u00f6nigsberg\" sur https://www.youtube.com/watch?v=F1G4srEXq2s \u21a9</p> </li> <li> <p>Les ensembles Python, de type <code>set</code>, ne sont pas au programme de NSI. Un ensemble est une collection d'\u00e9l\u00e9ments non ordonn\u00e9s, non index\u00e9s, qui n'accepte pas de contenir plusieurs fois le m\u00eame \u00e9l\u00e9ment. Les \u00e9l\u00e9ments d'un ensemble sont \u00e9crits entre accolades mais un ensemble est d\u00e9fini par la fonction <code>set()</code> (et pas par <code>{}</code> qui permet de d\u00e9finir un dictionnaire vide). On peut ajouter un \u00e9l\u00e9ment avec la m\u00e9thode <code>.add(</code>) et supprimer un \u00e9l\u00e9ment avec <code>.remove()</code>. On peut utiliser la fonction <code>len()</code> et le mot cl\u00e9 <code>in</code> comme pour les autres types construits.\u00a0\u21a9</p> </li> </ol>"}]}